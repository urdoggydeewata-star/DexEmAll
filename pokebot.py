import os
import sys
import pathlib
import json
from io import BytesIO

try:
    from PIL import Image  # type: ignore
except Exception:
    Image = None  # type: ignore
import random
import math
import asyncio
import inspect
import copy
import time
import hashlib
import re
import difflib
import urllib.request
import datetime as dt
import zipfile
from datetime import datetime, timedelta, timezone
from collections.abc import Mapping
from pathlib import Path
from typing import Tuple, Optional, List, Sequence, Any, Literal, Dict, TYPE_CHECKING
from dataclasses import dataclass, field

# Load .env BEFORE any project imports that read env vars (e.g., pvp/db_pool)
from dotenv import load_dotenv
sys.path.insert(0, str(pathlib.Path(__file__).resolve().parent))
load_dotenv()

import aiohttp
import discord
from discord.ext import commands
from discord import app_commands, ui, Interaction, Embed

from pvp.engine import build_mon
from pvp.panel import _base_pp, _max_pp
import pvp.panel as _pvp_panel
if TYPE_CHECKING:
    from pvp.engine import Mon
    from pvp.panel import BattleState

import lib
from lib import db
from lib import register_stats
from lib.owner_settings import load_owner_settings
from lib.market_catalog import (
    MARKET_DISPLAY_NAMES,
    MARKET_PRICE_CATALOG,
    MARKET_SELL_PRICES,
    market_display_name as _catalog_market_display_name,
    market_item_variants as _catalog_market_item_variants,
    normalize_market_key as _catalog_normalize_market_key,
    resolve_market_key as _catalog_resolve_market_key,
)
from lib.adventure_history import (
    history_entry as _history_entry,
    history_pop as _history_pop,
    history_push as _history_push,
)
try:
    from lib import db_cache
except ImportError:
    db_cache = None
from lib.poke_ingest import ensure_species_and_learnsets
from lib.stats import generate_mon, calc_all_stats
from lib.team_import import parse_showdown_team, get_preset_team_names, get_preset_team, ParsedPokemon
from lib.legality import legal_moves, species_allowed
from lib.rules import rules_for
import lib.rules as _rules
from lib import evolution_mechanics as evo_mech
from lib import breeding_mechanics as breeding_mech
import pvp.sprites as _pvp_sprites

# Always use the shared lib.db pooled backend for command queries.
# The legacy db_async module can resolve to a local sqlite backend on some hosts,
# which causes missing-table errors and broken alias commands under load.
db_connect = db.connect
try:
    from tools.cache_everything import warm_cache, STATIC_TABLES
except ImportError:
    warm_cache = None
    STATIC_TABLES = []


def _patch_pvp_sprite_icon_fallback() -> None:
    """
    Ensure PvP panel rendering still produces an image when full front/back assets
    are missing and only icon sprites exist on disk.

    This patch wraps pvp.sprites.find_sprite and also updates pvp.renderer.find_sprite
    (renderer imports find_sprite by name), so render_turn_gif can fall back to icon.png.
    """
    try:
        original = getattr(_pvp_sprites, "find_sprite", None)
        if not callable(original):
            return
        if getattr(original, "_dex_icon_fallback_patch", False):
            return

        def _wrapped_find_sprite(
            species: str,
            *,
            gen: int,
            perspective: str,
            shiny: bool,
            female: bool,
            prefer_animated: bool = True,
            form: Optional[str] = None,
        ) -> Optional[Path]:
            p = original(
                species,
                gen=gen,
                perspective=perspective,
                shiny=shiny,
                female=female,
                prefer_animated=prefer_animated,
                form=form,
            )
            try:
                if p and Path(p).exists():
                    return Path(p)
            except Exception:
                pass

            # Fallback: use icon from form-specific folder first, then base species folder.
            try:
                candidates: list[Path] = []
                base_species = _pvp_sprites._norm_species(species)

                if form:
                    norm_form = _pvp_sprites._norm_species(form)
                    if norm_form.startswith(f"{base_species}-"):
                        form_folder_name = norm_form
                    else:
                        form_folder_name = f"{base_species}-{norm_form}"
                    candidates.append(_pvp_sprites.BASE_SPRITES_DIR / form_folder_name / "icon.png")

                candidates.append(_pvp_sprites.BASE_SPRITES_DIR / base_species / "icon.png")

                for icon_path in candidates:
                    if icon_path.exists() and icon_path.stat().st_size > 0:
                        return icon_path
            except Exception:
                pass
            return None

        _wrapped_find_sprite._dex_icon_fallback_patch = True  # type: ignore[attr-defined]
        _pvp_sprites.find_sprite = _wrapped_find_sprite

        # renderer imports find_sprite by value; patch renderer symbol too
        try:
            import pvp.renderer as _pvp_renderer
            _pvp_renderer.find_sprite = _wrapped_find_sprite
        except Exception:
            pass
    except Exception:
        pass


_patch_pvp_sprite_icon_fallback()


# Some deployments may run with a partially-migrated DB that lacks
# pokedex_forms. Cache this probe so commands fail soft instead of repeatedly
# throwing SQL errors (which can cascade into pool timeouts).
_POKEDEX_FORMS_TABLE_AVAILABLE: Optional[bool] = None
_OPTIONAL_TABLE_AVAILABILITY: dict[str, bool] = {}


def _is_missing_table_error(exc: Exception, table_name: str) -> bool:
    msg = str(exc or "").lower()
    t = str(table_name or "").lower()
    if not t:
        return False
    return (
        ("no such table" in msg and t in msg)
        or ("undefined table" in msg and t in msg)
        or ("relation" in msg and t in msg and "does not exist" in msg)
    )


def _is_optional_table_disabled(table_name: str) -> bool:
    return _OPTIONAL_TABLE_AVAILABILITY.get(str(table_name or "").lower(), True) is False


def _disable_optional_table(table_name: str) -> None:
    t = str(table_name or "").lower().strip()
    if t:
        _OPTIONAL_TABLE_AVAILABILITY[t] = False


async def _safe_optional_fetchone(
    conn: Any,
    sql: str,
    params: tuple[Any, ...] = (),
    *,
    tables: tuple[str, ...] = (),
) -> Any:
    check_tables = tuple(str(t or "").lower().strip() for t in tables if str(t or "").strip())
    if check_tables and any(_is_optional_table_disabled(t) for t in check_tables):
        return None
    cur = None
    try:
        cur = await conn.execute(sql, params)
        row = await cur.fetchone()
        return row
    except Exception as e:
        for t in check_tables:
            if _is_missing_table_error(e, t):
                _disable_optional_table(t)
                return None
        raise
    finally:
        if cur is not None:
            try:
                await cur.close()
            except Exception:
                pass


async def _safe_optional_fetchall(
    conn: Any,
    sql: str,
    params: tuple[Any, ...] = (),
    *,
    tables: tuple[str, ...] = (),
) -> list[Any]:
    check_tables = tuple(str(t or "").lower().strip() for t in tables if str(t or "").strip())
    if check_tables and any(_is_optional_table_disabled(t) for t in check_tables):
        return []
    cur = None
    try:
        cur = await conn.execute(sql, params)
        rows = await cur.fetchall()
        return list(rows or [])
    except Exception as e:
        for t in check_tables:
            if _is_missing_table_error(e, t):
                _disable_optional_table(t)
                return []
        raise
    finally:
        if cur is not None:
            try:
                await cur.close()
            except Exception:
                pass


async def _safe_pokedex_forms_fetchone(conn: Any, sql: str, params: tuple[Any, ...] = ()) -> Any:
    global _POKEDEX_FORMS_TABLE_AVAILABLE
    if _POKEDEX_FORMS_TABLE_AVAILABLE is False:
        return None
    row = await _safe_optional_fetchone(conn, sql, params, tables=("pokedex_forms",))
    if row is None and _is_optional_table_disabled("pokedex_forms"):
        _POKEDEX_FORMS_TABLE_AVAILABLE = False
    return row


async def _safe_pokedex_forms_fetchall(conn: Any, sql: str, params: tuple[Any, ...] = ()) -> list[Any]:
    global _POKEDEX_FORMS_TABLE_AVAILABLE
    if _POKEDEX_FORMS_TABLE_AVAILABLE is False:
        return []
    rows = await _safe_optional_fetchall(conn, sql, params, tables=("pokedex_forms",))
    if _is_optional_table_disabled("pokedex_forms"):
        _POKEDEX_FORMS_TABLE_AVAILABLE = False
    return rows

# Warm up renderer once to avoid first-GIF stall (no-op if renderer missing)
try:
    from pvp.renderer import render_turn_gif
    def _warm_renderer_once() -> None:
        try:
            render_turn_gif(
                battle_id="warmup",
                turn=1,
                pov="p1",
                gen=1,
                my_species="bulbasaur",
                my_shiny=False,
                my_female=False,
                my_level=5,
                my_hp_current=20,
                my_hp_max=20,
                my_team_alive=1,
                my_team_total=1,
                my_form=None,
                my_has_substitute=False,
                my_status=None,
                my_mega_evolved=False,
                my_dynamaxed=False,
                my_primal_reversion=None,
                opp_species="charmander",
                opp_shiny=False,
                opp_female=False,
                opp_level=5,
                opp_hp_current=19,
                opp_hp_max=19,
                opp_team_alive=1,
                opp_team_total=1,
                opp_form=None,
                opp_has_substitute=False,
                opp_status=None,
                opp_mega_evolved=False,
                opp_dynamaxed=False,
                opp_primal_reversion=None,
                canvas_size=(128, 96),
                duration_ms=80,
                hide_hp_text=True,
                nullscape_active=False,
                my_team_statuses=[None],
                opp_team_statuses=[None],
                my_team_hp=[(20, 20)],
                opp_team_hp=[(19, 19)],
                bg_key=None,
            )
        except Exception:
            pass
    _warm_renderer_once()
except Exception:
    pass

# Adventure privacy patch:
# Keep opponent move names hidden in the "Swapping" panel for adventure/rival battles.
def _patch_adventure_switch_embed_privacy() -> None:
    try:
        original = getattr(_pvp_panel, "_team_switch_embed", None)
        if not callable(original):
            return
        if getattr(original, "_dex_patch_hide_opponent_moves", False):
            return

        def _wrapped_team_switch_embed(user_id: int, st, description_override: Optional[str] = None):
            em = original(user_id, st, description_override)
            try:
                fmt = str(getattr(st, "fmt_label", "") or "").lower()
                hide_opp_moves = (
                    bool(getattr(st, "_hide_opponent_moves", False))
                    or fmt.startswith("adventure")
                    or fmt == "rival"
                )
                if not hide_opp_moves or em is None:
                    return em

                opp_id = st.p2_id if user_id == st.p1_id else st.p1_id
                opp_active = st._active(opp_id)
                if opp_active is None:
                    masked_block = "‚Äî"
                else:
                    name = _pvp_panel._format_pokemon_name(opp_active)
                    hp_bar = _pvp_panel._hp_bar_simple(opp_active.hp, opp_active.max_hp)
                    masked_block = (
                        f"**{name}** Lv{opp_active.level}\n"
                        f"{hp_bar}\n"
                        "**1.** ???„ÄÄ**2.** ???\n"
                        "**3.** ???„ÄÄ**4.** ???"
                    )

                for i, field in enumerate(list(em.fields)):
                    if str(getattr(field, "name", "")).strip().lower() == "opponent":
                        em.set_field_at(i, name=field.name, value=masked_block, inline=field.inline)
                        break
            except Exception:
                pass
            return em

        _wrapped_team_switch_embed._dex_patch_hide_opponent_moves = True  # type: ignore[attr-defined]
        _pvp_panel._team_switch_embed = _wrapped_team_switch_embed
    except Exception:
        pass

_patch_adventure_switch_embed_privacy()


def _patch_pvp_streaming_reliability() -> None:
    """
    Runtime patch for PvP streaming when only pokebot.py is deployable.

    - Keeps a stable public stream channel on battle state.
    - Sends an initial "battle started" stream panel.
    - Adds robust fallback if stream attachment send fails.
    - Posts a public clarification that private panels != public stream.
    """
    # Modern streaming behavior is implemented in pvp/panel.py.
    # Keep this runtime monkey-patch disabled to avoid double-posts or
    # conflicting stream formats when both paths exist.
    return
    try:
        # Modern pvp.panel already has reliable streaming with per-turn summary+image.
        # Do not override it from pokebot.py unless those helpers are missing.
        if (
            callable(getattr(_pvp_panel, "_send_stream_panel", None))
            and callable(getattr(_pvp_panel, "_resolve_stream_channel", None))
        ):
            return
        original_send_stream = getattr(_pvp_panel, "_send_stream_panel", None)
        if callable(original_send_stream) and not getattr(original_send_stream, "_dex_stream_patch", False):

            async def _wrapped_send_stream_panel(channel, st, turn_summary: Optional[str] = None, gif_file: Optional[Any] = None):
                stream_channel = channel
                if stream_channel is None or not hasattr(stream_channel, "send"):
                    stream_channel = getattr(st, "stream_channel", None)
                if stream_channel is None or not hasattr(stream_channel, "send"):
                    return None

                try:
                    turn_no = int(getattr(st, "turn", 0) or 0)
                except Exception:
                    turn_no = 0
                summary_text = str(turn_summary or "").strip()
                if not summary_text:
                    try:
                        cached_lines = [
                            str(line).strip()
                            for line in (getattr(st, "_last_turn_log", []) or [])
                            if str(line).strip()
                        ]
                        if cached_lines:
                            summary_text = "\n".join(cached_lines).strip()
                    except Exception:
                        summary_text = ""
                if not summary_text:
                    summary_text = "No significant actions this turn."

                stream_key = None
                try:
                    stream_key = (turn_no, summary_text)
                    if stream_key == getattr(st, "_stream_last_sent_key", None):
                        return getattr(st, "_last_stream_message", None)
                except Exception:
                    stream_key = None

                try:
                    st.stream_channel = stream_channel
                    st.stream_channel_id = getattr(stream_channel, "id", None)
                except Exception:
                    pass

                p1 = _pvp_panel._format_pokemon_name(st._active(st.p1_id))
                p2 = _pvp_panel._format_pokemon_name(st._active(st.p2_id))
                desc = f"Turn {getattr(st, 'turn', '?')} ‚Ä¢ {getattr(st, 'fmt_label', 'Battle')} (Gen {getattr(st, 'gen', '?')})"
                if summary_text:
                    _sum = summary_text
                    if len(_sum) > 2500:
                        _sum = "...\n" + _sum[-2300:]
                    desc += f"\n\n**Turn Summary:**\n{_sum}"
                field_text_fn = getattr(_pvp_panel, "_field_conditions_text", None)
                if callable(field_text_fn):
                    try:
                        field_text = field_text_fn(getattr(st, "field", None))
                        if field_text:
                            desc += f"\n{field_text}"
                    except Exception:
                        pass
                emb = discord.Embed(
                    title=f"üì∫ Battle Stream: **{p1}** vs **{p2}**",
                    description=desc,
                    color=discord.Color.purple(),
                )

                # Resolve a stream image file:
                # - use supplied gif_file when provided,
                # - otherwise render a fresh panel for this turn.
                file_obj = None
                gif_path_to_cleanup = None
                try:
                    if gif_file:
                        if isinstance(gif_file, tuple) and len(gif_file) == 2:
                            file_obj, gif_path_to_cleanup = gif_file
                        elif isinstance(gif_file, discord.File):
                            file_obj = gif_file
                        elif isinstance(gif_file, (Path, str)):
                            p = Path(gif_file)
                            if p.exists():
                                file_obj = discord.File(p, filename=p.name)
                                gif_path_to_cleanup = p
                    if file_obj is None:
                        render_fn = getattr(_pvp_panel, "_render_gif_for_panel", None)
                        if callable(render_fn):
                            render_result = await render_fn(st, st.p1_id, hide_hp_text=True)
                            if isinstance(render_result, tuple) and len(render_result) == 2:
                                file_obj, gif_path_to_cleanup = render_result
                            elif isinstance(render_result, discord.File):
                                file_obj = render_result
                    if file_obj is None:
                        static_fn = getattr(_pvp_panel, "_fallback_static_panel_file", None)
                        if callable(static_fn):
                            file_obj = static_fn(st, st.p1_id, hide_hp_text=True, filename_prefix="stream-panel")
                except Exception as e:
                    print(f"[StreamPatch] stream render fallback failed: {e}")

                msg = None
                try:
                    if file_obj is not None:
                        try:
                            emb.set_image(url=f"attachment://{file_obj.filename}")
                        except Exception:
                            pass
                        try:
                            # Preferred: embed + image
                            msg = await stream_channel.send(embed=emb, file=file_obj)
                        except Exception as e:
                            print(f"[StreamPatch] embed+file send failed: {e}")
                            # Fallback: text + image attachment (works even if embed path breaks)
                            plain_text = f"üì∫ Battle Stream: {p1} vs {p2}\n{desc}"
                            if len(plain_text) > 1800:
                                plain_text = plain_text[:1800] + "‚Ä¶"
                            msg = await stream_channel.send(content=plain_text, file=file_obj)
                    else:
                        # No image available; still send the embed summary
                        msg = await stream_channel.send(embed=emb)
                except Exception as e:
                    print(f"[StreamPatch] stream embed/image send failed: {e}")
                    try:
                        txt = f"üì∫ Stream update ‚Ä¢ Turn {getattr(st, 'turn', '?')} ‚Ä¢ {getattr(st, 'fmt_label', 'Battle')}"
                        if summary_text:
                            _sum = summary_text
                            if len(_sum) > 1500:
                                _sum = "...\n" + _sum[-1300:]
                            txt += f"\n{_sum}"
                        msg = await stream_channel.send(txt)
                    except Exception as e2:
                        print(f"[StreamPatch] stream text fallback failed: {e2}")
                        msg = None
                finally:
                    if file_obj is not None:
                        try:
                            file_obj.close()
                        except Exception:
                            pass
                    if gif_path_to_cleanup is not None:
                        try:
                            if Path(gif_path_to_cleanup).exists():
                                Path(gif_path_to_cleanup).unlink(missing_ok=True)
                        except Exception:
                            pass

                if msg is not None:
                    if stream_key is not None:
                        st._stream_last_sent_key = stream_key
                    st._last_stream_message = msg
                return msg

            _wrapped_send_stream_panel._dex_stream_patch = True  # type: ignore[attr-defined]
            _pvp_panel._send_stream_panel = _wrapped_send_stream_panel

        original_turn_loop = getattr(_pvp_panel, "_turn_loop", None)
        if callable(original_turn_loop) and not getattr(original_turn_loop, "_dex_stream_patch", False):

            async def _wrapped_turn_loop(st, p1_itx, p2_itx, *args, **kwargs):
                try:
                    st._p1_itx = p1_itx
                    st._p2_itx = p2_itx
                    if getattr(st, "stream_channel", None) is None:
                        ch = getattr(p1_itx, "channel", None) or getattr(p2_itx, "channel", None)
                        if ch is not None and hasattr(ch, "send"):
                            st.stream_channel = ch
                            st.stream_channel_id = getattr(ch, "id", None)

                    # Do not emit an image-only kickoff post; stream updates should
                    # mirror turn summaries (text + image together).
                    if bool(getattr(st, "streaming_enabled", False)) and not bool(getattr(st, "_stream_started", False)):
                        st._stream_started = True
                except Exception:
                    pass
                return await original_turn_loop(st, p1_itx, p2_itx, *args, **kwargs)

            _wrapped_turn_loop._dex_stream_patch = True  # type: ignore[attr-defined]
            _pvp_panel._turn_loop = _wrapped_turn_loop

        original_send_player_panel = getattr(_pvp_panel, "_send_player_panel", None)
        if callable(original_send_player_panel) and not getattr(original_send_player_panel, "_dex_stream_patch", False):

            async def _wrapped_send_player_panel(itx, st, for_user_id, view, gif_file=None, extra_lines=None):
                result = await original_send_player_panel(itx, st, for_user_id, view, gif_file, extra_lines)
                try:
                    if bool(getattr(st, "streaming_enabled", False)) and int(for_user_id) == int(getattr(st, "p1_id", -1)):
                        ch = getattr(st, "stream_channel", None) or getattr(itx, "channel", None)
                        if ch is not None and hasattr(ch, "send"):
                            st.stream_channel = ch
                            st.stream_channel_id = getattr(ch, "id", None)
                            summary_lines = list(getattr(st, "_last_turn_log", []) or [])
                            summary_lines = [str(line).strip() for line in summary_lines if str(line).strip()]
                            if not summary_lines:
                                return result
                            summary_text = "\n".join(summary_lines).strip()
                            send_fn = getattr(_pvp_panel, "_send_stream_panel", None)
                            if callable(send_fn):
                                # Let stream panel render its own public-safe image.
                                await send_fn(ch, st, summary_text, None)
                except Exception as e:
                    print(f"[StreamPatch] _send_player_panel stream mirror failed: {e}")
                return result

            _wrapped_send_player_panel._dex_stream_patch = True  # type: ignore[attr-defined]
            _pvp_panel._send_player_panel = _wrapped_send_player_panel

        accept_view_cls = getattr(_pvp_panel, "AcceptView", None)
        if accept_view_cls is not None:
            original_start_if_ready = getattr(accept_view_cls, "_start_if_ready", None)
            if callable(original_start_if_ready) and not getattr(original_start_if_ready, "_dex_stream_patch", False):

                async def _wrapped_start_if_ready(self, itx):
                    result = await original_start_if_ready(self, itx)
                    return result

                _wrapped_start_if_ready._dex_stream_patch = True  # type: ignore[attr-defined]
                accept_view_cls._start_if_ready = _wrapped_start_if_ready
    except Exception:
        pass


_patch_pvp_streaming_reliability()


def _patch_pvp_capture_reliability() -> None:
    """
    Runtime patch for Pok√© Ball capture reliability when only pokebot.py is deployable.

    Fixes observed regressions where:
    - Master Ball could fail due upstream parsing exceptions.
    - Ball IDs with mixed separators/unicode dashes weren't normalized robustly.
    """
    try:
        basic = getattr(_pvp_panel, "_BALLS_BASIC", {}) or {}
        aliases = getattr(_pvp_panel, "_BALL_NAME_ALIASES", {}) or {}

        original_normalize_item = getattr(_pvp_panel, "_normalize_item", None)
        if callable(original_normalize_item) and not getattr(original_normalize_item, "_dex_capture_patch", False):
            def _wrapped_normalize_item(name: str) -> str:
                n = str(name or "").strip().lower().replace("√©", "e")
                for ch in ("-", "_", "‚Äì", "‚Äî", "‚Äë", "‚Äí", "‚àí", "Ôπ£", "Ôºç", ":"):
                    n = n.replace(ch, " ")
                return " ".join(n.split())
            _wrapped_normalize_item._dex_capture_patch = True  # type: ignore[attr-defined]
            _pvp_panel._normalize_item = _wrapped_normalize_item

        original_normalize_ball = getattr(_pvp_panel, "_normalize_ball_name", None)
        if callable(original_normalize_ball) and not getattr(original_normalize_ball, "_dex_capture_patch", False):
            def _wrapped_normalize_ball_name(name: str) -> str:
                try:
                    n = _pvp_panel._normalize_item(name)  # type: ignore[attr-defined]
                except Exception:
                    n = str(name or "").strip().lower().replace("-", " ").replace("_", " ")
                compact = "".join(ch for ch in n if ch.isalnum())
                if n in basic:
                    return n
                if compact in aliases:
                    return aliases[compact]
                return n
            _wrapped_normalize_ball_name._dex_capture_patch = True  # type: ignore[attr-defined]
            _pvp_panel._normalize_ball_name = _wrapped_normalize_ball_name

        original_ball_multiplier = getattr(_pvp_panel, "_ball_multiplier", None)
        if callable(original_ball_multiplier) and not getattr(original_ball_multiplier, "_dex_capture_patch", False):
            def _wrapped_ball_multiplier(ball_name, mon, battle_state):
                b = _pvp_panel._normalize_ball_name(ball_name)  # type: ignore[attr-defined]
                if b == "master ball":
                    return 9999.0
                try:
                    return float(original_ball_multiplier(ball_name, mon, battle_state))
                except Exception:
                    base = basic.get(b, 1.0)
                    return float(base if base not in (None, 0) else 1.0)
            _wrapped_ball_multiplier._dex_capture_patch = True  # type: ignore[attr-defined]
            _pvp_panel._ball_multiplier = _wrapped_ball_multiplier

        original_attempt_capture = getattr(_pvp_panel, "_attempt_capture", None)
        if callable(original_attempt_capture) and not getattr(original_attempt_capture, "_dex_capture_patch", False):
            def _wrapped_attempt_capture(mon, ball_name, battle_state):
                b = _pvp_panel._normalize_ball_name(ball_name)  # type: ignore[attr-defined]
                if b == "master ball":
                    return True, 1
                try:
                    return original_attempt_capture(mon, ball_name, battle_state)
                except Exception as e:
                    try:
                        print(f"[CapturePatch] _attempt_capture fallback: {e}")
                    except Exception:
                        pass
                    try:
                        ball_mod = float(_pvp_panel._ball_multiplier(ball_name, mon, battle_state))  # type: ignore[attr-defined]
                        if ball_mod >= 9999:
                            return True, 1
                        base_rate = int(float(getattr(mon, "capture_rate", 45) or 45))
                        base_rate = max(1, min(255, base_rate))
                        max_hp = max(1, int(getattr(mon, "max_hp", 1) or 1))
                        hp = max(1, int(getattr(mon, "hp", 1) or 1))
                        status_fn = getattr(_pvp_panel, "_status_bonus", None)
                        status_mod = float(status_fn(getattr(mon, "status", None))) if callable(status_fn) else 1.0
                        a = ((3 * max_hp - 2 * hp) * base_rate * max(0.1, ball_mod) * max(1.0, status_mod)) / (3 * max_hp)
                        if a >= 255:
                            return True, 4
                        import math as _m
                        bval = int(65536 / _m.pow(16711680 / max(1, int(a)), 0.25))
                        shakes = 0
                        for _ in range(4):
                            if random.randint(0, 65535) < bval:
                                shakes += 1
                            else:
                                break
                        return shakes == 4, shakes
                    except Exception:
                        return False, 0
            _wrapped_attempt_capture._dex_capture_patch = True  # type: ignore[attr-defined]
            _pvp_panel._attempt_capture = _wrapped_attempt_capture
    except Exception:
        pass


_patch_pvp_capture_reliability()

# =========================
#  Terastallization helpers
# =========================
VALID_TERA_TYPES: tuple[str, ...] = (
    "normal", "fire", "water", "electric", "grass", "ice",
    "fighting", "poison", "ground", "flying", "psychic", "bug",
    "rock", "ghost", "dragon", "dark", "steel", "fairy", "stellar"
)


def _normalize_type_id(value: Any) -> str | None:
    if value is None:
        return None
    s = str(value).strip().lower()
    s = s.replace("type", "").replace("_", "-").replace(" ", "-")
    return s or None


def _extract_species_types(entry: Mapping[str, Any]) -> list[str]:
    raw = entry.get("types")
    if isinstance(raw, str):
        try:
            raw = json.loads(raw)
        except Exception:
            raw = [raw]
    if raw is None:
        return []
    types: list[str] = []
    for item in raw:
        norm = _normalize_type_id(item)
        if norm and norm not in types:
            types.append(norm)
    return types


def _roll_default_tera_type(types: Sequence[str]) -> str | None:
    if not types:
        return None
    return random.choice(list(types))


# =========================
#  Config / Intents
# =========================
# Modern EXP Share (Gen VI+ behavior): when True, all non-fainted party mons gain full EXP.
# Default to off unless explicitly enabled via environment so participant-only gains
# remain the baseline when no Exp Share effect is present.
EXP_SHARE_ALWAYS_ON = str(os.getenv("EXP_SHARE_ALWAYS_ON", "0")).strip().lower() in {"1", "true", "yes", "on"}

# .env is already loaded above before importing db
TOKEN = (os.getenv("DISCORD_TOKEN") or "").strip()
if not TOKEN:
    raise RuntimeError("Missing DISCORD_TOKEN in .env ‚Äî add DISCORD_TOKEN=your_bot_token to .env")

intents = discord.Intents.default()
intents.guilds = True
intents.members = True            # requires Members intent enabled in Dev Portal if you really need it
intents.messages = True
intents.message_content = True    # keep True if you still use prefix commands elsewhere

# Owner-editable runtime settings (IDs/channels/roles live in config/owner_settings.json).
_OWNER_SETTINGS = load_owner_settings()

# ==== OWNER / ADMIN SETTINGS ====
OWNER_IDS: set[int] = set(_OWNER_SETTINGS.owner_ids)
STATIC_ADMIN_IDS: set[int] = set(_OWNER_SETTINGS.admin_ids)
BANNED_IDS: frozenset[int] = frozenset(_OWNER_SETTINGS.banned_ids)
CODE_BYPASS_IDS: frozenset[int] = frozenset(_OWNER_SETTINGS.code_bypass_ids)

DEV_GUILD_ID = int(_OWNER_SETTINGS.dev_guild_id)
DEV_GUILD = discord.Object(id=DEV_GUILD_ID)

# Embed echo settings
EMBED_ECHO_GUILD_ID: int | None = _OWNER_SETTINGS.embed_echo_guild_id
EMBED_ECHO_CHANNEL_IDS: set[int] = set(_OWNER_SETTINGS.embed_echo_channel_ids)
EMBED_ECHO_USER_IDS: set[int] | None = (
    set(_OWNER_SETTINGS.embed_echo_user_ids)
    if _OWNER_SETTINGS.embed_echo_user_ids is not None
    else None
)
EMBED_ECHO_DELETE_SOURCE = bool(_OWNER_SETTINGS.embed_echo_delete_source)
EMBED_ECHO_IGNORE_PREFIX_COMMANDS = bool(_OWNER_SETTINGS.embed_echo_ignore_prefix_commands)

# Verification button settings
VERIFY_GUILD_ID = int(_OWNER_SETTINGS.verify_guild_id)
VERIFY_CHANNEL_ID = int(_OWNER_SETTINGS.verify_channel_id)
VERIFY_ROLE_ID = int(_OWNER_SETTINGS.verify_role_id)
VERIFY_BUTTON_CUSTOM_ID = str(_OWNER_SETTINGS.verify_button_custom_id)

# Beta claim settings
BETA_ANNOUNCEMENT_CHANNEL_ID = int(_OWNER_SETTINGS.beta_announcement_channel_id)
BETA_CLAIM_CUSTOM_ID = str(_OWNER_SETTINGS.beta_claim_custom_id)

# Access code gate: users must run /code <code> before using the bot (set BOT_ACCESS_CODE in .env)
BOT_ACCESS_CODE: str = (os.getenv("BOT_ACCESS_CODE") or "").strip()

_ACCESS_VERIFY_CACHE_TTL_SECONDS = 21600.0
_ACCESS_VERIFY_CACHE: dict[int, tuple[bool, float]] = {}
_USER_GEN_CACHE_TTL_SECONDS = 300.0
_USER_GEN_CACHE: dict[str, tuple[int, float]] = {}
_ADMIN_CHECK_CACHE_TTL_SECONDS = 120.0
_ADMIN_CHECK_CACHE: dict[str, tuple[bool, float]] = {}
_REQUIRED_ROLE_CACHE_TTL_SECONDS = 21600.0
_REQUIRED_ROLE_CACHE: dict[int, tuple[bool, float]] = {}
_REQUIRED_ROLE_FETCH_INFLIGHT: dict[int, asyncio.Task[bool]] = {}
_ROLE_GATE_EXEMPT_CACHE_TTL_SECONDS = 1800.0
_ROLE_GATE_EXEMPT_CACHE: dict[int, tuple[bool, float]] = {}
_ROLE_GATE_EXEMPT_TABLE_READY = False
_ROLE_GATE_EXEMPT_TABLE_LOCK = asyncio.Lock()
_ROLE_GATE_EXEMPT_TABLE_LAST_ATTEMPT_TS = 0.0
_ROLE_GATE_EXEMPT_TABLE_RETRY_SECONDS = 60.0
_REQUIRED_ROLE_BLOCK_MESSAGE = (
    f"‚ùå You need <@&{VERIFY_ROLE_ID}> in the OS server to use this bot.\n"
    "Join the OS server and complete verification first."
)


def _get_cached_access_verified(user_id: int) -> Optional[bool]:
    rec = _ACCESS_VERIFY_CACHE.get(int(user_id))
    if rec is None:
        return None
    val, ts = rec
    if (time.time() - float(ts)) > _ACCESS_VERIFY_CACHE_TTL_SECONDS:
        _ACCESS_VERIFY_CACHE.pop(int(user_id), None)
        return None
    return bool(val)


def _set_cached_access_verified(user_id: int, verified: bool) -> None:
    _ACCESS_VERIFY_CACHE[int(user_id)] = (bool(verified), float(time.time()))


def _get_cached_user_gen(user_id: str) -> Optional[int]:
    uid = str(user_id)
    rec = _USER_GEN_CACHE.get(uid)
    if rec is None:
        return None
    val, ts = rec
    if (time.time() - float(ts)) > _USER_GEN_CACHE_TTL_SECONDS:
        _USER_GEN_CACHE.pop(uid, None)
        return None
    try:
        return int(val)
    except Exception:
        return None


def _set_cached_user_gen(user_id: str, generation: int) -> None:
    _USER_GEN_CACHE[str(user_id)] = (int(generation), float(time.time()))


def _get_cached_admin_check(user_id: str) -> Optional[bool]:
    uid = str(user_id)
    rec = _ADMIN_CHECK_CACHE.get(uid)
    if rec is None:
        return None
    val, ts = rec
    if (time.time() - float(ts)) > _ADMIN_CHECK_CACHE_TTL_SECONDS:
        _ADMIN_CHECK_CACHE.pop(uid, None)
        return None
    return bool(val)


def _set_cached_admin_check(user_id: str, is_admin: bool) -> None:
    _ADMIN_CHECK_CACHE[str(user_id)] = (bool(is_admin), float(time.time()))


def _get_cached_required_role(user_id: int | str) -> Optional[bool]:
    try:
        uid = int(user_id)
    except Exception:
        return None
    rec = _REQUIRED_ROLE_CACHE.get(uid)
    if rec is None:
        return None
    val, ts = rec
    if (time.time() - float(ts)) > _REQUIRED_ROLE_CACHE_TTL_SECONDS:
        _REQUIRED_ROLE_CACHE.pop(uid, None)
        return None
    return bool(val)


def _set_cached_required_role(user_id: int | str, has_role: bool) -> None:
    try:
        uid = int(user_id)
    except Exception:
        return
    _REQUIRED_ROLE_CACHE[uid] = (bool(has_role), float(time.time()))


def _get_cached_role_gate_exempt(user_id: int | str) -> Optional[bool]:
    try:
        uid = int(user_id)
    except Exception:
        return None
    rec = _ROLE_GATE_EXEMPT_CACHE.get(uid)
    if rec is None:
        return None
    val, ts = rec
    if (time.time() - float(ts)) > _ROLE_GATE_EXEMPT_CACHE_TTL_SECONDS:
        _ROLE_GATE_EXEMPT_CACHE.pop(uid, None)
        return None
    return bool(val)


def _set_cached_role_gate_exempt(user_id: int | str, is_exempt: bool) -> None:
    try:
        uid = int(user_id)
    except Exception:
        return
    _ROLE_GATE_EXEMPT_CACHE[uid] = (bool(is_exempt), float(time.time()))


async def _ensure_role_gate_exempt_table() -> None:
    global _ROLE_GATE_EXEMPT_TABLE_READY, _ROLE_GATE_EXEMPT_TABLE_LAST_ATTEMPT_TS
    if _ROLE_GATE_EXEMPT_TABLE_READY:
        return
    now = float(time.time())
    if (now - float(_ROLE_GATE_EXEMPT_TABLE_LAST_ATTEMPT_TS)) < _ROLE_GATE_EXEMPT_TABLE_RETRY_SECONDS:
        return
    async with _ROLE_GATE_EXEMPT_TABLE_LOCK:
        if _ROLE_GATE_EXEMPT_TABLE_READY:
            return
        now = float(time.time())
        if (now - float(_ROLE_GATE_EXEMPT_TABLE_LAST_ATTEMPT_TS)) < _ROLE_GATE_EXEMPT_TABLE_RETRY_SECONDS:
            return
        _ROLE_GATE_EXEMPT_TABLE_LAST_ATTEMPT_TS = now
        try:
            async with db.session() as conn:
                await conn.execute(
                    """
                    CREATE TABLE IF NOT EXISTS role_gate_exempt_users (
                      user_id TEXT PRIMARY KEY,
                      added_by TEXT,
                      note TEXT,
                      added_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                await conn.commit()
            _ROLE_GATE_EXEMPT_TABLE_READY = True
        except Exception:
            _ROLE_GATE_EXEMPT_TABLE_READY = False


async def _is_role_gate_exempt(user_id: int | str, *, force_refresh: bool = False) -> bool:
    try:
        uid = int(user_id)
    except Exception:
        return False
    if not force_refresh:
        cached = _get_cached_role_gate_exempt(uid)
        if cached is not None:
            return bool(cached)
    val = False
    try:
        await _ensure_role_gate_exempt_table()
        if not _ROLE_GATE_EXEMPT_TABLE_READY:
            _set_cached_role_gate_exempt(uid, False)
            return False
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT 1 FROM role_gate_exempt_users WHERE user_id = ? LIMIT 1",
                (str(uid),),
            )
            row = await cur.fetchone()
            await cur.close()
        val = bool(row)
    except Exception:
        val = False
    _set_cached_role_gate_exempt(uid, val)
    return val


async def _grant_role_gate_exempt(
    user_id: int | str,
    *,
    added_by: int | str | None = None,
    note: str | None = None,
) -> bool:
    try:
        uid = int(user_id)
    except Exception:
        return False
    try:
        await _ensure_role_gate_exempt_table()
        async with db.session() as conn:
            await conn.execute(
                """
                INSERT INTO role_gate_exempt_users (user_id, added_by, note)
                VALUES (?, ?, ?)
                ON CONFLICT (user_id) DO UPDATE SET
                  added_by = excluded.added_by,
                  note = excluded.note
                """,
                (
                    str(uid),
                    (str(added_by) if added_by is not None else None),
                    ((str(note).strip() or None) if note is not None else None),
                ),
            )
            await conn.commit()
        _set_cached_role_gate_exempt(uid, True)
        return True
    except Exception:
        return False


async def _revoke_role_gate_exempt(user_id: int | str) -> bool:
    try:
        uid = int(user_id)
    except Exception:
        return False
    try:
        await _ensure_role_gate_exempt_table()
        async with db.session() as conn:
            await conn.execute(
                "DELETE FROM role_gate_exempt_users WHERE user_id = ?",
                (str(uid),),
            )
            await conn.commit()
        _ROLE_GATE_EXEMPT_CACHE.pop(uid, None)
        return True
    except Exception:
        return False


async def _list_role_gate_exempt(limit: int = 100) -> list[dict]:
    out: list[dict] = []
    lim = max(1, min(int(limit or 100), 500))
    try:
        await _ensure_role_gate_exempt_table()
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT user_id, added_by, note, added_at FROM role_gate_exempt_users ORDER BY added_at DESC LIMIT ?",
                (lim,),
            )
            rows = await cur.fetchall()
            await cur.close()
        for row in rows or []:
            if hasattr(row, "keys"):
                out.append(dict(row))
            else:
                out.append(
                    {
                        "user_id": row[0] if len(row) > 0 else None,
                        "added_by": row[1] if len(row) > 1 else None,
                        "note": row[2] if len(row) > 2 else None,
                        "added_at": row[3] if len(row) > 3 else None,
                    }
                )
    except Exception:
        return []
    return out


def _parse_user_id_input(raw: str | int | None) -> Optional[int]:
    if raw is None:
        return None
    s = str(raw).strip()
    if s.startswith("<@") and s.endswith(">"):
        s = s.strip("<@!>")
    return int(s) if s.isdigit() else None


def _is_verify_button_interaction(interaction: discord.Interaction) -> bool:
    try:
        data = interaction.data
        if not isinstance(data, dict):
            return False
        return str(data.get("custom_id", "")).strip() == VERIFY_BUTTON_CUSTOM_ID
    except Exception:
        return False


async def _has_required_os_role(
    user_id: int | str,
    *,
    force_refresh: bool = False,
    interaction: Optional[discord.Interaction] = None,
) -> bool:
    try:
        uid = int(user_id)
    except Exception:
        return False
    if not force_refresh:
        cached = _get_cached_required_role(uid)
        if cached is not None:
            return bool(cached)

    # Fast path for slash interactions inside the verification guild:
    # use the interaction member payload directly (no API fetch).
    if interaction is not None:
        try:
            if int(getattr(interaction, "guild_id", 0) or 0) == VERIFY_GUILD_ID:
                member = interaction.user
                roles = getattr(member, "roles", None)
                if roles is not None:
                    has_role = any(int(r.id) == VERIFY_ROLE_ID for r in roles)
                    _set_cached_required_role(uid, bool(has_role))
                    return bool(has_role)
        except Exception:
            pass

    async def _resolve_required_role() -> bool:
        guild = bot.get_guild(VERIFY_GUILD_ID)
        if guild is None:
            return False
        member = guild.get_member(uid)
        if member is None:
            try:
                member = await guild.fetch_member(uid)
            except (discord.NotFound, discord.Forbidden, discord.HTTPException):
                member = None
            except Exception:
                member = None
        return bool(member and any(int(r.id) == VERIFY_ROLE_ID for r in getattr(member, "roles", [])))

    # Coalesce concurrent role fetches for the same user.
    inflight = _REQUIRED_ROLE_FETCH_INFLIGHT.get(uid)
    if inflight is not None:
        try:
            has_role = bool(await inflight)
            _set_cached_required_role(uid, has_role)
            return has_role
        except Exception:
            pass

    task: asyncio.Task[bool] = asyncio.create_task(_resolve_required_role())
    _REQUIRED_ROLE_FETCH_INFLIGHT[uid] = task
    try:
        has_role = bool(await task)
    except Exception:
        has_role = False
    finally:
        if _REQUIRED_ROLE_FETCH_INFLIGHT.get(uid) is task:
            _REQUIRED_ROLE_FETCH_INFLIGHT.pop(uid, None)
    _set_cached_required_role(uid, has_role)
    return has_role


async def _send_required_role_block(interaction: discord.Interaction) -> None:
    try:
        if interaction.response.is_done():
            await interaction.followup.send(_REQUIRED_ROLE_BLOCK_MESSAGE, ephemeral=True)
        else:
            await interaction.response.send_message(_REQUIRED_ROLE_BLOCK_MESSAGE, ephemeral=True)
    except Exception:
        pass


async def _check_required_role_interaction(
    interaction: discord.Interaction, *, allow_verify_button: bool = False
) -> bool:
    if not interaction.user:
        return False
    if int(interaction.user.id) in OWNER_IDS:
        return True
    if allow_verify_button and _is_verify_button_interaction(interaction):
        return True
    # Fast path: most users should pass via required role check; avoid DB lookup
    # for role-gate exemptions unless role check fails.
    if await _has_required_os_role(interaction.user.id, interaction=interaction):
        return True
    if await _is_role_gate_exempt(interaction.user.id):
        return True
    await _send_required_role_block(interaction)
    return False


def _is_static_admin(user_id: int | str) -> bool:
    try:
        uid = int(user_id)
    except Exception:
        return False
    return uid in OWNER_IDS or uid in STATIC_ADMIN_IDS


async def _is_admin_user(user_id: int | str) -> bool:
    if _is_static_admin(user_id):
        return True
    uid = str(user_id)
    cached = _get_cached_admin_check(uid)
    if cached is not None:
        return bool(cached)
    try:
        val = bool(await db.is_admin(uid))
    except Exception:
        val = False
    _set_cached_admin_check(uid, val)
    return val


class _BannedCheckTree(app_commands.CommandTree):
    """CommandTree that blocks banned users and enforces access gates."""

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if not interaction.user:
            return await super().interaction_check(interaction)
        uid = interaction.user.id

        # 1) Banned users
        if uid in BANNED_IDS:
            try:
                await interaction.response.send_message(
                    "‚ùå You are banned from using this bot.",
                    ephemeral=True,
                )
            except discord.DiscordException:
                pass
            return False

        # 2) Role gate: user must hold OS verification role
        if not await _check_required_role_interaction(interaction):
            return False

        # 3) Access code gate (skip if no code configured)
        if BOT_ACCESS_CODE:
            bypass = uid in (OWNER_IDS | CODE_BYPASS_IDS)
            cmd_name = (interaction.data or {}).get("name", "")
            if not bypass and cmd_name != "code":
                verified = _get_cached_access_verified(uid)
                if verified is None:
                    verified = await db.is_access_verified(str(uid))
                    _set_cached_access_verified(uid, bool(verified))
                if not verified:
                    try:
                        await interaction.response.send_message(
                            "üîí You need to enter the access code first.\n"
                            "Use `/code <your_code>` to unlock the bot.",
                            ephemeral=True,
                        )
                    except discord.DiscordException:
                        pass
                    return False

        return await super().interaction_check(interaction)


bot = commands.Bot(command_prefix='.', intents=intents, tree_cls=_BannedCheckTree)
# Enforce role-gate for all UI interactions (buttons/selects/modals), including in other servers.
_ORIG_VIEW_INTERACTION_CHECK = discord.ui.View.interaction_check
_ORIG_MODAL_INTERACTION_CHECK = discord.ui.Modal.interaction_check


async def _role_gated_view_interaction_check(self, interaction: discord.Interaction) -> bool:
    if not await _check_required_role_interaction(interaction, allow_verify_button=True):
        return False
    return await _ORIG_VIEW_INTERACTION_CHECK(self, interaction)


async def _role_gated_modal_interaction_check(self, interaction: discord.Interaction) -> bool:
    if not await _check_required_role_interaction(interaction):
        return False
    return await _ORIG_MODAL_INTERACTION_CHECK(self, interaction)


if not getattr(discord.ui.View.interaction_check, "_required_role_gate_patch", False):
    _role_gated_view_interaction_check._required_role_gate_patch = True  # type: ignore[attr-defined]
    discord.ui.View.interaction_check = _role_gated_view_interaction_check

if not getattr(discord.ui.Modal.interaction_check, "_required_role_gate_patch", False):
    _role_gated_modal_interaction_check._required_role_gate_patch = True  # type: ignore[attr-defined]
    discord.ui.Modal.interaction_check = _role_gated_modal_interaction_check


@bot.check
async def _required_role_prefix_command_check(ctx: commands.Context) -> bool:
    if not getattr(ctx, "author", None):
        return False
    if int(ctx.author.id) in OWNER_IDS:
        return True
    # Check required role first to avoid a DB read for non-exempt users.
    if await _has_required_os_role(ctx.author.id):
        return True
    if await _is_role_gate_exempt(ctx.author.id):
        return True
    try:
        await ctx.reply(_REQUIRED_ROLE_BLOCK_MESSAGE, mention_author=False)
    except Exception:
        pass
    return False

# ==== OWNER / ADMIN CHECKS ====


class BetaClaimView(discord.ui.View):
    """One-time Claim button for beta token announcement. First clicker gets 1 token; button is removed."""

    def __init__(self, *, timeout: float | None = None):
        super().__init__(timeout=timeout)

    @discord.ui.button(label="Claim", style=discord.ButtonStyle.primary, custom_id=BETA_CLAIM_CUSTOM_ID)
    async def claim_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await interaction.response.defer(ephemeral=False)
        except Exception:
            return
        message_id = interaction.message.id if interaction.message else None
        user_id = str(interaction.user.id)
        if not message_id:
            try:
                await interaction.followup.send("‚ùå Could not identify message.", ephemeral=True)
            except Exception:
                pass
            return
        try:
            async with db.session() as conn:
                cur = await conn.execute("SELECT 1 FROM beta_claims WHERE message_id = ? LIMIT 1", (message_id,))
                row = await cur.fetchone()
                await cur.close()
                if row:
                    await interaction.followup.send("‚ùå This reward has already been claimed.", ephemeral=True)
                    return
                await conn.execute(
                    """
                    INSERT INTO users (user_id, created_at, coins, currencies, beta_tokens)
                    VALUES (?, CURRENT_TIMESTAMP, 0, '{"coins": 0}'::jsonb, 1)
                    ON CONFLICT (user_id) DO UPDATE SET
                      beta_tokens = COALESCE(users.beta_tokens, 0) + 1
                    """,
                    (user_id,),
                )
                await conn.execute("INSERT INTO beta_claims (message_id) VALUES (?) ON CONFLICT (message_id) DO NOTHING", (message_id,))
                await conn.commit()
            try:
                await interaction.message.edit(view=None)
            except Exception:
                pass
            await interaction.followup.send("‚úÖ You claimed **1 Beta Token**! It has been added to your account.", ephemeral=True)
        except Exception as e:
            try:
                await interaction.followup.send(f"‚ùå Something went wrong: {e}", ephemeral=True)
            except Exception:
                pass
            import traceback
            traceback.print_exc()


# Beta claim view is created in on_ready() (needs a running event loop) and stored on bot.beta_claim_view


def owners_only():
    """Allow only owner IDs from owner settings."""
    async def predicate(interaction: discord.Interaction) -> bool:
        if interaction.user and interaction.user.id in OWNER_IDS:
            return True
        await interaction.response.send_message("‚ùå Owner only.", ephemeral=True)
        return False
    return app_commands.check(predicate)

def admin_only():
    """Allow static admins/owners and DB admins."""
    async def predicate(interaction: discord.Interaction) -> bool:
        try:
            if await _is_admin_user(interaction.user.id):
                return True
        except Exception:
            pass
        await interaction.response.send_message(
            "‚ùå You are not allowed to use this command (admin only).",
            ephemeral=True
        )
        return False
    return app_commands.check(predicate)
DB_WRITE_LOCK = asyncio.Lock()

def _close_discord_files(files) -> None:
    """Best-effort close of discord.File handles to avoid FD leaks."""
    if not files:
        return
    for f in files:
        try:
            if f:
                f.close()
        except Exception:
            pass

async def open_db():
    # Use the shared, WAL-configured connection from lib.db
    return await db.connect()
@bot.tree.command(name="restartbot", description="Owner only: restart the bot process.")
@owners_only()
async def restartbot(interaction: discord.Interaction):
    # Acknowledge before restarting so Discord gets the reply
    await interaction.response.send_message("üîÅ Restarting bot‚Ä¶", ephemeral=True)

    async def _reexec():
        await asyncio.sleep(1)
        try:
            os.execv(sys.executable, [sys.executable] + sys.argv)  # replace current process
        except Exception:
            os._exit(0)  # fallback: exit; your process manager/host restarts it

    asyncio.create_task(_reexec())
# Quick check (anyone): are you a DB admin?
@bot.tree.command(name="am_i_admin", description="Tell me if I can run DB-admin commands.")
async def am_i_admin(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    in_db = await _is_admin_user(interaction.user.id)
    await interaction.followup.send(
        "Admin: " + ("YES ‚úÖ" if in_db else "NO ‚ùå"),
        ephemeral=True
    )


@bot.tree.command(name="check_schema", description="List tables in the database (to verify migration ran).")
async def check_schema(interaction: discord.Interaction):
    """List tables in public schema so you can confirm init_schema / migration worked."""
    await interaction.response.defer(ephemeral=False)
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename"
            )
            rows = await cur.fetchall()
            await cur.close()
        names = [str(r[0]) for r in rows] if rows else []
        if names:
            text = "**Tables in public schema:**\n" + ", ".join(names)
        else:
            text = "No tables in public schema. Run the bot once (init_schema runs at startup) or apply `db/schema_pg.sql` manually (e.g. `psql $DATABASE_URL -f db/schema_pg.sql`)."
        await interaction.followup.send(text[:2000], ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"Could not list tables: {e}", ephemeral=True)


@bot.tree.command(name="post_beta_announcement", description="Owner only: post the beta tokens announcement to the announcement channel.")
@owners_only()
async def post_beta_announcement(interaction: discord.Interaction):
    """Post an announcement embed to the beta announcement channel. Owner only."""
    await interaction.response.defer(ephemeral=False)
    channel = bot.get_channel(BETA_ANNOUNCEMENT_CHANNEL_ID)
    if channel is None:
        try:
            channel = await bot.fetch_channel(BETA_ANNOUNCEMENT_CHANNEL_ID)
        except Exception:
            channel = None
    if not isinstance(channel, discord.TextChannel):
        return await interaction.followup.send("‚ùå Announcement channel not found.", ephemeral=True)
    embed = discord.Embed(
        title="ü™ô Beta Tokens ‚Äî Announcement",
        description=(
            "**Routing is almost operational.**\n\n"
            "For that, I'm introducing **Beta Tokens** ‚Äî a currency for beta testers.\n\n"
            "‚Ä¢ **Beta-exclusive:** These tokens are for beta testers only and will **disappear when Gen 1 fully releases**.\n"
            "‚Ä¢ **1 token per person** per command that awards them.\n"
            "‚Ä¢ **Use:** Beta tokens will unlock **exclusive rewards** once the bot stands on its feet.\n\n"
            "Thank you for testing. üéÆ"
        ),
        color=0x9B59B6,
    )
    embed.set_footer(text="Beta Tokens ‚Ä¢ 1 per person per eligible command ‚Ä¢ Disappear at Gen 1 full release")
    view = getattr(bot, "beta_claim_view", None) or BetaClaimView()
    await channel.send(embed=embed, view=view)
    await interaction.followup.send("‚úÖ Beta announcement posted.", ephemeral=True)


def _canon_item_id(pokeapi_name: str) -> str:
    # PokeAPI uses hyphens; your DB uses underscores (e.g., poke-ball -> poke_ball)
    return pokeapi_name.strip().lower().replace("-", "_")

async def _item_english_name(payload: dict) -> str:
    # Prefer English pretty name; fallback to base name
    for n in payload.get("names", []):
        if n.get("language", {}).get("name") == "en":
            return n.get("name") or payload.get("name", "")
    return payload.get("name", "")

def _item_english_desc(payload: dict) -> str | None:
    # Take last English flavor (they vary by version)
    en = [f for f in payload.get("flavor_text_entries", [])
          if f.get("language", {}).get("name") == "en"]
    if not en:
        return None
    # Clean newlines
    return en[-1].get("text", "").replace("\n", " ").replace("\f", " ").strip() or None

async def _upsert_item_row(conn, *, item_id: str, name: str | None, icon_url: str | None,
                           category: str | None, description: str | None,
                           price: int | None, sell_price: int | None):
    # Works with your schema:
    # items(id, name, emoji, icon_url, category, description, price, sell_price)
    await conn.execute("""
        INSERT INTO items (id, name, icon_url, category, description, price, sell_price)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(id) DO UPDATE SET
            name        = COALESCE(excluded.name, items.name),
            icon_url    = COALESCE(excluded.icon_url, items.icon_url),
            category    = COALESCE(excluded.category, items.category),
            description = COALESCE(excluded.description, items.description),
            price       = COALESCE(excluded.price, items.price),
            sell_price  = COALESCE(excluded.sell_price, items.sell_price)
    """, (item_id, name, icon_url, category, description, price, sell_price))

async def _fetch_json(session: aiohttp.ClientSession, url: str) -> dict:
    async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as resp:
        resp.raise_for_status()
        return await resp.json()

async def _import_all_items_from_pokeapi() -> tuple[int, int]:
    """
    Returns (inserted_or_updated_count, total_seen)
    """
    base = "https://pokeapi.co/api/v2/item?limit=100000&offset=0"
    async with aiohttp.ClientSession() as session:
        listing = await _fetch_json(session, base)
        results = listing.get("results", [])
        total = len(results)
        if total == 0:
            return 0, 0

        changed = 0
        async with db.session() as conn:
            # Gentle on the API: fetch details sequentially (still fast enough), or batch if you want
            for idx, entry in enumerate(results, start=1):
                try:
                    detail = await _fetch_json(session, entry["url"])
                except Exception as e:
                    print(f"[items] skip {entry.get('name')} (fetch error: {e})")
                    continue

                pid = _canon_item_id(detail["name"])
                pretty_name = await _item_english_name(detail)
                icon_url = (detail.get("sprites") or {}).get("default") or None
                category = (detail.get("category") or {}).get("name")
                if category:
                    category = category.replace("-", "_")
                desc = _item_english_desc(detail)
                price = detail.get("cost")
                sell_price = price // 2 if isinstance(price, int) else None  # simple default

                await _upsert_item_row(
                    conn,
                    item_id=pid,
                    name=pretty_name,
                    icon_url=icon_url,
                    category=category,
                    description=desc,
                    price=price if isinstance(price, int) else None,
                    sell_price=sell_price
                )
                changed += 1

                # optional: tiny sleep to be nice to PokeAPI
                await asyncio.sleep(0.01)

            await conn.commit()
            return changed, total

@bot.tree.command(name="import_items", description="(DB Admin) Cache all PokeAPI items into the database.")
@admin_only()
async def import_items_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True, thinking=True)
    try:
        changed, total = await _import_all_items_from_pokeapi()
    except Exception as e:
        return await interaction.followup.send(f"‚ùå Import failed: {e}", ephemeral=True)
    await interaction.followup.send(
        f"üì• Imported/updated **{changed}** items (saw {total}).\n"
        f"You can now set emojis with `/set_item_emoji` and view them in `/bag`.",
        ephemeral=True
    )

@bot.tree.command(name="seed_tm_fragments", description="(DB Admin) Ensure TM Fragment + all Gen1 TMs exist in items; give you 1 fragment per TM.")
@admin_only()
async def seed_tm_fragments_cmd(interaction: discord.Interaction):
    """Ensure item_master has tm-fragment and every GEN1 TM; give the invoker 1 TM Fragment per TM (for testing/exchange)."""
    await interaction.response.defer(ephemeral=True, thinking=True)
    uid = str(interaction.user.id)
    try:
        await db.upsert_item_master(TM_FRAGMENT_ITEM_ID, name="TM Fragment")
        for item_id, move_name in GEN1_TMS:
            num = item_id.replace("tm-", "").zfill(2)
            await db.upsert_item_master(item_id, name=f"TM{num} {move_name}")
        n_tms = len(GEN1_TMS)
        await db.give_item(uid, TM_FRAGMENT_ITEM_ID, n_tms)
    except Exception as e:
        return await interaction.followup.send(f"‚ùå Seed failed: {e}", ephemeral=True)
    await interaction.followup.send(
        f"‚úÖ Seeded **TM Fragment** and all **{n_tms}** Gen 1 TMs in the item catalog.\n"
        f"You received **{n_tms}** TM Fragment(s).",
        ephemeral=True
    )

@bot.tree.command(name="mygen", description="Show your current game generation.")
async def mygen(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    try:
        g = await _user_selected_gen(uid)
    except Exception:
        g = 1
    await interaction.followup.send(f"Your current generation is **Gen {g}**.", ephemeral=True)

@bot.tree.command(name="setgen", description="Admin: set a user's generation (1‚Äì9).")
@app_commands.describe(user="Target user", gen="Generation number (1‚Äì9)")
@owners_only()
async def setgen(
    interaction: discord.Interaction,
    user: discord.User,
    gen: app_commands.Range[int, 1, 9],
    also_unlock: bool = True
):
    """
    Set a user's current generation and optionally unlock up to that gen.
    
    Args:
        user: The user to modify
        gen: Generation to set (1-9)
        also_unlock: If True, also sets max_unlocked_gen to this value (default: True)
    """
    await interaction.response.defer(ephemeral=False)
    uid = str(user.id)
    
    await db.set_user_gen(uid, gen)
    _set_cached_user_gen(uid, int(gen))
    
    if also_unlock:
        conn = await db.connect()
        try:
            await conn.execute(
                "INSERT OR IGNORE INTO user_rulesets (user_id, generation, max_unlocked_gen) VALUES (?, 1, 1)",
                (uid,)
            )
            await conn.execute(
                "UPDATE user_rulesets SET max_unlocked_gen = ?, updated_at_utc = CURRENT_TIMESTAMP WHERE user_id = ?",
                (gen, uid)
            )
            await conn.commit()
            await interaction.followup.send(
                f"‚úÖ Set {user.mention}'s generation to **Gen {gen}** and unlocked up to **Gen {gen}**.", ephemeral=True
            )
        finally:
            try:
                await conn.close()
            except Exception:
                pass
    else:
        await interaction.followup.send(
            f"‚úÖ Set {user.mention}'s generation to **Gen {gen}**.", ephemeral=True
        )

# --- Call this helper BEFORE you allow a held item / battle gimmick ---
async def enforce_item_gimmick_gate(
    interaction: discord.Interaction,
    owner_id: str,
    item_id: str | None
) -> bool:
    """
    Returns True if the item is allowed for the owner's current gen, else
    sends an ephemeral error and returns False.

    Use this anywhere you equip, give, or activate an item that could be
    a gimmick enabler (Mega stones, Z-crystals, Dynamax, Tera Orb).
    """
    if not item_id:
        return True  # nothing to check
    try:
        user_gen = await _user_selected_gen(owner_id)
    except Exception:
        user_gen = 1

    if not _rules.gimmick_allowed_in_gen(user_gen, item_id):
        await interaction.followup.send(
            f"‚ùå `{item_id}` isn‚Äôt allowed in **Gen {user_gen}**.", ephemeral=True
        )
        return False
    return True
##sprites:
# === Local Pok√©mon sprites (project_root/sprites/<species>/...) ===
SPRITES_DIR = Path(__file__).resolve().parent / "sprites"   # e.g. sprites/bulbasaur/...

def _species_folder_name(species: str) -> str:
    """
    Your folder layout is 'sprites/{species name}/...'.
    We'll normalize to lowercase and turn spaces/underscores into dashes
    to match your actual folders (e.g., 'Mr Mime' -> 'mr-mime').
    """
    s = str(species or "").strip().lower()
    # Normalize well-known alias folders
    if s in ("greninja-ash", "ash-greninja"):
        s = "greninja-battle-bond"
    # Also convert any '...-ash' variant for greninja to battle-bond
    if s.startswith("greninja-") and s.endswith("-ash"):
        s = s.replace("-ash", "-battle-bond")
    return s.replace(" ", "-").replace("_", "-")

def pokemon_sprite_attachment(
    species: str,
    *,
    shiny: bool = False,
    gender: str | None = None,
) -> tuple[str | None, discord.File | None]:
    """
    Returns (attachment_url, discord.File) for the *best* local sprite you have.

    Priority (always animated over static, as requested):
      1) female animated shiny front  -> female animated front
      2) female shiny front           -> female front
      3) animated shiny front         -> animated front
      4) shiny front                  -> front
      5) icon                         (only if no animated/static fronts exist)

    Filenames assumed from your screenshot:
      animated-front.gif
      animated-back.gif
      animated-shiny-front.gif
      animated-shiny-back.gif
      front.png
      back.png
      shiny-front.png
      shiny-back.png
      icon.png
      and the female-prefixed versions:
      female-animated-front.gif, female-animated-shiny-front.gif,
      female-front.png, female-shiny-front.png, etc.

    If nothing local exists, returns (None, None).
    """
    folder = SPRITES_DIR / _species_folder_name(species)

    def _exists(name: str) -> Path | None:
        p = folder / name
        try:
            return p if p.exists() and p.stat().st_size > 0 else None
        except Exception:
            return None

    is_female = (str(gender or "").strip().lower() == "female")

    # Build candidate list in strict priority (animated > static; shiny > normal; female first)
    candidates: list[str] = []
    if is_female:
        if shiny:
            candidates += ["female-animated-shiny-front.gif", "female-shiny-front.png"]
        candidates += ["female-animated-front.gif", "female-front.png"]

    if shiny:
        candidates += ["animated-shiny-front.gif", "shiny-front.png"]
    candidates += ["animated-front.gif", "front.png"]

    # If absolutely nothing, try icon last
    candidates += ["icon.png"]

    for fname in candidates:
        p = _exists(fname)
        if p:
            return f"attachment://{p.name}", discord.File(p, filename=p.name)

    return None, None
##shiny odds
TRIGGER_NAME = "pokemons_shiny_auto"

class OwnerShinyOddsCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        # Pull the same OWNER_IDS set you already use
        ids = None
        try:
            # If this cog is in a separate file and your main file is named pokebot.py:
            from pokebot import OWNER_IDS as _IDS  # noqa: F401
            ids = set(_IDS)
        except Exception:
            # If it's the same file, OWNER_IDS will already be in globals()
            ids = set(globals().get("OWNER_IDS", set()))
        self.owner_ids: set[int] = set(int(x) for x in (ids or set()))

    async def _is_owner(self, interaction: discord.Interaction) -> bool:
        # Primary: your OWNER_IDS set
        if self.owner_ids and interaction.user.id in self.owner_ids:
            return True
        # Fallback only if OWNER_IDS is empty
        try:
            app = await interaction.client.application_info()
            if app.owner:
                return interaction.user.id == app.owner.id
        except Exception:
            pass
        return False

    async def _current_denominator(self) -> int | None:
        return None

    async def _create_trigger(self, n: int) -> None:
        if getattr(db, "DB_IS_POSTGRES", False):
            return
        conn = await db.connect()
        try:
            await conn.execute(f"DROP TRIGGER IF EXISTS {TRIGGER_NAME}")
            await conn.execute(f"""
            CREATE TRIGGER {TRIGGER_NAME}
            AFTER INSERT ON pokemons
            BEGIN
              UPDATE pokemons
              SET shiny = CASE WHEN (abs(random()) % {n}) = 0 THEN 1 ELSE shiny END
              WHERE id = NEW.id;
            END;
            """)
            await conn.commit()
        finally:
            try:
                await conn.close()
            except Exception:
                pass

    @app_commands.command(name="shiny_odds", description="Show the current global shiny odds (owner only).")
    async def shiny_odds(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=False)
        if not await self._is_owner(interaction):
            return await interaction.followup.send("‚ùå Owner only.", ephemeral=True)
        if getattr(db, "DB_IS_POSTGRES", False):
            return await interaction.followup.send("‚ùå Shiny trigger is not supported on Postgres.", ephemeral=True)
        n = await self._current_denominator()
        if not n:
            return await interaction.followup.send("No shiny trigger found. Run `/set_shiny_odds` first.", ephemeral=True)
        await interaction.followup.send(f"‚≠ê Current shiny odds: **1 / {n}**", ephemeral=True)

    @app_commands.command(name="set_shiny_odds", description="Set global shiny odds to 1/N for all new Pok√©mon inserts (owner only).")
    @app_commands.describe(n="Denominator N (e.g., 4096). Use 1 for always-shiny during testing.")
    async def set_shiny_odds(self, interaction: discord.Interaction, n: app_commands.Range[int, 1, 1000000]):
        await interaction.response.defer(ephemeral=False)
        if not await self._is_owner(interaction):
            return await interaction.followup.send("‚ùå Owner only.", ephemeral=True)
        if getattr(db, "DB_IS_POSTGRES", False):
            return await interaction.followup.send("‚ùå Shiny trigger is not supported on Postgres.", ephemeral=True)
        await self._create_trigger(n)
        await interaction.followup.send(f"‚úÖ Shiny odds set to **1 / {n}** for all NEW Pok√©mon inserts.", ephemeral=True)
# =========================
#  Owner admin management
# =========================
async def _count(conn, table: str, where_sql: str = "", args: tuple = ()):
    cur = await conn.execute(f"SELECT COUNT(*) AS c FROM {table} {where_sql}", args)
    row = await cur.fetchone()
    await cur.close()
    return int(row["c"] if row else 0)

_PG_POKEMONS_COLS_OK = False

async def _ensure_pg_pokemons_columns(conn) -> None:
    global _PG_POKEMONS_COLS_OK
    if _PG_POKEMONS_COLS_OK or not getattr(db, "DB_IS_POSTGRES", False):
        return
    try:
        await conn.execute("ALTER TABLE pokemons ADD COLUMN IF NOT EXISTS hp_now INTEGER")
        await conn.execute("ALTER TABLE pokemons ADD COLUMN IF NOT EXISTS moves_pp JSONB")
        await conn.execute("ALTER TABLE pokemons ADD COLUMN IF NOT EXISTS moves_pp_min JSONB")
        await conn.execute("ALTER TABLE pokemons ADD COLUMN IF NOT EXISTS moves_pp_max JSONB")
        await conn.execute("ALTER TABLE pokemons ADD COLUMN IF NOT EXISTS shiny INTEGER NOT NULL DEFAULT 0")
        await conn.execute("ALTER TABLE pokemons ADD COLUMN IF NOT EXISTS is_hidden_ability INTEGER NOT NULL DEFAULT 0")
        _PG_POKEMONS_COLS_OK = True
    except Exception:
        # leave flag false so we can try again later
        pass

async def _pg_pokemons_column_flags(conn) -> dict:
    """Return existence flags for optional PG columns on pokemons."""
    flags = {
        "hp_now": True,
        "moves_pp": True,
        "moves_pp_min": False,
        "moves_pp_max": False,
        "shiny": True,
        "is_hidden_ability": True,
    }
    if not getattr(db, "DB_IS_POSTGRES", False):
        return flags
    try:
        flags["hp_now"] = await db._column_exists(conn, "pokemons", "hp_now")
    except Exception:
        flags["hp_now"] = False
    try:
        flags["moves_pp"] = await db._column_exists(conn, "pokemons", "moves_pp")
    except Exception:
        flags["moves_pp"] = False
    try:
        flags["moves_pp_min"] = await db._column_exists(conn, "pokemons", "moves_pp_min")
    except Exception:
        flags["moves_pp_min"] = False
    try:
        flags["moves_pp_max"] = await db._column_exists(conn, "pokemons", "moves_pp_max")
    except Exception:
        flags["moves_pp_max"] = False
    try:
        flags["shiny"] = await db._column_exists(conn, "pokemons", "shiny")
    except Exception:
        flags["shiny"] = False
    try:
        flags["is_hidden_ability"] = await db._column_exists(conn, "pokemons", "is_hidden_ability")
    except Exception:
        flags["is_hidden_ability"] = False
    return flags

async def _tx_begin(conn) -> None:
    await conn.execute("BEGIN")

async def _tx_commit(conn) -> None:
    if getattr(db, "DB_IS_POSTGRES", False):
        await conn.execute("COMMIT")
    else:
        await conn.commit()

async def _tx_rollback(conn) -> None:
    if getattr(db, "DB_IS_POSTGRES", False):
        await conn.execute("ROLLBACK")
    else:
        await conn.rollback()

async def _wipe_user(conn, uid: str) -> dict:
    """
    Remove EVERYTHING for one user.
    Note: owner_id tables -> uid in owner_id; users/user_rulesets -> uid in user_id.
    """
    stats = {
        "pokemons":       await _count(conn, "pokemons",       "WHERE owner_id=?", (uid,)),
        "user_items":     await _count(conn, "user_items",     "WHERE owner_id=?", (uid,)),
        "user_equipment": await _count(conn, "user_equipment", "WHERE owner_id=?", (uid,)),
        "user_boxes":     await _count(conn, "user_boxes",     "WHERE owner_id=?", (uid,)),
        "user_meta":      await _count(conn, "user_meta",      "WHERE owner_id=?", (uid,)),
        "user_rulesets":  await _count(conn, "user_rulesets",  "WHERE user_id=?",  (uid,)),
        "event_log":      await _count(conn, "event_log",      "WHERE user_id=?",  (uid,)),
        "users":          await _count(conn, "users",          "WHERE user_id=?",  (uid,)),
    }

    await _tx_begin(conn)
    try:
        # Enable foreign keys to ensure CASCADE works
        if not getattr(db, "DB_IS_POSTGRES", False):
            await conn.execute("PRAGMA foreign_keys = ON")
        # children first (in order of dependencies)
        await conn.execute("DELETE FROM pokemons       WHERE owner_id=?", (uid,))
        await conn.execute("DELETE FROM user_items     WHERE owner_id=?", (uid,))
        await conn.execute("DELETE FROM user_equipment WHERE owner_id=?", (uid,))
        await conn.execute("DELETE FROM user_boxes     WHERE owner_id=?", (uid,))
        await conn.execute("DELETE FROM user_meta      WHERE owner_id=?",  (uid,))
        await conn.execute("DELETE FROM user_rulesets  WHERE user_id=?",  (uid,))
        await conn.execute("DELETE FROM event_log      WHERE user_id=?",  (uid,))
        # finally the user row
        await conn.execute("DELETE FROM users          WHERE user_id=?",  (uid,))
        await _tx_commit(conn)
        db.invalidate_pokemons_cache(uid)
        db.invalidate_bag_cache(uid)
    except Exception:
        await _tx_rollback(conn)
        raise
    return stats

async def _recache_after_wipe() -> None:
    try:
        if db_cache is not None:
            db_cache.clear_cache()
        if warm_cache is not None:
            await warm_cache()
    except Exception:
        pass

async def _wipe_all(conn) -> dict:
    """Delete ALL players & data. Order matters (children -> parent)."""
    stats = {
        "pokemons":       await _count(conn, "pokemons"),
        "user_items":     await _count(conn, "user_items"),
        "user_equipment": await _count(conn, "user_equipment"),
        "user_boxes":     await _count(conn, "user_boxes"),
        "user_meta":      await _count(conn, "user_meta"),
        "user_rulesets":  await _count(conn, "user_rulesets"),
        "users":          await _count(conn, "users"),
    }

    await _tx_begin(conn)
    try:
        await conn.execute("DELETE FROM pokemons")
        await conn.execute("DELETE FROM user_items")
        await conn.execute("DELETE FROM user_equipment")
        await conn.execute("DELETE FROM user_boxes")
        await conn.execute("DELETE FROM user_meta")
        await conn.execute("DELETE FROM user_rulesets")
        await conn.execute("DELETE FROM users")
        await _tx_commit(conn)
        db.clear_all_pokemons_cache()
        db.clear_all_bag_cache()
    except Exception:
        await _tx_rollback(conn)
        raise
    return stats


@bot.tree.command(name="wipe", description="OWNER: wipe one user OR wipe ALL player data.")
@owners_only()
@app_commands.describe(
    scope="Choose single user or ALL players.",
    user="Target user (mention or ID) if scope=user.",
    confirm="Type CONFIRM to proceed."
)
@app_commands.choices(
    scope=[
        app_commands.Choice(name="single user", value="user"),
        app_commands.Choice(name="ALL players", value="all"),
    ]
)
async def wipe_cmd(
    interaction: discord.Interaction,
    scope: app_commands.Choice[str],
    user: str | None = None,
    confirm: str | None = None,
):
    await interaction.response.defer(ephemeral=True, thinking=True)

    if (confirm or "").strip().upper() != "CONFIRM":
        return await interaction.followup.send(
            "‚ùó Destructive action. Re-run with `confirm: CONFIRM`.",
            ephemeral=True,
        )

    # Get data first, then release connection before sending messages
    conn = await db.connect()
    # Ensure foreign keys are enabled (SQLite only)
    if not getattr(db, "DB_IS_POSTGRES", False):
        await conn.execute("PRAGMA foreign_keys = ON")

    try:
        if scope.value == "user":
            if not user:
                await conn.close()  # Release before network call
                return await interaction.followup.send("Provide `user:` (ID or mention).", ephemeral=True)

            # accept <@123>, <@!123>, or raw 123
            uid = user.strip()
            if uid.startswith("<@") and uid.endswith(">"):
                uid = uid.strip("<@!>")

            # sanity check
            cur = await conn.execute("SELECT 1 FROM users WHERE user_id=?", (uid,))
            exists = bool(await cur.fetchone())
            await cur.close()
            
            if not exists:
                await conn.close()  # Release before network call
                return await interaction.followup.send(f"No save found for user `{uid}`.", ephemeral=True)

            stats = await _wipe_user(conn, uid)
            await conn.close()  # Release connection before network call
            await _recache_after_wipe()
            lines = "\n".join(f"- {k}: {v}" for k, v in stats.items())
            return await interaction.followup.send(f"üßπ Wiped user `{uid}`:\n{lines}", ephemeral=True)

        # wipe all
        stats = await _wipe_all(conn)
        await conn.close()  # Release connection before network call
        await _recache_after_wipe()
        lines = "\n".join(f"- {k}: {v}" for k, v in stats.items())
        return await interaction.followup.send(f"üí£ **ALL PLAYERS ERASED**\n{lines}", ephemeral=True)

    except Exception as e:
        try:
            await conn.close()
        except:
            pass
        return await interaction.followup.send(f"‚ùå Error: {e}", ephemeral=True)
    finally:
        try:
            await conn.close()
        except Exception:
            pass
@bot.tree.command(name="db_pool_stats", description="(Owner) Show current database pool statistics.")
@owners_only()
async def db_pool_stats(interaction: discord.Interaction):
    """Show database pool statistics for monitoring connection usage."""
    await interaction.response.defer(ephemeral=False)
    
    try:
        from pvp.db_pool import get_pool_stats
        stats = get_pool_stats()
        
        embed = discord.Embed(
            title="üìä Database Pool Statistics",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="Pool Configuration",
            value=f"Pool Size: {stats['pool_size']}\nTimeout: 60s",
            inline=False
        )
        
        embed.add_field(
            name="Current Usage",
            value=f"Available: {stats['available_connections']}\nIn Use: {stats['in_use_connections']}\nTotal: {stats['total_connections']}",
            inline=True
        )
        
        utilization = stats.get('pool_utilization_pct', 0)
        color_status = "üü¢ Good" if utilization < 50 else "üü° Moderate" if utilization < 80 else "üî¥ High"
        
        embed.add_field(
            name="Utilization",
            value=f"{utilization}%\n{color_status}",
            inline=True
        )
        
        if stats.get('total_connections', 0) > stats.get('pool_size', 0):
            embed.add_field(
                name="‚ö†Ô∏è Warning",
                value="Potential connection leak detected! Total connections exceed pool size.",
                inline=False
            )
        
        await interaction.followup.send(embed=embed, ephemeral=True)
    except ImportError:
        await interaction.followup.send("‚ùå Pool stats not available (pvp.db_pool not found)", ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="admin_list", description="(Owner) Show current DB admins.")
@owners_only()
async def admin_list(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    admins = await db.list_admins(limit=200)
    if not admins:
        return await interaction.followup.send("No admins in DB.", ephemeral=True)
    lines = [f"- <@{a['user_id']}> (`{a['user_id']}`) added_at: {a['added_at']}" for a in admins]
    await interaction.followup.send("**Admins in DB:**\n" + "\n".join(lines), ephemeral=True)

@bot.tree.command(name="admin_add", description="(Owner) Add a user to the admin whitelist.")
@owners_only()
@app_commands.describe(member="User to grant admin access")
async def admin_add(interaction: discord.Interaction, member: discord.Member):
    uid = str(member.id)
    await db.add_admin(uid)
    await interaction.response.send_message(
        f"‚úÖ Added {member.mention} (`{uid}`) to admin whitelist.", ephemeral=True
    )

@bot.tree.command(name="admin_remove", description="(Owner) Remove a user from the admin whitelist.")
@owners_only()
@app_commands.describe(member="User to remove from admin access")
async def admin_remove(interaction: discord.Interaction, member: discord.Member):
    uid = str(member.id)
    if member.id in OWNER_IDS:
        return await interaction.response.send_message("‚ùå You can‚Äôt remove an owner.", ephemeral=True)
    await db.remove_admin(uid)
    await interaction.response.send_message(
        f"‚úÖ Removed {member.mention} (`{uid}`) from admin whitelist.", ephemeral=True
    )


@bot.tree.command(name="verified_add", description="(Owner) Exempt a player from the OS role requirement.")
@owners_only()
@app_commands.describe(user="User mention or user ID", note="Optional note for why this user is exempt")
async def verified_add(interaction: discord.Interaction, user: str, note: str | None = None):
    uid = _parse_user_id_input(user)
    if uid is None:
        return await interaction.response.send_message("‚ùå Invalid user. Provide a mention like `<@123>` or a numeric ID.", ephemeral=True)
    if uid in OWNER_IDS:
        return await interaction.response.send_message("‚ÑπÔ∏è Owners are already exempt from the role rule.", ephemeral=True)
    ok = await _grant_role_gate_exempt(uid, added_by=interaction.user.id, note=note)
    if not ok:
        return await interaction.response.send_message("‚ùå Failed to add exemption. Try again.", ephemeral=True)
    await interaction.response.send_message(
        f"‚úÖ Added <@{uid}> (`{uid}`) to the verified exemption list (role rule bypass).",
        ephemeral=True,
    )


@bot.tree.command(name="verified_remove", description="(Owner) Remove a player from role-rule exemptions.")
@owners_only()
@app_commands.describe(user="User mention or user ID")
async def verified_remove(interaction: discord.Interaction, user: str):
    uid = _parse_user_id_input(user)
    if uid is None:
        return await interaction.response.send_message("‚ùå Invalid user. Provide a mention like `<@123>` or a numeric ID.", ephemeral=True)
    if uid in OWNER_IDS:
        return await interaction.response.send_message("‚ùå Owners cannot be removed from exemption.", ephemeral=True)
    ok = await _revoke_role_gate_exempt(uid)
    if not ok:
        return await interaction.response.send_message("‚ùå Failed to remove exemption. Try again.", ephemeral=True)
    await interaction.response.send_message(
        f"‚úÖ Removed <@{uid}> (`{uid}`) from the verified exemption list.",
        ephemeral=True,
    )


@bot.tree.command(name="verified_list", description="(Owner) List players exempt from the OS role rule.")
@owners_only()
async def verified_list(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True, thinking=False)
    rows = await _list_role_gate_exempt(limit=100)
    if not rows:
        return await interaction.followup.send("No verified role-rule exemptions are currently set.", ephemeral=True)
    lines: list[str] = []
    for row in rows[:50]:
        uid = str(row.get("user_id") or "").strip()
        if not uid:
            continue
        added_by = str(row.get("added_by") or "").strip()
        note = str(row.get("note") or "").strip()
        if len(note) > 60:
            note = note[:57] + "..."
        by_txt = f" by <@{added_by}>" if added_by.isdigit() else ""
        note_txt = f" ‚Äî {note}" if note else ""
        lines.append(f"‚Ä¢ <@{uid}> (`{uid}`){by_txt}{note_txt}")
    if not lines:
        return await interaction.followup.send("No verified role-rule exemptions are currently set.", ephemeral=True)
    msg = "**Verified role-rule exemptions:**\n" + "\n".join(lines)
    if len(msg) > 1900:
        msg = msg[:1897] + "..."
    await interaction.followup.send(msg, ephemeral=True)


@bot.tree.command(name="hatchnow", description="(Owner) Instantly hatch one daycare egg for testing.")
@owners_only()
@app_commands.describe(
    target="Target trainer (defaults to yourself).",
    source="Where to hatch from.",
    index="Egg position in that source (1-based).",
)
@app_commands.choices(
    source=[
        app_commands.Choice(name="Auto (incubator first)", value="auto"),
        app_commands.Choice(name="Incubator", value="incubating"),
        app_commands.Choice(name="Daycare waiting eggs", value="daycare"),
    ]
)
async def hatchnow(
    interaction: discord.Interaction,
    target: discord.User | None = None,
    source: app_commands.Choice[str] | None = None,
    index: app_commands.Range[int, 1, 30] = 1,
):
    await interaction.response.defer(ephemeral=True, thinking=False)
    target_user = target or interaction.user
    uid = str(target_user.id)
    mode = str(source.value if source else "auto").strip().lower()
    idx = max(0, int(index) - 1)

    state = await _get_adventure_state(uid)
    rec = _daycare_get_record(state, DAYCARE_CITY_ID)
    incubating = rec.get("incubating") if isinstance(rec.get("incubating"), list) else []
    waiting = rec.get("eggs") if isinstance(rec.get("eggs"), list) else []

    egg_list: list[Any]
    source_label: str
    source_key: str
    if mode == "incubating":
        egg_list = incubating
        source_label = "incubator"
        source_key = "incubating"
    elif mode == "daycare":
        egg_list = waiting
        source_label = "daycare waiting eggs"
        source_key = "eggs"
    else:
        if incubating:
            egg_list = incubating
            source_label = "incubator"
            source_key = "incubating"
        else:
            egg_list = waiting
            source_label = "daycare waiting eggs"
            source_key = "eggs"

    if not egg_list:
        return await interaction.followup.send(
            f"‚ùå No eggs available in **{source_label}** for <@{target_user.id}>.",
            ephemeral=True,
        )
    if idx >= len(egg_list):
        return await interaction.followup.send(
            f"‚ùå Invalid egg index. {source_label.title()} currently has **{len(egg_list)}** egg(s).",
            ephemeral=True,
        )

    egg = egg_list[idx]
    if not isinstance(egg, dict):
        return await interaction.followup.send(
            f"‚ùå Egg data at index **{idx + 1}** is invalid.",
            ephemeral=True,
        )

    hatched = await _daycare_hatch_to_team(uid, egg)
    if not hatched:
        return await interaction.followup.send(
            "‚ùå Instant hatch failed. Check breeding metadata for this egg.",
            ephemeral=True,
        )

    try:
        rec[source_key].pop(idx)
    except Exception:
        rec[source_key] = [e for i, e in enumerate(list(rec.get(source_key) or [])) if i != idx]
    await _save_adventure_state(uid, state)

    species_txt = str(hatched.get("species") or "Pok√©mon").replace("-", " ").title()
    dest = str(hatched.get("destination") or "box")
    if dest == "team":
        slot = int(hatched.get("team_slot") or 0)
        dest_txt = f"team slot **{slot}**" if slot > 0 else "the team"
    else:
        bno = int(hatched.get("box_no") or 0)
        bpos = int(hatched.get("box_pos") or 0)
        if bno > 0 and bpos > 0:
            dest_txt = f"**Box {bno}, Slot {bpos}**"
        else:
            dest_txt = "the PC Box"

    await interaction.followup.send(
        (
            f"‚úÖ Instantly hatched **{species_txt}** for <@{target_user.id}> "
            f"from **{source_label}** (egg #{idx + 1}).\n"
            f"Destination: {dest_txt}."
        ),
        ephemeral=True,
    )

# =========================
#  Utility / admin-only slash
# =========================
# --- fuzzy matching helpers ---
def _canon(s: str) -> str:
    """lowercase and strip non-alphanumerics for fuzzy compare"""
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

# ============================================================================
# ENHANCED FUZZY MATCHING SYSTEM
# ============================================================================

class FuzzyMatcher:
    """
    Comprehensive fuzzy matching for Pokemon data with abbreviations,
    typo tolerance, and smart suggestions.
    """
    
    # Common abbreviations for moves
    MOVE_ABBREVIATIONS = {
        "eq": "earthquake",
        "dclaw": "dragon-claw",
        "stone": "stone-edge",
        "sword": "swords-dance",
        "rocks": "stealth-rock",
        "twave": "thunder-wave",
        "willowisp": "will-o-wisp",
        "wow": "will-o-wisp",
        "sr": "stealth-rock",
        "hp": "hidden-power",
        "sub": "substitute",
        "protect": "protect",
        "toxic": "toxic",
        "roost": "roost",
        "uturn": "u-turn",
        "volt": "volt-switch",
        "scald": "scald",
        "knock": "knock-off",
        "defog": "defog",
        "rapid": "rapid-spin",
        "spin": "rapid-spin",
        "flamethrower": "flamethrower",
        "fireblast": "fire-blast",
        "icebeam": "ice-beam",
        "thunderbolt": "thunderbolt",
        "thunder": "thunder",
        "psychic": "psychic",
        "shadowball": "shadow-ball",
        "energyball": "energy-ball",
        "focusblast": "focus-blast",
        "aurasphere": "aura-sphere",
        "darkpulse": "dark-pulse",
        "dragonpulse": "dragon-pulse",
        "dracometeor": "draco-meteor",
        "overheat": "overheat",
        "closecombat": "close-combat",
        "superpower": "superpower",
        "ironhead": "iron-head",
        "playrough": "play-rough",
        "moonblast": "moonblast",
        "gigadrain": "giga-drain",
    }
    
    # Common nature abbreviations
    NATURE_ABBREVIATIONS = {
        "ada": "adamant",
        "bold": "bold",
        "brave": "brave",
        "calm": "calm",
        "care": "careful",
        "hast": "hasty",
        "imp": "impish",
        "jol": "jolly",
        "lax": "lax",
        "lone": "lonely",
        "mild": "mild",
        "mod": "modest",
        "naive": "naive",
        "naugh": "naughty",
        "quie": "quiet",
        "rash": "rash",
        "relax": "relaxed",
        "sass": "sassy",
        "seri": "serious",
        "timi": "timid",
    }
    
    @staticmethod
    def normalize(text: str) -> str:
        """Normalize text for matching"""
        if not text:
            return ""
        # Convert to string if it's not already (handles move IDs)
        text = str(text)
        return text.strip().lower().replace(" ", "-").replace("_", "-")
    
    @staticmethod
    def fuzzy_match(query: str, choices: list[str], threshold: float = 0.72) -> tuple[Optional[str], float, list[str]]:
        """
        Enhanced fuzzy matching with better scoring.
        Returns: (best_match, score, suggestions[:5])
        """
        if not choices:
            return None, 0.0, []
        
        query_norm = FuzzyMatcher.normalize(query)
        
        # Check exact match first
        for choice in choices:
            if FuzzyMatcher.normalize(choice) == query_norm:
                return choice, 1.0, [choice]
        
        # Score all choices
        scored = []
        for choice in choices:
            choice_norm = FuzzyMatcher.normalize(choice)
            
            # Calculate similarity ratio
            ratio = difflib.SequenceMatcher(a=query_norm, b=choice_norm).ratio()
            
            # Bonus for prefix match
            if choice_norm.startswith(query_norm):
                ratio = max(ratio, 0.85)
            
            # Bonus for containing the query
            if query_norm in choice_norm:
                ratio = max(ratio, 0.80)
            
            scored.append((ratio, choice))
        
        scored.sort(reverse=True, key=lambda x: x[0])
        
        best_score, best_choice = scored[0]
        suggestions = [c for s, c in scored if s >= threshold][:5]
        
        return best_choice, best_score, suggestions
    
    @staticmethod
    async def fuzzy_move(conn, query: str, species_id: Optional[int] = None, 
                         gen: Optional[int] = None) -> tuple[Optional[str], float, list[str]]:
        """
        Fuzzy match move name with abbreviation support and legality checking.
        Returns: (move_name, confidence, suggestions)
        """
        query_norm = FuzzyMatcher.normalize(query)
        
        # Check abbreviations first
        if query_norm in FuzzyMatcher.MOVE_ABBREVIATIONS:
            exact_move = FuzzyMatcher.MOVE_ABBREVIATIONS[query_norm]
            return exact_move, 1.0, [exact_move]
        
        # Get all moves (or legal moves if species_id provided)
        if species_id and gen:
            cur = await conn.execute("""
                SELECT DISTINCT m.name
                FROM moves m
                JOIN learnsets l ON m.id = l.move_id
                WHERE l.species_id = ? AND l.generation <= ?
            """, (species_id, gen))
        else:
            cur = await conn.execute("SELECT name FROM moves")
        
        move_rows = await cur.fetchall()
        await cur.close()
        
        all_moves = [row['name'] for row in move_rows]
        
        return FuzzyMatcher.fuzzy_match(query, all_moves, threshold=0.70)
    
    @staticmethod
    async def fuzzy_species(conn, query: str) -> tuple[Optional[dict], float, list[str]]:
        """
        Fuzzy match species name.
        Returns: (species_row, confidence, suggestions)
        """
        cur = await conn.execute("SELECT id, name FROM pokedex")
        species_rows = await cur.fetchall()
        await cur.close()
        
        species_names = [row['name'] for row in species_rows]
        best_name, score, suggestions = FuzzyMatcher.fuzzy_match(query, species_names, threshold=0.70)
        
        if best_name:
            cur = await conn.execute("SELECT * FROM pokedex WHERE LOWER(name) = LOWER(?)", (best_name,))
            species_row = await cur.fetchone()
            await cur.close()
            return dict(species_row) if species_row else None, score, suggestions
        
        return None, 0.0, suggestions
    
    @staticmethod
    async def fuzzy_ability(conn, query: str, valid_abilities: Optional[list[str]] = None) -> tuple[Optional[str], float, list[str]]:
        """
        Fuzzy match ability name.
        Returns: (ability_name, confidence, suggestions)
        """
        if valid_abilities:
            choices = valid_abilities
        else:
            # Get all abilities from database (you may need to adjust this query)
            cur = await conn.execute("SELECT DISTINCT ability FROM pokemons WHERE ability IS NOT NULL")
            rows = await cur.fetchall()
            await cur.close()
            choices = list(set(row['ability'] for row in rows if row['ability']))
        
        return FuzzyMatcher.fuzzy_match(query, choices, threshold=0.75)
    
    @staticmethod
    async def fuzzy_item(conn, query: str) -> tuple[Optional[str], float, list[str]]:
        """
        Fuzzy match item name. Uses item cache when available to avoid DB round-trip.
        Returns: (item_id, confidence, suggestions)
        """
        item_rows = []
        if db_cache is not None:
            item_rows = db_cache.get_all_cached_items()
        if not item_rows:
            cur = await conn.execute("SELECT id, name FROM items")
            item_rows = [dict(r) for r in await cur.fetchall()]
            await cur.close()
        
        item_ids = [r.get("id") or "" for r in item_rows]
        item_names = [r.get("name") or r.get("id") or "" for r in item_rows]
        
        best_id, score_id, sugg_id = FuzzyMatcher.fuzzy_match(query, item_ids, threshold=0.70)
        best_name, score_name, sugg_name = FuzzyMatcher.fuzzy_match(query, item_names, threshold=0.70)
        
        if score_id > score_name:
            return best_id, score_id, sugg_id
        if best_name:
            for row in item_rows:
                if (row.get("name") or "").lower() == best_name.lower():
                    sugg = [r.get("id") or "" for r in item_rows if (r.get("name") or "") in sugg_name]
                    return row.get("id"), score_name, sugg
        return None, 0.0, []
    
    @staticmethod
    async def fuzzy_move(conn, query: str) -> tuple[Optional[str], float, list[str]]:
        """
        Fuzzy match move name.
        Returns: (move_name, confidence, suggestions)
        The move_name is normalized (lowercase, hyphens).
        """
        cur = await conn.execute("SELECT name FROM moves")
        move_rows = await cur.fetchall()
        await cur.close()
        
        # Get all move names
        move_names = [row['name'] for row in move_rows]
        
        # Check abbreviations first
        query_norm = FuzzyMatcher.normalize(query)
        if query_norm in FuzzyMatcher.MOVE_ABBREVIATIONS:
            abbrev_full = FuzzyMatcher.MOVE_ABBREVIATIONS[query_norm]
            # Check if abbreviated move exists
            if abbrev_full in move_names:
                return abbrev_full, 1.0, [abbrev_full]
        
        # Try fuzzy match
        best_match, score, suggestions = FuzzyMatcher.fuzzy_match(query, move_names, threshold=0.70)
        
        return best_match, score, suggestions[:5]  # Return top 5 suggestions
    
    @staticmethod
    def fuzzy_nature(query: str) -> tuple[Optional[str], float, list[str]]:
        """
        Fuzzy match nature name with abbreviation support.
        Returns: (nature_name, confidence, suggestions)
        """
        import lib.stats as stats
        
        query_norm = FuzzyMatcher.normalize(query)
        
        # Check abbreviations first
        if query_norm in FuzzyMatcher.NATURE_ABBREVIATIONS:
            return FuzzyMatcher.NATURE_ABBREVIATIONS[query_norm], 1.0, [FuzzyMatcher.NATURE_ABBREVIATIONS[query_norm]]
        
        natures = list(stats.NATURE_PLUS_MINUS.keys())
        return FuzzyMatcher.fuzzy_match(query, natures, threshold=0.75)

# Keep old function for backwards compatibility
def _fuzzy_best(query: str, choices: list[str]):
    """
    Return (best_choice, best_ratio, suggestions[:3]) using difflib.
    best_ratio is 0..1; ~0.90 is a good autocorrect threshold.
    (Legacy function - use FuzzyMatcher for new code)
    """
    qc = _canon(query)
    if not choices:
        return None, 0.0, []
    scored = []
    for c in choices:
        ratio = difflib.SequenceMatcher(a=qc, b=_canon(c)).ratio()
        scored.append((ratio, c))
    scored.sort(reverse=True)
    best_ratio, best = scored[0]
    suggestions = [c for r, c in scored if r >= 0.72][:3]
    return best, best_ratio, suggestions

# --- replace your existing resolve_team_mon with this version ---
async def resolve_team_mon(
    interaction,
    name: str,
    slot: int | None = None,
    *,
    threshold: float = 0.85,  # relaxed from 0.90
    conn=None,
) -> dict | None:
    """
    Resolve a user's TEAM Pok√©mon by fuzzy name (and optional slot).
    - Autocorrects on a confident match OR when the name looks like a prefix variant.
    - If duplicates and slot not given, prompts which slot to specify.
    - Sends an ephemeral message itself on failure and returns None.
    - Pass conn from db.session() to reuse a connection (e.g. for mpokeinfo).
    """
    # If caller hasn't replied yet, safely defer so followups work
    try:
        if not interaction.response.is_done():
            await interaction.response.defer(ephemeral=True, thinking=True)
    except Exception:
        pass

    uid = str(interaction.user.id)

    # Try cache first (avoids DB round-trip)
    team = None
    if db_cache is not None:
        try:
            cached = db_cache.get_cached_pokemons(uid)
            if cached is None:
                # Populate cache on miss (for mpokeinfo, /team, etc.)
                await db.list_pokemons(uid, limit=2000, offset=0)
                cached = db_cache.get_cached_pokemons(uid)
            if cached is not None:
                team = [
                    {"id": p.get("id"), "species": p.get("species"), "team_slot": p.get("team_slot")}
                    for p in cached
                    if p.get("team_slot") and 1 <= int(p.get("team_slot") or 0) <= 6
                ]
                team.sort(key=lambda p: (int(p.get("team_slot") or 0), int(p.get("id") or 0)))
        except Exception:
            pass

    if team is None:
        async def _run(qconn):
            cur = await qconn.execute("""
                SELECT id, species, team_slot
                FROM pokemons
                WHERE owner_id = ?
                  AND team_slot BETWEEN 1 AND 6
                ORDER BY team_slot, id
            """, (uid,))
            out = [dict(r) for r in await cur.fetchall()]
            await cur.close()
            return out

        if conn is not None:
            team = await _run(conn)
        else:
            async with db.session() as c:
                team = await _run(c)
        # Populate cache for future mpokeinfo, /team calls
        try:
            await db.list_pokemons(uid, limit=2000, offset=0)
        except Exception:
            pass

    if not team:
        await interaction.followup.send("Your team is empty.", ephemeral=True)
        return None

    # Group by species
    species_map: dict[str, list[dict]] = {}
    for r in team:
        species_map.setdefault(r["species"].lower(), []).append(r)

    key = name.lower()
    autocorrected_to = None

    if key not in species_map:
        names = list(species_map.keys())
        best, score, suggestions = _fuzzy_best(name, names)

        # NEW: prefix/near-prefix heuristic (helps "charmand" -> "charmander")
        qc = _canon(name)
        bc = _canon(best) if best else ""
        is_prefixish = bool(best) and len(qc) >= 4 and (bc.startswith(qc) or qc.startswith(bc))

        if best and (score >= threshold or is_prefixish):
            key = best
            autocorrected_to = best.title()
        elif suggestions:
            pretty = ", ".join(s.title() for s in suggestions)
            await interaction.followup.send(
                f"No **{name.title()}** in your team. Did you mean: {pretty} ?\n"
                f"Re-run with the corrected name (and `slot:` if you have duplicates).",
                ephemeral=True
            )
            return None
        else:
            have = ", ".join(sorted({r['species'].title() for r in team}))
            await interaction.followup.send(
                f"No **{name.title()}** in your team. Team contains: {have}.",
                ephemeral=True
            )
            return None

    mons = species_map[key]

    # Duplicate handling
    if len(mons) > 1 and slot is None:
        choices = ", ".join(f"slot {m['team_slot']} (ID #{m['id']})" for m in mons)
        await interaction.followup.send(
            f"You have {len(mons)} **{key.title()}** in your team: {choices}.\n"
            f"Re-run with `slot:<1-6>`.",
            ephemeral=True
        )
        return None

    # Choose the one in the requested slot (or first)
    if slot is not None:
        for m in mons:
            if int(m["team_slot"]) == int(slot):
                m = dict(m)
                break
        else:
            choices = ", ".join(str(m["team_slot"]) for m in mons)
            await interaction.followup.send(
                f"No **{key.title()}** in team slot {slot}. Available slots: {choices}.",
                ephemeral=True
            )
            return None
    else:
        m = dict(mons[0])

    if autocorrected_to:
        m["_autocorrected_to"] = autocorrected_to
    return m
async def _item_index(conn) -> tuple[dict, list[str]]:
    """
    Build a lookup: candidate_string -> row_dict and the flat list of candidates.
    Candidates include items.id and items.name (if present).
    """
    cur = await conn.execute("SELECT * FROM items")
    rows = [dict(r) for r in await cur.fetchall()]
    await cur.close()

    lookup: dict[str, dict] = {}
    candidates: list[str] = []
    for r in rows:
        iid = r["id"]
        lookup[iid] = r;    candidates.append(iid)
        nm = (r.get("name") or "").strip()
        if nm:
            lookup[nm] = r; candidates.append(nm)
    return lookup, candidates


def _is_prefixish(a: str, b: str) -> bool:
    qa = _canon(a)
    qb = _canon(b)
    return len(qa) >= 4 and (qb.startswith(qa) or qa.startswith(qb))

async def _resolve_item_fuzzy(conn, query: str, *, threshold: float = 0.85):
    """
    Returns (row_dict | None, autocorrect_to | None, suggestions: list[str])
    - Exact match on id or name (case-insensitive)
    - Else fuzzy match using your _fuzzy_best helpers
    """
    q = (query or "").strip()

    # 1) exact by canonical id (e.g., "poke_ball")
    canon_id = item_id_from_user(q)
    cur = await conn.execute("SELECT * FROM items WHERE LOWER(id) = LOWER(?) LIMIT 1", (canon_id,))
    row = await cur.fetchone(); await cur.close()
    if row:
        return dict(row), None, []

    # 2) exact by display name (case-insensitive)
    cur = await conn.execute("SELECT * FROM items WHERE LOWER(name) = LOWER(?) LIMIT 1", (q,))
    row = await cur.fetchone(); await cur.close()
    if row:
        return dict(row), None, []

    # 3) fuzzy: use cache when available, else DB
    rows = []
    if db_cache is not None:
        rows = [{"id": r.get("id"), "name": r.get("name") or r.get("id")} for r in db_cache.get_all_cached_items()]
    if not rows:
        cur = await conn.execute("SELECT id, COALESCE(name, id) AS name FROM items")
        rows = [dict(r) for r in await cur.fetchall()]
        await cur.close()
    names = [r["name"] for r in rows]

    best, score, suggestions = _fuzzy_best(q, names)
    if best and (score >= threshold or _is_prefixish(q, best)):
        match_id = next((r["id"] for r in rows if r["name"] == best), None)
        if match_id:
            row = await _fetch_item_by_query(conn, str(match_id))
            if row:
                return dict(row), best, []
    return None, None, [s.title() for s in suggestions[:3]]
##items
MAX_STACK = 999  # per-item cap

class AdminItems(commands.Cog):
    # ---------- helpers ----------
    async def _is_admin(self, user_id: int) -> bool:
        conn = await open_db()
        try:
            cur = await conn.execute("SELECT 1 FROM admins WHERE user_id = ?", (str(user_id),))
            row = await cur.fetchone()
            await cur.close()
            return row is not None
        finally:
            await conn.close()

    async def _resolve_item(self, conn, query: str):
        """Use project fuzzy resolver if available, else LIKE fallback."""
        try:
            return await _resolve_item_fuzzy(conn, query)  # your existing helper
        except Exception:
            like = f"%{query.lower()}%"
            cur = await conn.execute(
                "SELECT id, name FROM items WHERE LOWER(id) LIKE ? OR LOWER(name) LIKE ? LIMIT 25",
                (like, like)
            )
            rows = await cur.fetchall()
            await cur.close()
            if not rows:
                return None, None, []
            best = rows[0]
            # (row, autocorrect_to, suggestions)
            return dict(best), (best["name"] or best["id"]), [r["name"] or r["id"] for r in rows[1:6]]
    # ---------- end helpers ----------

    @app_commands.command(
        name="give_item",
        description="(Admin) Give a registered item to a player (cap 999)."
    )
    @app_commands.describe(
        user="The player to receive the item.",
        item="Item id or name (fuzzy).",
        qty="How many to give (>=1)."
    )
    async def give_item(
        self,
        interaction: discord.Interaction,
        user: discord.User,
        item: str,
        qty: app_commands.Range[int, 1, 1_000_000] = 1
    ):
        # admin gate
        if not await self._is_admin(interaction.user.id):
            return await interaction.response.send_message("‚ùå You are not allowed to use this command.", ephemeral=True)

        await interaction.response.defer(ephemeral=True, thinking=True)

        # resolve item using FuzzyMatcher
        conn = await open_db()
        try:
            item_id, confidence, suggestions = await FuzzyMatcher.fuzzy_item(conn, item)
        finally:
            await conn.close()

        if not item_id or confidence < 0.70:
            sugg_text = f" Did you mean: {', '.join(suggestions[:5])}?" if suggestions else ""
            return await interaction.followup.send(
                f"‚ùå Item **{item}** not found.{sugg_text}",
                ephemeral=True
            )

        # Get full item details
        conn = await open_db()
        try:
            cur = await conn.execute("SELECT id, name FROM items WHERE id = ?", (item_id,))
            row = await cur.fetchone()
            await cur.close()
        finally:
            await conn.close()

        if not row:
            return await interaction.followup.send(f"‚ùå Item **{item_id}** not found in database.", ephemeral=True)

        item_id = row["id"]
        pretty = row["name"] if row["name"] else item_id
        owner = str(user.id)

        async with DB_WRITE_LOCK:
            conn = await open_db()
            try:
                # Postgres uses BEGIN; SQLite uses BEGIN IMMEDIATE
                await conn.execute("BEGIN" if getattr(db, "DB_IS_POSTGRES", False) else "BEGIN IMMEDIATE")

                # ensure user exists
                cur = await conn.execute("SELECT 1 FROM users WHERE user_id = ?", (owner,))
                exists = await cur.fetchone(); await cur.close()
                if not exists:
                    await conn.execute("INSERT INTO users(user_id, coins, currencies) VALUES(?, 3000, '{\"coins\": 3000}'::jsonb)", (owner,))

                # current qty
                cur = await conn.execute(
                    "SELECT qty FROM user_items WHERE owner_id=? AND item_id=?",
                    (owner, item_id)
                )
                r = await cur.fetchone(); await cur.close()
                current = int(r[0]) if r else 0

                if current >= MAX_STACK:
                    await conn.execute("ROLLBACK")
                    return await interaction.followup.send(
                        f"‚ùå {user.mention} already has **{current}/{MAX_STACK}** `{pretty}`.",
                        ephemeral=True
                    )

                allowed = min(int(qty), MAX_STACK - current)
                if allowed <= 0:
                    await conn.execute("ROLLBACK")
                    return await interaction.followup.send(
                        f"‚ùå Cannot give more `{pretty}` due to the cap ({current}/{MAX_STACK}).",
                        ephemeral=True
                    )

                await conn.execute(
                    "INSERT INTO user_items(owner_id, item_id, qty) VALUES(?,?,?) "
                    "ON CONFLICT(owner_id, item_id) DO UPDATE SET qty = LEAST(user_items.qty + excluded.qty, ?::int);",
                    (owner, item_id, allowed, MAX_STACK)
                )

                cur = await conn.execute(
                    "SELECT qty FROM user_items WHERE owner_id=? AND item_id=?",
                    (owner, item_id)
                )
                r = await cur.fetchone(); await cur.close()
                new_qty = int(r[0]) if r else current

                await _tx_commit(conn)
                db.invalidate_bag_cache(owner)
            finally:
                await conn.close()

        note = ""
        if allowed < int(qty):
            note = f" (reduced by cap to {allowed}; now **{new_qty}/{MAX_STACK}**)"

        # Show autocorrect info if item name differs from query
        autocorrect_note = ""
        if item.lower() != item_id.lower() and item.lower() != pretty.lower():
            autocorrect_note = f" (matched: {pretty})"

        desc = f"‚úÖ Gave **{allowed}√ó {pretty}** to {user.mention}{note}{autocorrect_note}"
        emb = discord.Embed(description=desc, color=0x57F287)
        await interaction.followup.send(embed=emb, ephemeral=True)

    # üîΩ AUTOCOMPLETE ‚Äî note it targets the param name **'item'**, not 'item_id'
    @give_item.autocomplete("item")
    async def give_item_autocomplete(
        self,
        interaction: discord.Interaction,
        current: str
    ) -> list[app_commands.Choice[str]]:
        q = (current or "").strip().lower()
        if not q:
            return []

        like = f"%{q}%"
        conn = await open_db()
        try:
            cur = await conn.execute(
                "SELECT id, name FROM items "
                "WHERE LOWER(id) LIKE ? OR LOWER(name) LIKE ? "
                "ORDER BY CASE "
                "  WHEN LOWER(id)=? OR LOWER(name)=? THEN 0 "
                "  WHEN LOWER(id) LIKE ? OR LOWER(name) LIKE ? THEN 1 "
                "  ELSE 2 "
                "END, id "
                "LIMIT 25",
                (like, like, q, q, like, like)
            )
            rows = await cur.fetchall(); await cur.close()
        finally:
            await conn.close()

        choices: list[app_commands.Choice[str]] = []
        for r in rows:
            _id = r["id"]; _name = r["name"]
            label = f"{_name} ({_id})" if _name and _name.lower() != _id else _id
            choices.append(app_commands.Choice(name=label, value=_id))
        return choices
    def __init__(self, bot: commands.Bot):
        self.bot = bot
    # /merge_item_id
    @app_commands.command(
        name="merge_item_id",
        description="(DB Admin) Merge an old item id into a canonical item id (fix duplicates like pokeball ‚Üí poke_ball)."
    )
    @app_commands.describe(
        old_id="Alias to replace (e.g. pokeball)",
        new_id="Canonical id to keep (e.g. poke_ball)"
    )
    @admin_only()
    async def merge_item_id(
        self,
        interaction: Interaction,
        old_id: str,
        new_id: str
    ):
        await interaction.response.defer(ephemeral=False)

        old_norm = item_id_from_user(old_id)
        new_norm = item_id_from_user(new_id)

        if old_norm == new_norm:
            return await interaction.followup.send(
                "‚ö†Ô∏è The old id and new id are the same after normalization.",
                ephemeral=True
            )

        moved = await db.merge_item_ids(old_norm, new_norm)
        await interaction.followup.send(
            f"üîß Merged `{old_norm}` ‚Üí `{new_norm}` (moved {moved} inventory rows).",
            ephemeral=True
        )

    # /items_autofix
    @app_commands.command(
        name="items_autofix",
        description="(DB Admin) Suggest and merge common item id aliases; list orphans."
    )
    @admin_only()
    async def items_autofix(self, interaction: Interaction):
        await interaction.response.defer(ephemeral=True, thinking=True)

        try:
            orphans = await db.find_orphan_user_item_ids()
        except AttributeError:
            orphans = []

        try:
            pairs = await db.find_probable_alias_pairs()
        except AttributeError:
            pairs = []

        if not orphans and not pairs:
            return await interaction.followup.send("‚úÖ No obvious problems found.", ephemeral=True)

        lines = []
        if orphans:
            lines.append("**Orphans in `user_items` (no matching `items.id`):**")
            lines += [f"‚Ä¢ `{i}`" for i in orphans]
            lines.append("_Create these in `items` or merge them into an existing id._")

        if pairs:
            results = await db.merge_many(pairs)
            moved_total = sum(n for *_ , n in results)
            lines.append("\n**Merged duplicate ids (old ‚Üí new):**")
            lines += [f"‚Ä¢ `{a}` ‚Üí `{b}`" for (a, b, _) in results]
            lines.append(f"\nüîß Affected rows: **{moved_total}**")

        await interaction.followup.send("\n".join(lines), ephemeral=True)
## shinies 
async def _reply(interaction: discord.Interaction, *args, **kwargs):
    """
    Sends either via interaction.response.send_message (first reply)
    or via interaction.followup.send if the interaction was already responded to / deferred.
    """
    if interaction.response.is_done():
        return await interaction.followup.send(*args, **kwargs)
    else:
        return await interaction.response.send_message(*args, **kwargs)

# --- Force embeds for user-facing interaction responses ---
_EMBED_WRAP_ENABLED = False

def _content_needs_plain_text(content: str) -> bool:
    if not content:
        return False
    if "@everyone" in content or "@here" in content:
        return True
    if "<@" in content or "<#" in content:
        return True
    return False

def _wrap_content_into_embed(kwargs: dict) -> None:
    if kwargs.get("embed") is not None:
        return
    if kwargs.get("embeds"):
        return
    content = kwargs.get("content")
    if content is None:
        return
    content_str = str(content)
    if not content_str.strip():
        return
    if len(content_str) > 3900:
        kwargs["embed"] = discord.Embed(description="(message)")
        # keep content to avoid embed length issues
        return
    kwargs["embed"] = discord.Embed(description=content_str)
    if not _content_needs_plain_text(content_str):
        kwargs["content"] = None

def _wrap_send_func(func):
    func_name = getattr(func, "__name__", "")
    accepts_positional_content = func_name in {"send", "send_message"}

    async def wrapped(self, *args, **kwargs):
        # Preserve positional IDs for edit_message(message_id=...) calls.
        if accepts_positional_content and args and "content" not in kwargs:
            kwargs["content"] = args[0]
            args = args[1:]
        _wrap_content_into_embed(kwargs)
        return await func(self, *args, **kwargs)
    return wrapped

def _enable_embed_only_messages() -> None:
    global _EMBED_WRAP_ENABLED
    if _EMBED_WRAP_ENABLED:
        return
    _EMBED_WRAP_ENABLED = True
    try:
        discord.InteractionResponse.send_message = _wrap_send_func(discord.InteractionResponse.send_message)
    except Exception:
        pass
    try:
        discord.InteractionResponse.edit_message = _wrap_send_func(discord.InteractionResponse.edit_message)
    except Exception:
        pass
    try:
        if hasattr(discord, "Webhook"):
            discord.Webhook.send = _wrap_send_func(discord.Webhook.send)
            if hasattr(discord.Webhook, "edit_message"):
                discord.Webhook.edit_message = _wrap_send_func(discord.Webhook.edit_message)
    except Exception:
        pass
##money:
COIN = "ü™ô"
PKDollar_NAME = "Pok√©Dollars"

def _norm_item_query(s: str) -> str:
    return _canonical_item_token(s)

async def _fetch_item_by_query(conn, q: str) -> dict | None:
    """Find by id or english name (case-insensitive). Uses item cache when available."""
    if db_cache is not None:
        cached = db_cache.get_cached_item(q)
        if cached is not None:
            return cached

    qn = _norm_item_query(q)
    # try id
    cur = await conn.execute("SELECT * FROM items WHERE id = ? LIMIT 1", (qn,))
    row = await cur.fetchone()
    if row:
        await cur.close()
        d = dict(row)
        if db_cache is not None:
            db_cache.set_cached_item(q, d)
        return d
    await cur.close()
    # try by name
    cur = await conn.execute("SELECT * FROM items WHERE LOWER(name) = LOWER(?) LIMIT 1", (q.strip(),))
    row = await cur.fetchone()
    await cur.close()
    if row:
        d = dict(row)
        if db_cache is not None:
            db_cache.set_cached_item(q, d)
        return d
    return None

async def _user_item_qty(conn, owner_id: str, item_id: str) -> int:
    aliases = _item_alias_tokens(item_id)
    if not aliases:
        base = _canonical_item_token(item_id) or _normalize_item_token(item_id)
        aliases = [base] if base else []
    if not aliases:
        return 0
    placeholders = ", ".join("?" for _ in aliases)
    cur = await conn.execute(
        f"SELECT COALESCE(SUM(qty), 0) AS qty_total FROM user_items "
        f"WHERE owner_id=? AND LOWER(REPLACE(item_id, '-', '_')) IN ({placeholders})",
        (owner_id, *aliases)
    )
    row = await cur.fetchone()
    await cur.close()
    try:
        return int((row.get("qty_total") if hasattr(row, "keys") else (row[0] if row else 0)) or 0)
    except Exception:
        return 0


async def _user_money(conn, owner_id: str) -> int:
    await conn.execute("INSERT OR IGNORE INTO user_meta(owner_id) VALUES (?)", (owner_id,))
    cur = await conn.execute("SELECT money FROM user_meta WHERE owner_id=?", (owner_id,))
    row = await cur.fetchone(); await cur.close()
    return int(row["money"] or 0)

async def _set_user_money(conn, owner_id: str, new_val: int) -> None:
    await conn.execute("UPDATE user_meta SET money=? WHERE owner_id=?", (int(new_val), owner_id))

def _item_title_line(row: dict) -> str:
    emoji = row.get("emoji") or ""
    nm = row.get("name") or row["id"]
    nice = pretty_item_name(nm)
    return f"{emoji + ' ' if emoji else ''}{nice}"
ASSETS_DIR = Path(__file__).resolve().parent / "assets"
ITEM_ICON_DIR = ASSETS_DIR / "item_icons"
def _looks_http(s: str | None) -> bool:
    return isinstance(s, str) and (s.startswith("http://") or s.startswith("https://"))


def _is_displayable_item_emoji(s: str | None) -> bool:
    """True if we should show this in embeds. Bare :shortcode: renders as literal text ‚Äî hide it."""
    if not s or not isinstance(s, str):
        return False
    s = s.strip()
    if not s:
        return False
    # Bare :shortcode: (e.g. :choicescarf:) shows as text when emoji missing ‚Äî don't display
    if s.startswith(":") and ":" in s[1:] and not s.startswith("<"):
        return False
    return True
def item_icon_file(item_id: str) -> tuple[str | None, discord.File | None]:
    """
    Returns (attachment_url, discord.File) if we have a local icon,
    else (None, None). Use the returned File in send()/edit().
    """
    safe = str(item_id).lower().strip()
    p = ITEM_ICON_DIR / f"{safe}.png"
    if not p.exists():
        return None, None
    # to reference an attachment in an embed, use "attachment://<filename>"
    return f"attachment://{p.name}", discord.File(p, filename=p.name)
# ---------- item display helpers ----------

def build_item_embed(item_row: dict, owner_id: int, price: int, have_qty: int) -> discord.Embed:
    """
    Build a clean embed for an item panel.
    Expects item_row to contain at least: id, name (optional), description (optional),
    icon_url (optional), category (optional), sell_price (optional).
    """
    title = pretty_item_name(item_row.get("name") or item_row.get("id") or "")
    desc  = (item_row.get("description") or "‚Äî").strip()

    e = discord.Embed(title=title, description=desc)

    # Thumbnail (only one image to avoid the ‚Äúdouble icon‚Äù issue)
    icon = item_row.get("icon_url")
    if icon:
        e.set_thumbnail(url=icon)

    e.add_field(name="Price",   value=f"{int(price or 0):,} {PKDollar_NAME}", inline=True)
    e.add_field(name="You own", value=str(int(have_qty or 0)),     inline=True)

    cat = (item_row.get("category") or "").replace("_", " ").title()
    if cat:
        e.add_field(name="Category", value=cat, inline=True)

    sp = item_row.get("sell_price")
    if sp is not None:
        e.add_field(name="Sell Price", value=f"{int(sp):,} {PKDollar_NAME}", inline=True)

    return e
## bag
async def _decrement_user_item(owner_id: str, item_id: str, amount: int = 1) -> bool:
    """
    Remove `amount` of `item_id` from the user's bag.
    Returns True if successful, False if not enough quantity.
    """
    conn = await db.connect()
    try:
        ok = await _bag_adjust_conn(conn, str(owner_id), str(item_id), -int(amount))
        if not ok:
            return False
        await conn.commit()
        db.invalidate_bag_cache(owner_id)
        return True
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _get_item_qty(owner_id: str, item_id: str, conn=None) -> int:
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        aliases = _item_alias_tokens(item_id)
        if not aliases:
            base = _canonical_item_token(item_id) or _normalize_item_token(item_id)
            aliases = [base] if base else []
        if not aliases:
            return 0
        placeholders = ", ".join("?" for _ in aliases)
        cur = await conn.execute(
            f"SELECT COALESCE(SUM(qty), 0) AS qty_total FROM user_items "
            f"WHERE owner_id=? AND LOWER(REPLACE(item_id, '-', '_')) IN ({placeholders})",
            (owner_id, *aliases),
        )
        row = await cur.fetchone()
        await cur.close()
        try:
            return int((row.get("qty_total") if hasattr(row, "keys") else (row[0] if row else 0)) or 0)
        except Exception:
            return 0
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


EXP_SHARE_ITEM_IDS: tuple[str, ...] = ("exp_share", "exp-share", "expshare")
EXP_SHARE_COST_PKC = 20_000


async def _has_exp_share_bag_item(owner_id: str, conn=None) -> bool:
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        oid = str(owner_id)
        placeholders = ", ".join("?" for _ in EXP_SHARE_ITEM_IDS)
        cur = await conn.execute(
            f"SELECT COALESCE(SUM(qty), 0) AS total_qty FROM user_items WHERE owner_id=? AND item_id IN ({placeholders})",
            (oid, *EXP_SHARE_ITEM_IDS),
        )
        row = await cur.fetchone()
        await cur.close()
        try:
            total_qty = int((row.get("total_qty") if hasattr(row, "keys") else row[0]) or 0) if row else 0
        except Exception:
            total_qty = 0
        return total_qty > 0
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass

async def _count_item_in_use(owner_id: str, item_id: str, conn=None) -> int:
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        aliases = _item_alias_tokens(item_id)
        if not aliases:
            base = _canonical_item_token(item_id) or _normalize_item_token(item_id)
            aliases = [base] if base else []
        if not aliases:
            return 0
        placeholders = ", ".join("?" for _ in aliases)
        cur = await conn.execute(
            f"SELECT COUNT(*) AS used_total FROM pokemons "
            f"WHERE owner_id=? AND LOWER(REPLACE(COALESCE(held_item, ''), '-', '_')) IN ({placeholders})",
            (owner_id, *aliases),
        )
        row = await cur.fetchone()
        await cur.close()
        try:
            return int((row.get("used_total") if hasattr(row, "keys") else (row[0] if row else 0)) or 0)
        except Exception:
            return 0
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass

async def _get_usage(owner_id: str, item_id: str, conn=None) -> tuple[int, int]:
    """Single query: (used, total). Use for usage checks and display."""
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        total = int(await _get_item_qty(str(owner_id), str(item_id), conn=conn))
        used = int(await _count_item_in_use(str(owner_id), str(item_id), conn=conn))
        return used, total
    except Exception:
        return 0, 0
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


def _item_category_is_consumable(category: Any) -> bool:
    """Return True for item categories that should spend bag qty on /give."""
    c = str(category or "").strip().lower().replace("-", "_").replace(" ", "_")
    if not c:
        return False
    if c in {"consumable", "single_use", "singleuse", "one_time_use"}:
        return True
    return "consum" in c


_CONSUMABLE_ITEM_ID_OVERRIDES: frozenset[str] = frozenset(
    {
        "ether",
        "max_ether",
        "elixir",
        "max_elixir",
        "pp_up",
        "pp_max",
    }
)


def _item_forces_consumable(item_id: Any) -> bool:
    try:
        canon = _canonical_item_token(str(item_id or ""))
    except Exception:
        canon = str(item_id or "").strip().lower().replace("-", "_").replace(" ", "_")
    return canon in _CONSUMABLE_ITEM_ID_OVERRIDES


async def _item_is_consumable_conn(conn, item_id: str) -> bool:
    try:
        cur = await conn.execute("SELECT category FROM items WHERE id=? LIMIT 1", (str(item_id),))
        row = await cur.fetchone()
        await cur.close()
        cat = (row["category"] if hasattr(row, "keys") else (row[0] if row else None))
        return _item_category_is_consumable(cat)
    except Exception:
        return False


async def _bag_adjust_conn(conn, owner_id: str, item_id: str, delta: int) -> bool:
    """
    Adjust one bag stack by delta within an existing DB connection.
    Returns False when the adjustment would make qty negative.
    """
    d = int(delta or 0)
    if d == 0:
        return True
    canonical_item_id = _canonical_item_token(str(item_id)) or _normalize_item_token(item_id)
    if not canonical_item_id:
        return False
    aliases = _item_alias_tokens(canonical_item_id)
    if not aliases:
        aliases = [canonical_item_id]
    placeholders = ", ".join("?" for _ in aliases)
    cur = await conn.execute(
        f"SELECT item_id, qty FROM user_items "
        f"WHERE owner_id=? AND LOWER(REPLACE(item_id, '-', '_')) IN ({placeholders})",
        (str(owner_id), *aliases),
    )
    rows = await cur.fetchall()
    await cur.close()
    if rows:
        try:
            seen_ids: list[str] = []
            for row in rows:
                rid = str((row["item_id"] if hasattr(row, "keys") else row[0]) or "").strip()
                if rid:
                    seen_ids.append(rid)
            if seen_ids and all(str(canonical_item_id) != rid for rid in seen_ids):
                canon_norm = _normalize_item_token(canonical_item_id)
                for rid in seen_ids:
                    if _normalize_item_token(rid) == canon_norm:
                        canonical_item_id = rid
                        break
        except Exception:
            pass
    old_qty = 0
    for row in rows or []:
        try:
            old_qty += int((row["qty"] if hasattr(row, "keys") else row[1]) or 0)
        except Exception:
            continue
    new_qty = int(old_qty + d)
    if new_qty < 0:
        return False
    await conn.execute(
        f"DELETE FROM user_items WHERE owner_id=? AND LOWER(REPLACE(item_id, '-', '_')) IN ({placeholders})",
        (str(owner_id), *aliases),
    )
    if new_qty > 0:
        await conn.execute(
            "INSERT INTO user_items(owner_id, item_id, qty) VALUES(?,?,?) "
            "ON CONFLICT(owner_id, item_id) DO UPDATE SET qty=excluded.qty",
            (str(owner_id), str(canonical_item_id), int(new_qty)),
        )
    return True

async def _usage_str(owner_id: str, item_id: str, conn=None) -> str:
    used, total = await _get_usage(owner_id, item_id, conn)
    return f"{used}/{total}"


class ConfirmSwapView(discord.ui.View):
    """Generic confirm/cancel view with correct callback signatures."""
    def __init__(self, *, timeout: float = 120.0):
        super().__init__(timeout=timeout)
        self._confirmed: bool | None = None

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.success)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        self._confirmed = True
        # edit the message that has this view
        if interaction.response.is_done():
            try:
                await interaction.message.edit(content="Confirmed.", view=None)  # type: ignore
            except Exception:
                pass
        else:
            await interaction.response.edit_message(content="Confirmed.", view=None)
        self.stop()

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.danger)
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        self._confirmed = False
        if interaction.response.is_done():
            try:
                await interaction.message.edit(content="Cancelled.", view=None)  # type: ignore
            except Exception:
                pass
        else:
            await interaction.response.edit_message(content="Cancelled.", view=None)
        self.stop()

    @property
    def confirmed(self) -> bool | None:
        return self._confirmed

@bot.tree.command(
    name="give",
    description="Give an item from your bag to a team Pok√©mon (consumables spend one copy)."
)
@app_commands.describe(
    name="Pok√©mon species (e.g., garchomp)",
    item="Item id or name to give (autocorrects)",
    slot="Team slot (1‚Äì6) if you have duplicates"
)
async def give_item(interaction: discord.Interaction, name: str, item: str, slot: int | None = None):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)

    # Resolve team Pok√©mon
    mon = await resolve_team_mon(interaction, name, slot)
    if not mon:
        return
    mon_id = int(mon["id"])
    mon_name = mon['species'].title()

    # Resolve item with fuzzy matching
    conn = await db.connect()
    try:
        # Use FuzzyMatcher for intelligent item matching
        item_id, confidence, suggestions = await FuzzyMatcher.fuzzy_item(conn, item)
        
        if not item_id or confidence < 0.70:
            sugg_text = f" Did you mean: {', '.join(suggestions[:5])}?" if suggestions else ""
            return await interaction.followup.send(
                f"‚ùå Item **{item}** not found.{sugg_text}",
                ephemeral=True
            )
        
        # Get full item details
        cur = await conn.execute("SELECT id, name, emoji, category FROM items WHERE id = ?", (item_id,))
        row = await cur.fetchone()
        await cur.close()
        
        if not row:
            return await interaction.followup.send(f"‚ùå Item **{item_id}** not found in database.", ephemeral=True)
        
        give_id = row["id"]
        if not give_id:
            return await interaction.followup.send("‚ùå Invalid item.", ephemeral=True)

        # Convert Row to dict for .get() method
        row_dict = dict(row)
        canonical_give_id = _canonical_item_token(give_id) or str(give_id)
        if canonical_give_id and canonical_give_id != str(give_id):
            canonical_row = await _fetch_item_by_query(conn, canonical_give_id)
            if canonical_row:
                give_id = canonical_give_id
                row_dict = dict(canonical_row)

        give_emoji_raw = (row_dict.get("emoji") or "").strip()
        give_emoji = give_emoji_raw if _is_displayable_item_emoji(give_emoji_raw) else ""
        give_disp = pretty_item_name(row_dict.get("name") or row_dict.get("id") or item)
        give_is_consumable = _item_category_is_consumable(row_dict.get("category")) or _item_forces_consumable(give_id)
        # Show autocorrect if the matched item is different from what user typed
        ac_suffix = f" _(autocorrected to {give_disp})_" if item.lower().replace(" ", "-") != give_id.lower() else ""

        async def _stock_text(item_id_local: str, *, consumable: bool) -> str:
            if consumable:
                qty_local = await _get_item_qty(uid, item_id_local, conn)
                return f"{qty_local} in bag"
            usage_local = await _usage_str(uid, item_id_local, conn)
            return f"{usage_local} in use"

        if give_is_consumable:
            bag_qty = await _get_item_qty(uid, give_id, conn)
            if bag_qty <= 0:
                return await interaction.followup.send(
                    f"‚ùå You don't have {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** in your bag.{ac_suffix}",
                    ephemeral=True,
                )
        else:
            # Non-consumables use free-pool usage checks.
            used_now, total_qty = await _get_usage(uid, give_id, conn)
            if total_qty <= 0:
                return await interaction.followup.send(
                    f"‚ùå You don't have {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** in your bag.{ac_suffix}",
                    ephemeral=True,
                )
            free = total_qty - used_now
            if free <= 0:
                usage = f"{used_now}/{total_qty}"
                return await interaction.followup.send(
                    f"‚ùå All copies of {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** are in use (**{usage}**).\n"
                    f"üí° Use `/take` to remove it from another Pok√©mon first.{ac_suffix}",
                    ephemeral=True,
                )

        # Get current held item
        cur = await conn.execute("SELECT held_item FROM pokemons WHERE owner_id=? AND id=?", (uid, mon_id))
        hold_row = await cur.fetchone()
        await cur.close()
        current_held = (hold_row["held_item"] if hasattr(hold_row, "keys") else (hold_row[0] if hold_row else None)) or None

        # Check if already holding the same item
        if current_held and _canonical_item_token(current_held) == _canonical_item_token(give_id):
            usage = await _stock_text(give_id, consumable=give_is_consumable)
            return await interaction.followup.send(
                f"‚ÑπÔ∏è **{mon_name}** already holds {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** (**{usage}**).{ac_suffix}",
                ephemeral=True
            )

        # If no current item, just give it
        if not current_held:
            try:
                if give_is_consumable:
                    consumed = await _bag_adjust_conn(conn, uid, give_id, -1)
                    if not consumed:
                        return await interaction.followup.send(
                            f"‚ùå No copies of {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** left in your bag.{ac_suffix}",
                            ephemeral=True,
                        )
                await conn.execute("UPDATE pokemons SET held_item=? WHERE owner_id=? AND id=?", (give_id, uid, mon_id))
                await conn.commit()
                db.invalidate_pokemons_cache(uid)
                if give_is_consumable:
                    db.invalidate_bag_cache(uid)
            except Exception:
                try:
                    await conn.rollback()
                except Exception:
                    pass
                return await interaction.followup.send("‚ùå Failed to give item. Please try again.", ephemeral=True)

            new_usage = await _stock_text(give_id, consumable=give_is_consumable)
            return await interaction.followup.send(
                f"‚úÖ Gave {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** to **{mon_name}** (**{new_usage}**).{ac_suffix}",
                ephemeral=True
            )

        # Get info about current held item
        prow = await _resolve_item_fuzzy(conn, str(current_held))
        if isinstance(prow, tuple):
            prow, _, _ = prow
        pemoji_raw = (prow.get("emoji") if prow else "") or ""
        pemoji = pemoji_raw if _is_displayable_item_emoji(pemoji_raw) else ""
        pdisp = pretty_item_name(prow.get("name") if prow else str(current_held))
        current_is_consumable = _item_category_is_consumable((prow or {}).get("category")) or _item_forces_consumable(current_held)
        if not current_is_consumable and current_held:
            # Fallback if category metadata is missing from cache/fuzzy row.
            current_is_consumable = await _item_is_consumable_conn(conn, str(current_held))
        usage_prev = await _stock_text(str(current_held), consumable=current_is_consumable)
        usage_new = await _stock_text(give_id, consumable=give_is_consumable)

        # Create confirmation view
        view = ConfirmSwapView(timeout=60.0)
        msg = await interaction.followup.send(
            content=(
                f"**{mon_name}** currently holds {(pemoji + ' ') if pemoji else ''}**{pdisp}** (**{usage_prev}**).\n\n"
                f"Switch to {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** (**{usage_new}**)?{ac_suffix}"
            ),
            view=view,
            ephemeral=True,
            wait=True
        )
        
        # Wait for user response
        await view.wait()
        
        if view.confirmed:
            try:
                if give_is_consumable:
                    give_qty = await _get_item_qty(uid, give_id, conn)
                    if give_qty <= 0:
                        return await msg.edit(
                            content=f"‚ùå No copies of **{give_disp}** are left in your bag. Try again.",
                            view=None,
                        )
                    consumed = await _bag_adjust_conn(conn, uid, give_id, -1)
                    if not consumed:
                        return await msg.edit(
                            content=f"‚ùå No copies of **{give_disp}** are left in your bag. Try again.",
                            view=None,
                        )
                else:
                    # Double-check capacity (race condition protection)
                    used_check, total_check = await _get_usage(uid, give_id, conn)
                    if used_check >= total_check:
                        return await msg.edit(
                            content=f"‚ùå All copies of **{give_disp}** are now in use. Try again.",
                            view=None
                        )

                # Consumables are spent when equipped and are not returned on unequip.

                await conn.execute("UPDATE pokemons SET held_item=? WHERE owner_id=? AND id=?", (give_id, uid, mon_id))
                await conn.commit()
                db.invalidate_pokemons_cache(uid)
                if give_is_consumable or current_is_consumable:
                    db.invalidate_bag_cache(uid)
            except Exception:
                try:
                    await conn.rollback()
                except Exception:
                    pass
                return await msg.edit(content="‚ùå Failed to swap held items. Please try again.", view=None)

            new_usage2 = await _stock_text(give_id, consumable=give_is_consumable)
            prev_usage2 = await _stock_text(str(current_held), consumable=current_is_consumable)
            
            await msg.edit(
                content=(
                    f"‚úÖ Switched **{mon_name}'s** held item!\n"
                    f"‚Ä¢ Removed: {(pemoji + ' ') if pemoji else ''}**{pdisp}** (now **{prev_usage2}**)\n"
                    f"‚Ä¢ Equipped: {(give_emoji + ' ') if give_emoji else ''}**{give_disp}** (now **{new_usage2}**){ac_suffix}"
                ),
                view=None
            )
        elif view.confirmed is False:
            await msg.edit(content="‚ùå Item swap cancelled.", view=None)
        else:
            # Timeout
            await msg.edit(content="‚è±Ô∏è Item swap timed out.", view=None)
    
    finally:
        await conn.close()


@bot.tree.command(
    name="take",
    description="Take a held item from a team Pok√©mon. Consumables are not returned to bag."
)
@app_commands.describe(
    name="Pok√©mon species (e.g., garchomp)",
    slot="Team slot (1‚Äì6) if you have duplicates"
)
async def take_item(interaction: discord.Interaction, name: str, slot: int | None = None):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)

    # Team mon selection (uses your fuzzy autocorrect)
    mon = await resolve_team_mon(interaction, name, slot)
    if not mon:
        return
    mon_id = int(mon["id"])

    conn = await db.connect()
    try:
        cur = await conn.execute("SELECT held_item FROM pokemons WHERE owner_id=? AND id=?", (uid, mon_id))
        row = await cur.fetchone(); await cur.close()
        held = (row["held_item"] if hasattr(row, "keys") else (row[0] if row else None)) or None
        if not held:
            return await interaction.followup.send(
                f"‚ÑπÔ∏è **{mon['species'].title()}** isn‚Äôt holding anything.", ephemeral=True
            )

        held_is_consumable = _item_forces_consumable(held)
        if not held_is_consumable:
            try:
                held_is_consumable = await _item_is_consumable_conn(conn, str(held))
            except Exception:
                held_is_consumable = _item_forces_consumable(held)

        # Non-consumables return to bag. Consumables are spent on equip and don't return.
        if not held_is_consumable:
            await conn.execute(
                "INSERT INTO user_items(owner_id, item_id, qty) VALUES(?,?,1) "
                "ON CONFLICT(owner_id, item_id) DO UPDATE SET qty = user_items.qty + 1;",
                (uid, str(_canonical_item_token(held) or held))
            )
            await conn.commit()
            db.invalidate_bag_cache(uid)

        # Now remove it from the Pok√©mon
        try:
            await db.set_held_item(uid, mon_id, None)
        except Exception:
            await conn.execute("UPDATE pokemons SET held_item=NULL WHERE owner_id=? AND id=?", (uid, mon_id))
            await conn.commit()
            db.invalidate_pokemons_cache(uid)

        # Pretty print with updated usage (success path)
        prow, _, _ = await _resolve_item_fuzzy(conn, str(held))
        pemoji_raw = (prow.get("emoji") if prow else "") or ""
        pemoji = pemoji_raw if _is_displayable_item_emoji(pemoji_raw) else ""
        pdisp  = pretty_item_name(prow.get("name") if prow else str(held))
        if held_is_consumable:
            await interaction.followup.send(
                f"‚úÖ Removed {(pemoji + ' ') if pemoji else ''}**{pdisp}** from **{mon['species'].title()}**.\n"
                f"‚ÑπÔ∏è This item is consumable, so it was not returned to your bag.",
                ephemeral=True,
            )
        else:
            usage = await _usage_str(uid, str(held), conn)
            await interaction.followup.send(
                f"‚úÖ Took {(pemoji + ' ') if pemoji else ''}**{pdisp}** from **{mon['species'].title()}** "
                f"(now **{usage}** in use).",
                ephemeral=True
            )
    except Exception as e:
        return await interaction.followup.send(f"‚ùå Failed to take item: {e}", ephemeral=True)
    finally:
        try:
            await conn.close()
        except Exception:
            pass


MAX_STACK = 999
GLOBAL_ITEM_BUY_LOCK_MESSAGE = (
    "üõí Item purchases from this global panel are locked.\n"
    "Use **/adventure** and enter a **Pok√© Mart** to buy/sell items."
)


class QuantityModal(discord.ui.Modal, title="Buy item"):
    def __init__(self, parent_view: "BuyItemView", source_message: discord.Message):
        super().__init__()
        self.parent_view = parent_view
        self.source_message = source_message

        self.qty_input = discord.ui.TextInput(
            label="How many do you want to buy?",
            default="1",
            required=True,
            max_length=3,  # 1..999
            placeholder=f"Enter 1‚Äì{MAX_STACK}"
        )
        self.add_item(self.qty_input)

    async def on_submit(self, itx: discord.Interaction):
        await itx.response.defer(ephemeral=True)  # ACK immediately
        # Legacy global buy flow is intentionally disabled.
        return await itx.followup.send(GLOBAL_ITEM_BUY_LOCK_MESSAGE, ephemeral=True)
class BuyItemView(discord.ui.View):
    def __init__(self, owner_id: int, item_row: dict, price: int, have_qty: int):
        super().__init__(timeout=90)
        self.owner_id = owner_id
        self.item_row = item_row
        self.price = int(price or 0)
        self.have_qty = have_qty

        self.buy_btn = discord.ui.Button(
            label="Buy in Pok√© Mart",
            style=discord.ButtonStyle.secondary,
            disabled=True,
        )
        self.add_item(self.buy_btn)
        self.buy_btn.callback = self.on_buy_click

        self.bound_message: discord.Message | None = None

    async def on_buy_click(self, itx: discord.Interaction):
        if itx.user.id != self.owner_id:
            return await itx.response.send_message("This shop panel isn‚Äôt for you.", ephemeral=True)
        return await itx.response.send_message(GLOBAL_ITEM_BUY_LOCK_MESSAGE, ephemeral=True)


@bot.tree.command(name="item", description="Show info about an item.")
@app_commands.describe(name="Item id or name (e.g. 'poke ball', 'choice scarf')")
async def item_cmd(interaction: discord.Interaction, name: str):
    start_time = time.time()
    # Defer IMMEDIATELY - wrapped in try/catch for expired interactions
    try:
        if not interaction.response.is_done():
            await interaction.response.defer(ephemeral=True, thinking=True)
            defer_time = time.time() - start_time
            if defer_time > 1.0:
                print(f"[SLOW] /item defer took {defer_time:.2f}s")
    except discord.errors.NotFound:
        elapsed = time.time() - start_time
        print(f"[WARNING] /item command expired after {elapsed:.2f}s")
        return

    # Resolve item (exact or fuzzy)
    conn = await db.connect()
    try:
        row, autocorrect_to, suggestions = await _resolve_item_fuzzy(conn, name)

        if row is None:
            if suggestions:
                return await interaction.followup.send(
                    f"‚ùå Item **{name}** not found. Did you mean: {', '.join(suggestions)} ?",
                    ephemeral=True
                )
            return await interaction.followup.send(
                f"‚ùå Item **{name}** not found. Try `/items` to browse.",
                ephemeral=True
            )

        item_id = row["id"]
        price = int(row.get("price") or 0)

        # ‚úÖ Alias-aware quantity lookup (collapses legacy ids like pokeball/poke_ball).
        uid = str(interaction.user.id)
        have_qty = await _user_item_qty(conn, uid, item_id)

        # Build embed (per-unit price is shown inside)
        embed = build_item_embed(row, interaction.user.id, price, have_qty)
        embed.title = pretty_item_name(row.get("name") or item_id)

        # Display sprite in BOTH locations: author icon (small) + thumbnail (large)
        files = None
        att_url, att_file = item_icon_file(item_id)     # ("attachment://...", discord.File) or (None, None)
        if att_file:
            embed.set_author(name=embed.title, icon_url=att_url)  # Small icon next to title
            embed.set_thumbnail(url=att_url)  # Large image on the right
            files = [att_file]
        elif row.get("icon_url"):
            embed.set_author(name=embed.title, icon_url=row["icon_url"])  # Small icon
            embed.set_thumbnail(url=row["icon_url"])  # Large image

        if autocorrect_to:
            embed.set_footer(text=f"Autocorrected to {autocorrect_to}")

        view = BuyItemView(interaction.user.id, row, price, have_qty)

        if files:
            sent_msg = await interaction.followup.send(
                embed=embed, view=view, files=files, ephemeral=True
            )
        else:
            sent_msg = await interaction.followup.send(
                embed=embed, view=view, ephemeral=True
            )

        # Let the Buy view edit this same message after purchase
        view.bound_message = sent_msg
    finally:
        try:
            await conn.close()
        except Exception:
            pass
# ---------- /items (catalog browser with pagination) ----------
from discord import ui, Interaction, Embed, SelectOption
ITEMS_PER_PAGE = 15  # keep/tweak

async def _items_catalog_page(page: int, per_page: int = ITEMS_PER_PAGE):
    # Prefer in-memory cache if available (fast, no DB round-trip)
    if db_cache:
        cached_items = db_cache.get_cached_items_table()
        if cached_items:
            items = list(cached_items)
            items.sort(
                key=lambda r: (
                    (r.get("name") is None),
                    (r.get("name") or "").lower(),
                    str(r.get("id") or "").lower(),
                )
            )
            total = len(items)
            max_pages = max(1, (total + per_page - 1) // per_page)
            page = max(1, min(page, max_pages))
            offset = (page - 1) * per_page
            rows = items[offset:offset + per_page]
            return rows, max_pages, total

    # Fallback to DB (cloud)
    async with db.session() as conn:
        cur = await conn.execute("SELECT COUNT(*) AS c FROM items")
        row = await cur.fetchone(); await cur.close()
        total = int(row["c"] or 0)
        if total == 0:
            return [], 1, 0

        max_pages = max(1, (total + per_page - 1) // per_page)
        page = max(1, min(page, max_pages))
        offset = (page - 1) * per_page

        cur = await conn.execute("""
            SELECT id, name, emoji, icon_url, price, sell_price, category, description
            FROM items
            ORDER BY (name IS NULL), name COLLATE NOCASE ASC, id COLLATE NOCASE ASC
            LIMIT ? OFFSET ?
        """, (per_page, offset))
        rows = [dict(r) if hasattr(r, "keys") else {
            "id": r[0],
            "name": r[1],
            "emoji": r[2],
            "icon_url": r[3],
            "price": r[4],
            "sell_price": r[5],
            "category": r[6],
            "description": r[7],
        } for r in await cur.fetchall()]
        await cur.close()
        return rows, max_pages, total

def _fmt_item_row(r: dict) -> str:
    name = r.get("name") or r["id"]
    emj  = (r.get("emoji") or "").strip()
    return (f"{emj} **{name}** `({r['id']})`") if emj else (f"**{name}** `({r['id']})`")

def _build_items_embed(page: int, max_pages: int, total: int, rows: list[dict]) -> Embed:
    e = Embed(title=f"üì¶ Items ‚Äî Page {page}/{max_pages}")
    e.description = "_No items found._" if not rows else "\n".join(_fmt_item_row(r) for r in rows)
    e.set_footer(text=f"{total} total ‚Ä¢ Use /item <name> to view details")
    return e

class JumpModal(ui.Modal, title="Jump to page"):
    def __init__(self, on_submit_cb):
        super().__init__()
        self.on_submit_cb = on_submit_cb
        self.page_input = ui.TextInput(label="Page number", placeholder="e.g. 42", required=True, max_length=6)
        self.add_item(self.page_input)

    async def on_submit(self, interaction: Interaction):
        try:
            n = int(str(self.page_input.value).strip())
        except Exception:
            return await interaction.response.send_message("Please enter a valid number.", ephemeral=True)
        await self.on_submit_cb(interaction, n)

class ItemsView(ui.View):
    def __init__(self, page: int, max_pages: int):
        super().__init__(timeout=120)
        self.page = page
        self.max_pages = max_pages

        # Prev / Next
        self.prev_btn = ui.Button(label="Prev", style=discord.ButtonStyle.secondary, disabled=(page <= 1))
        self.next_btn = ui.Button(label="Next", style=discord.ButtonStyle.secondary, disabled=(page >= max_pages))
        self.prev_btn.callback = self.on_prev
        self.next_btn.callback = self.on_next
        self.add_item(self.prev_btn)
        self.add_item(self.next_btn)

        # If there are at most 25 pages, show a select; otherwise show a Jump modal button.
        if max_pages <= 25:
            options = [SelectOption(label=f"Page {i}", value=str(i), default=(i == page))
                       for i in range(1, max_pages + 1)]
            self.page_select = ui.Select(placeholder="Jump to‚Ä¶", options=options, min_values=1, max_values=1)
            self.page_select.callback = self.on_jump_select
            self.add_item(self.page_select)
            self.jump_btn = None
        else:
            self.page_select = None
            self.jump_btn = ui.Button(label="Jump", style=discord.ButtonStyle.primary)
            self.jump_btn.callback = self.on_jump_modal
            self.add_item(self.jump_btn)

    async def _reload(self, interaction: Interaction, new_page: int):
        rows, max_pages, total = await _items_catalog_page(new_page)
        self.page = max(1, min(new_page, max_pages))
        self.max_pages = max_pages

        # Update buttons
        self.prev_btn.disabled = (self.page <= 1)
        self.next_btn.disabled = (self.page >= self.max_pages)

        # If we‚Äôre using a select, refresh its options (<=25 pages only)
        if self.page_select is not None:
            self.page_select.options = [
                SelectOption(label=f"Page {i}", value=str(i), default=(i == self.page))
                for i in range(1, self.max_pages + 1)
            ]

        embed = _build_items_embed(self.page, self.max_pages, total, rows)
        await interaction.response.edit_message(embed=embed, view=self)

    # Callbacks
    async def on_prev(self, interaction: Interaction):
        await self._reload(interaction, max(1, self.page - 1))

    async def on_next(self, interaction: Interaction):
        await self._reload(interaction, min(self.max_pages, self.page + 1))

    async def on_jump_select(self, interaction: Interaction):
        choice = int(self.page_select.values[0])
        await self._reload(interaction, choice)

    async def on_jump_modal(self, interaction: Interaction):
        async def go_to(inter: Interaction, n: int):
            n = max(1, min(n, self.max_pages))
            await self._reload(inter, n)
        await interaction.response.send_modal(JumpModal(go_to))

@bot.tree.command(name="items", description="Browse the items catalog with pages.")
@app_commands.describe(page="Start on this page (default 1)")
async def items_cmd(interaction: discord.Interaction, page: int = 1):
    await interaction.response.defer(ephemeral=False)
    rows, max_pages, total = await _items_catalog_page(page)
    page = max(1, min(page, max_pages))
    embed = _build_items_embed(page, max_pages, total, rows)
    view = ItemsView(page, max_pages)
    await interaction.followup.send(embed=embed, view=view, ephemeral=False)
@bot.tree.command(name="list_commands", description="Show the commands I currently have.")
@admin_only()
@app_commands.guild_only()
async def list_commands(interaction: discord.Interaction):
    names = [c.name for c in bot.tree.get_commands()]
    await interaction.response.send_message(
        "Commands: " + (", ".join(names) if names else "(none)"), ephemeral=True
    )

@bot.tree.command(name="fix_dupes", description="Remove guild-registered copies; keep global only.")
@admin_only()
@app_commands.guild_only()
async def fix_dupes(interaction: discord.Interaction):
    guild = interaction.guild
    if guild is None:
        return await interaction.response.send_message("Run this in a server, not DMs.", ephemeral=True)
    bot.tree.clear_commands(guild=guild)
    await bot.tree.sync(guild=guild)
    await interaction.response.send_message(
        f"Cleared guild copies for **{guild.name}**. You should now see one copy of each command.",
        ephemeral=True
    )

# =========================
#  Players & Pokemons
# =========================
@bot.tree.command(name="players", description="List players in a custom format.")
@app_commands.describe(
    page="Page number (starts at 1)",
    resolve_names="Resolve usernames (true = slower; default false)"
)
@admin_only()
@app_commands.guild_only()
async def players(
    interaction: discord.Interaction,
    page: int = 1,
    resolve_names: bool = False
):
    await interaction.response.defer(ephemeral=False)
    if page < 1:
        page = 1
    page_size = 10
    offset = (page - 1) * page_size

    try:
        total = await db.count_users()
        users = await db.list_users(limit=page_size, offset=offset)
    except Exception as e:
        return await interaction.followup.send(f"DB error: {e}", ephemeral=True)

    if not users:
        return await interaction.followup.send(
            f"No users on page {page}. Total users: {total}.",
            ephemeral=True
        )

    lines = []
    for u in users:
        uid = u["user_id"]
        name = "unknown"
        if resolve_names:
            user_obj = interaction.client.get_user(int(uid))
            if user_obj is None:
                try:
                    user_obj = await interaction.client.fetch_user(int(uid))
                except Exception:
                    user_obj = None
            if user_obj:
                name = user_obj.name

        lines.append(
            f'user: "{name}" '
            f'id:"{uid}" '
            f'ip:"N/A" '  # Discord bots cannot access user IPs
            f'starter:"{u["starter"] or ""}" '
            f'coins:{u["coins"]} '
            f'created_at:"{u["created_at"]}"'
        )

    pages = (total + page_size - 1) // page_size
    footer = f"-- page {page}/{max(pages,1)} (total {total})"
    await interaction.followup.send("\n".join(lines) + f"\n{footer}", ephemeral=True)

@bot.tree.command(name="player_pkinventory", description="List a member's pokemons.")
@app_commands.describe(member="Whose pokemons to list", page="Page number (starts at 1)")
@admin_only()
@app_commands.guild_only()
async def pokemons_cmd(interaction: discord.Interaction, member: discord.Member, page: int = 1):
    await interaction.response.defer(ephemeral=False)
    uid = str(member.id)
    page_size = 10
    offset = (max(page, 1) - 1) * page_size

    pkm = await db.list_pokemons(uid, limit=page_size, offset=offset)
    if not pkm:
        return await interaction.followup.send(
            f"No pokemons found for {member.mention} on page {page}.",
            ephemeral=True
        )

    embed = discord.Embed(title=f"{member.display_name}'s Pokemons (page {page})")
    for p in pkm:
        stats = f"Lv{p['level']} | HP:{p['hp']} ATK:{p['atk']} DEF:{p['def']}"
        embed.add_field(name=f"#{p['id']} ‚Äî {p['species']}", value=stats, inline=False)

    await interaction.followup.send(embed=embed, ephemeral=True)
# =========================
#  give pokemon
# =========================


USE_DM_INPUT = False

# ------------- Helpers -------------
import re
import json
import asyncio
import discord
from discord import app_commands
from discord.ext import commands

from lib import db, poke_ingest, stats, legality  # make sure lib/__init__.py exists

# =================== Config ===================
# If True, the bot DMs the admin and collects answers there.
# If False, it prompts ephemerally in the channel and ONLY listens to the invoker there.
USE_DM_INPUT = False

# ------------- Helpers -------------
_IV_KEYS = ["hp","attack","defense","special_attack","special_defense","speed"]
_EV_KEYS = _IV_KEYS

def _parse_yes_no(s: str) -> bool:
    return str(s).strip().lower() in {"y","yes","true","1","shiny","on"}

def _comma_or_slash_list(s: str) -> list[str]:
    parts = re.split(r"[,/]+|\s{2,}", s.strip())
    return [p.strip().lower().replace(" ", "-") for p in parts if p.strip()]

def _parse_six_numbers(s: str, low: int, high: int) -> dict[str, int]:
    s = s.strip()
    if "=" in s:  # key=value style
        kv = dict()
        for m in re.finditer(r"(hp|atk|def|spa|spd|spe|attack|defense|special_attack|special_defense|speed)\s*=\s*(\d+)", s, re.I):
            k = m.group(1).lower()
            k = {"atk":"attack","def":"defense","spa":"special_attack","spd":"special_defense","spe":"speed"}.get(k, k)
            kv[k] = int(m.group(2))
        if set(kv.keys()) != set(_IV_KEYS):
            raise ValueError("Please provide all 6 stats (hp, atk, def, spa, spd, spe).")
        return {k: max(low, min(high, int(v))) for k,v in kv.items()}
    nums = re.split(r"[,/]\s*|\s+", s)
    nums = [n for n in nums if n]
    if len(nums) != 6:
        raise ValueError("Need exactly 6 numbers (hp, atk, def, spa, spd, spe).")
    vals = [max(low, min(high, int(x))) for x in nums]
    return dict(zip(_IV_KEYS, vals))

def _validate_evs(evs: dict[str,int]) -> None:
    if any(v < 0 or v > 252 for v in evs.values()):
        raise ValueError("Each EV must be between 0 and 252.")
    if sum(evs.values()) > 510:
        raise ValueError("Total EVs cannot exceed 510.")

def _get_ev_yield_for_species(species_name: str) -> dict:
    """Return EV yield dict (hp, atk, defn, spa, spd, spe) for a species from cached pokedex. All keys int >= 0."""
    if not species_name or not db_cache:
        return {k: 0 for k in _STAT_KEYS_SHORT}
    entry = db_cache.get_cached_pokedex(species_name) or db_cache.get_cached_pokedex((species_name or "").lower()) or db_cache.get_cached_pokedex((species_name or "").replace(" ", "-"))
    if not entry:
        return {k: 0 for k in _STAT_KEYS_SHORT}
    raw = entry.get("ev_yield")
    if isinstance(raw, str):
        try:
            raw = json.loads(raw) if raw else {}
        except Exception:
            raw = {}
    if not isinstance(raw, dict):
        raw = {}
    normalized = _normalize_stats_keys(raw)
    return {
        "hp": max(0, int(normalized.get("hp", 0) or 0)),
        "atk": max(0, int(normalized.get("atk", 0) or 0)),
        "defn": max(0, int(normalized.get("def", 0) or normalized.get("defn", 0) or 0)),
        "spa": max(0, int(normalized.get("spa", 0) or 0)),
        "spd": max(0, int(normalized.get("spd", 0) or 0)),
        "spe": max(0, int(normalized.get("spe", 0) or 0)),
    }

def _cap_evs(evs_dict: dict) -> dict:
    """Return a new EV dict with each stat capped at 252 and total capped at 510."""
    keys = list(_STAT_KEYS_SHORT)
    evs = {k: max(0, min(252, int(evs_dict.get(k, 0) or 0))) for k in keys}
    total = sum(evs.values())
    while total > 510:
        best_k = max(keys, key=lambda k: evs[k])
        if evs[best_k] <= 0:
            break
        evs[best_k] -= 1
        total -= 1
    return evs

def _maybe_json(v):
    if isinstance(v, str):
        try: return json.loads(v)
        except Exception: return v
    return v
def _json(v, default):
    if isinstance(v, str):
        try: return json.loads(v)
        except Exception: return default
    return default if v is None else v
async def _ask(inter: discord.Interaction, prompt: str, timeout: int = 180) -> str:
    """
    Ask the invoker for input and ONLY accept messages from the same user.
    If USE_DM_INPUT=True, questions go to DM; otherwise ephemeral in the same channel.
    """
    if USE_DM_INPUT:
        dm = inter.user.dm_channel or await inter.user.create_dm()
        await dm.send(f"üìù {prompt}")
        listen_channel_id = dm.id
    else:
        await inter.followup.send(prompt, ephemeral=True)
        listen_channel_id = inter.channel_id

    def check(msg: discord.Message) -> bool:
        return msg.author.id == inter.user.id and msg.channel.id == listen_channel_id and not msg.author.bot

    msg = await inter.client.wait_for("message", check=check, timeout=timeout)
    return msg.content.strip()

async def _resolve_item_id(name: str | None) -> str | None:
    if not name:
        return None
    item_id = await db.find_item_id(name)
    if not item_id:
        try:
            info = await poke_ingest.ensure_item_cached(name)
            item_id = info["id"]
        except Exception:
            item_id = None
    return item_id

async def _send_move_list(inter: discord.Interaction, species_id: int, species_name: str, gen: int = 9):
    """Send all learnable move names (informational only) in chunks, ephemeral/DM."""
    legal = await legality.legal_moves(species_id, gen)
    names = sorted({(m["name"] if isinstance(m, dict) else str(m)).replace("-", " ") for m in legal})
    header = f"üìú **{species_name.title()}** can learn **{len(names)}** moves (Gen {gen}):"
    await inter.followup.send(header, ephemeral=not USE_DM_INPUT)
    # chunk messages to avoid hitting 2000-char limit
    chunk = ""
    for n in names:
        add = (n + ", ")
        if len(chunk) + len(add) > 1900:
            await inter.followup.send(chunk.rstrip(", "), ephemeral=not USE_DM_INPUT)
            chunk = add
        else:
            chunk += add
    if chunk:
        await inter.followup.send(chunk.rstrip(", "), ephemeral=not USE_DM_INPUT)

# --- setters for shiny & pok√©ball on the row (requires columns in DB) ---
EMOJI_GUILD_ID: int = 1148637394162155603  # <-- replace with your emoji server ID

def _norm_key(s: str) -> str:
    return str(s or "").strip().lower().replace("_", "-").replace("  ", " ").replace(" ", "-")

def _candidates(base: str) -> set[str]:
    return {base, base.replace("-", ""), base.replace("-", " "), base.split("-")[0]}

def _titleize(s: str) -> str:
    s = _norm_key(s).replace("-", " ")
    return " ".join(w.capitalize() for w in s.split())

async def _db_item_lookup(key: str | int | None) -> tuple[str | None, str | None]:
    """Return (canonical name, emoji) from items by id or normalized name."""
    from lib import db  # local import to avoid cycles
    conn = None
    try:
        conn = await db.connect()
        if isinstance(key, int) or (isinstance(key, str) and key.isdigit()):
            cur = await conn.execute("SELECT name, emoji FROM items WHERE id=? LIMIT 1", (int(key),))
        else:
            cur = await conn.execute("SELECT name, emoji FROM items WHERE LOWER(name)=? LIMIT 1", (_norm_key(key or ""),))
        row = await cur.fetchone(); await cur.close()
        if row:
            name = row["name"] if isinstance(row, dict) else row[0]
            emoji = (row.get("emoji") if isinstance(row, dict) else (row[1] if len(row) > 1 else None)) or None
            return (str(name) if name is not None else None), (str(emoji) if emoji is not None else None)
    except Exception:
        pass
    finally:
        if conn is not None:
            try:
                await conn.close()
            except Exception:
                pass
    return None, None

def _emoji_by_name_in_guild(guild: discord.Guild | None, name: str) -> str:
    if not guild: return ""
    cand = _candidates(_norm_key(name))
    try:
        for e in guild.emojis:
            if e.name.lower() in cand:
                return str(e)  # <:name:id>
    except Exception:
        pass
    return ""

async def get_emoji_global(
    bot: commands.Bot,
    preferred_guild: discord.Guild | None,
    key: str | int | None,
    *,
    name_from_db: str | None = None,
    emoji_hint: str | None = None,
) -> str:
    """
    Resolve an emoji for item/ball/type/etc:
    - items.emoji in DB (supports <:x:id>, numeric id, name, unicode)
    - current guild by name
    - EMOJI_GUILD_ID by name
    - bot.get_emoji(numeric_id) fallback
    If name_from_db and emoji_hint are provided, skips _db_item_lookup (avoids duplicate lookup).
    """
    if name_from_db is None and emoji_hint is None:
        name_from_db, emoji_hint = await _db_item_lookup(key)

    # If DB already stores a full custom emoji or unicode, use it:
    if emoji_hint:
        em = emoji_hint.strip()
        if em.startswith("<") and em.endswith(">"):
            return em  # already <:name:id>
        if em.isdigit():
            ge = bot.get_emoji(int(em))
            if ge: return str(ge)
        # try by name in current or emoji guild
        em_name = _emoji_by_name_in_guild(preferred_guild, em)
        if em_name: return em_name
        emoji_guild = bot.get_guild(EMOJI_GUILD_ID)
        em_name = _emoji_by_name_in_guild(emoji_guild, em)
        if em_name: return em_name
        # last chance: could be unicode emoji
        if len(em) <= 3:
            return em

    # 2) Try current guild by name (prefer DB name; else provided key)
    prefer_name = name_from_db or (str(key) if key is not None else "")
    em = _emoji_by_name_in_guild(preferred_guild, prefer_name)
    if em: return em

    # 3) Try private emoji guild by name
    emoji_guild = bot.get_guild(EMOJI_GUILD_ID)
    em = _emoji_by_name_in_guild(emoji_guild, prefer_name)
    if em: return em

    # 4) If key is numeric id-like, try global cache
    try:
        if isinstance(key, int) or (isinstance(key, str) and key.isdigit()):
            ge = bot.get_emoji(int(key))
            if ge: return str(ge)
    except Exception:
        pass

    return ""  # nothing found

async def render_label_global(bot: commands.Bot, preferred_guild: discord.Guild | None, key: str | int | None) -> str:
    name_from_db, emoji_hint = await _db_item_lookup(key)
    label = _titleize(name_from_db or str(key or ""))
    emoji = await get_emoji_global(bot, preferred_guild, key, name_from_db=name_from_db, emoji_hint=emoji_hint)
    return f"{emoji} {label}" if emoji else label
def _roll_gender_from_ratio(gender_ratio: dict) -> str:
    """Return 'male' | 'female' | 'genderless' based on the Pok√©dex ratio."""
    if not isinstance(gender_ratio, dict):
        return "male"
    if gender_ratio.get("genderless"):
        return "genderless"
    m = float(gender_ratio.get("male", 0) or 0.0)
    f = float(gender_ratio.get("female", 0) or 0.0)
    total = m + f
    if total <= 0:
        return "male"
    return "male" if (random.random() * total) < m else "female"

async def _get_base_friendship(species_name: str) -> int:
    """Read base friendship from pokedex; fallback to base_happiness ‚Üí 50."""
    species_key = str(species_name or "").strip().lower()
    if db_cache and species_key:
        cache_keys = {
            species_key,
            species_key.replace(" ", "-"),
            species_key.replace("-", " "),
            species_key.replace("_", "-"),
            species_key.replace("-", "_"),
        }
        for ck in cache_keys:
            entry = db_cache.get_cached_pokedex(ck)
            if not entry:
                continue
            bf = entry.get("base_friendship")
            if bf is None:
                bf = entry.get("base_happiness")
            try:
                return int(bf) if bf is not None else 50
            except Exception:
                return 50

    try:
        conn = await db.connect()
    except (asyncio.TimeoutError, TimeoutError):
        return 50
    except Exception:
        return 50
    try:
        row = await _safe_optional_fetchone(
            conn,
            "SELECT base_friendship, base_happiness FROM pokedex WHERE LOWER(name)=LOWER(?)",
            (species_key,),
            tables=("pokedex",),
        )
        if not row:
            return 50
        bf = row["base_friendship"]
        if bf is None:
            bf = row["base_happiness"]
        try:
            return int(bf) if bf is not None else 50
        except Exception:
            return 50
    finally:
        try:
            await conn.close()
        except Exception:
            pass


def _normalize_ball_item_id(ball_name: Optional[str]) -> str:
    """Normalize a Pok√© Ball identifier to canonical item_id style (snake_case)."""
    raw = str(ball_name or "").strip().lower()
    if not raw:
        return "poke_ball"
    norm = re.sub(r"[\s\-]+", "_", raw)
    norm = re.sub(r"[^a-z0-9_]", "", norm)
    aliases = {
        "pokeball": "poke_ball",
        "pok_ball": "poke_ball",
        "poke_ball": "poke_ball",
        "greatball": "great_ball",
        "ultraball": "ultra_ball",
        "masterball": "master_ball",
        "safariball": "safari_ball",
        "repeatball": "repeat_ball",
        "timerball": "timer_ball",
        "quickball": "quick_ball",
        "duskball": "dusk_ball",
        "netball": "net_ball",
        "nestball": "nest_ball",
        "heavyball": "heavy_ball",
        "loveball": "love_ball",
        "levelball": "level_ball",
        "lureball": "lure_ball",
        "moonball": "moon_ball",
        "fastball": "fast_ball",
        "friendball": "friend_ball",
        "friendshipball": "friend_ball",
        "friendship_ball": "friend_ball",
        "healball": "heal_ball",
        "luxuryball": "luxury_ball",
        "premierball": "premier_ball",
        "beastball": "beast_ball",
        "diveball": "dive_ball",
        "cherishball": "cherish_ball",
        "sportball": "sport_ball",
        "dreamball": "dream_ball",
        "parkball": "park_ball",
    }
    return aliases.get(norm, norm)


def _is_friend_ball(ball_item_id: Optional[str]) -> bool:
    return _normalize_ball_item_id(ball_item_id) == "friend_ball"


def _is_heal_ball(ball_item_id: Optional[str]) -> bool:
    return _normalize_ball_item_id(ball_item_id) == "heal_ball"


def _is_luxury_ball(ball_item_id: Optional[str]) -> bool:
    return _normalize_ball_item_id(ball_item_id) == "luxury_ball"


def _caught_friendship_for_ball(base_friendship: int, ball_item_id: Optional[str]) -> int:
    """Apply on-catch friendship behavior from the catch ball."""
    value = max(0, min(255, int(base_friendship or 0)))
    if _is_friend_ball(ball_item_id):
        # Friend Ball starts at 200 friendship.
        value = max(value, 200)
    return value


def _caught_hp_for_ball(mon: "Mon", hp_max: int, ball_item_id: Optional[str]) -> int:
    """Apply on-catch HP behavior from the catch ball."""
    if _is_heal_ball(ball_item_id):
        return max(1, int(hp_max or 1))
    try:
        cur = int(getattr(mon, "hp", hp_max) or hp_max)
    except Exception:
        cur = int(hp_max or 1)
    return max(1, min(int(hp_max or 1), cur))


async def _get_pokemon_ball(owner_id: str, mon_id: int) -> Optional[str]:
    """Read pokeball column for a Pok√©mon (fails soft if column is unavailable)."""
    conn = await db.connect()
    try:
        try:
            cur = await conn.execute(
                "SELECT pokeball FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                (owner_id, int(mon_id)),
            )
        except Exception as e:
            if "pokeball" in str(e).lower() and (
                "no such column" in str(e).lower() or "does not exist" in str(e).lower()
            ):
                return None
            raise
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return None
        return row["pokeball"] if hasattr(row, "keys") else row[0]
    finally:
        try:
            await conn.close()
        except Exception:
            pass


def _friendship_delta_with_ball_bonus(delta: int, ball_item_id: Optional[str]) -> int:
    """Luxury Ball gives +1 friendship on positive friendship gains."""
    d = int(delta or 0)
    if d > 0 and _is_luxury_ball(ball_item_id):
        return d + 1
    return d


async def _set_friendship(owner_id: str, mon_id: int, value: int) -> None:
    """Persist friendship on pokemons(friendship) for (owner_id, id)."""
    conn = await db.connect()
    try:
        await conn.execute(
            "UPDATE pokemons SET friendship=? WHERE owner_id=? AND id=?",
            (int(value), owner_id, mon_id)
        )
        await conn.commit()
        db.invalidate_pokemons_cache(owner_id)
    finally:
        try:
            await conn.close()
        except Exception:
            pass
async def _give_item(owner_id: str, item_id: str, qty: int) -> None:
    """
    Upsert into user_items using your schema:
      owner_id TEXT, item_id TEXT, qty INTEGER
    """
    qty = int(qty)
    conn = await db.connect()
    try:
        # Try an UPSERT if (owner_id, item_id) is UNIQUE/PK
        try:
            await conn.execute("""
                INSERT INTO user_items (owner_id, item_id, qty)
                VALUES (?, ?, ?)
                ON CONFLICT(owner_id, item_id)
                DO UPDATE SET qty = user_items.qty + excluded.qty
            """, (owner_id, item_id, qty))
            await conn.commit()
            return
        except Exception:
            # Fallback if there is no UNIQUE (owner_id, item_id) constraint
            pass

        # Manual upsert
        cur = await conn.execute(
            "SELECT qty FROM user_items WHERE owner_id=? AND item_id=?",
            (owner_id, item_id)
        )
        row = await cur.fetchone()
        await cur.close()
        if row:
            await conn.execute(
                "UPDATE user_items SET qty = qty + ? WHERE owner_id=? AND item_id=?",
                (qty, owner_id, item_id)
            )
        else:
            await conn.execute(
                "INSERT INTO user_items (owner_id, item_id, qty) VALUES (?, ?, ?)",
                (owner_id, item_id, qty)
            )
        await conn.commit()
        db.invalidate_bag_cache(owner_id)
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _user_max_unlocked_gen(user_id: str) -> int:
    """Return the user's highest unlocked generation from user_rulesets.max_unlocked_gen (default 1)."""
    conn = await db.connect()
    try:
        cur = await conn.execute("SELECT max_unlocked_gen FROM user_rulesets WHERE user_id=?", (user_id,))
        row = await cur.fetchone(); await cur.close()
        if row and row["max_unlocked_gen"]:
            return int(row["max_unlocked_gen"])
        return 1
    except Exception:
        return 1
    finally:
        try:
            await conn.close()
        except Exception:
            pass
async def shiny_roll(default_denominator: int = 4096) -> bool:
    """
    Reusable shiny helper for routes, gifts, starters, etc.
    If you have a trigger named 'pokemons_shiny_auto' that uses 'RANDOM() % N = 0',
    we read N to match the DB odds; otherwise default to 1/4096 (or override here).
    """
    return random.randrange(max(1, int(default_denominator))) == 0


def normalize_base_stats(src: dict | None) -> dict:
    """
    Accepts {'hp','atk','def','spa','spd','spe'} OR long keys and returns long keys
    required by your generator: attack/defense/special_attack/special_defense/speed.
    """
    src = dict(src or {})
    return {
        "hp":              int(src.get("hp",                src.get("HP", 0))),
        "attack":          int(src.get("attack",            src.get("atk", 0))),
        "defense":         int(src.get("defense",           src.get("def", 0))),
        "special_attack":  int(src.get("special_attack",    src.get("spa", 0))),
        "special_defense": int(src.get("special_defense",   src.get("spd", 0))),
        "speed":           int(src.get("speed",             src.get("spe", 0))),
    }


def parse_abilities(abilities_raw) -> tuple[list[str], list[str]]:
    """
    Normalizes ability data from your DB (strings, dicts, or JSON string) into:
        (regular_ability_names, hidden_ability_names)
    Accepts formats like:
      - ["overgrow","chlorophyll"]
      - [{"name":"overgrow"},{"name":"chlorophyll","is_hidden":true}]
      - [{"ability":{"name":"overgrow"},"slot":1},{"ability":{"name":"chlorophyll"},"slot":3}]
    """
    # if JSON text, parse first
    if isinstance(abilities_raw, str):
        try:
            abilities_raw = json.loads(abilities_raw)
        except Exception:
            abilities_raw = []
    regs, hides = [], []
    for a in (abilities_raw or []):
        if isinstance(a, str):
            regs.append(a)
            continue
        if isinstance(a, dict):
            name = a.get("name") or (a.get("ability") or {}).get("name") or ""
            is_hidden = bool(a.get("is_hidden") or a.get("hidden") or (a.get("slot") == 3))
            if name:
                (hides if is_hidden else regs).append(name)
    # de-dup while preserving order
    def _dedup(seq: list[str]) -> list[str]:
        seen = set(); out = []
        for s in seq:
            k = s.lower()
            if k not in seen:
                seen.add(k); out.append(s)
        return out
    return _dedup(regs), _dedup(hides)


def _norm_ability_id(value: Any) -> str:
    return str(value or "").strip().lower().replace("_", "-").replace(" ", "-")


def _ability_set_from_entry(entry: Optional[Mapping[str, Any]]) -> tuple[list[str], list[str], set[str]]:
    regs_raw, hides_raw = parse_abilities((entry or {}).get("abilities") or [])
    regs = [_norm_ability_id(a) for a in regs_raw if _norm_ability_id(a)]
    hides = [_norm_ability_id(a) for a in hides_raw if _norm_ability_id(a)]
    valid = set(regs) | set(hides)
    return regs, hides, valid
def roll_hidden_ability(abilities_raw, ha_denominator: int = 10) -> tuple[str, bool]:
    """
    Returns (ability_name, is_hidden).

    - 1/N chance (N = ha_denominator) to get a Hidden Ability.
    - If HA roll fails, choose uniformly among ALL regular abilities.
    - If no regulars exist but HAs do, pick a random HA.
    - If nothing is present, return ("", False).
    """
    regs, hides = parse_abilities(abilities_raw)  # uses the helper you already added

    # nothing stored
    if not regs and not hides:
        return ("", False)

    # try HA roll if any hidden exists
    if hides and random.randrange(max(1, int(ha_denominator))) == 0:
        return (random.choice(hides), True)

    # fallback: pick a regular at random if available
    if regs:
        return (random.choice(regs), False)

    # last resort: only hidden exists
    return (random.choice(hides), True)
# --- DB field setters (use your schema names) ---
async def _set_shiny(owner_id: str, mon_id: int, shiny: bool) -> None:
    conn = await db.connect()
    try:
        await conn.execute(
            "UPDATE pokemons SET shiny=? WHERE owner_id=? AND id=?",
            (1 if shiny else 0, owner_id, mon_id),
        )
        await conn.commit()
        db.invalidate_pokemons_cache(owner_id)
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _set_pokeball(owner_id: str, mon_id: int, pokeball: str | None) -> None:
    conn = await db.connect()
    try:
        await conn.execute(
            "UPDATE pokemons SET pokeball=? WHERE owner_id=? AND id=?",
            (pokeball, owner_id, mon_id),
        )
        await conn.commit()
        db.invalidate_pokemons_cache(owner_id)
    finally:
        try:
            await conn.close()
        except Exception:
            pass


# ------------- Command -------------
import lib.stats as stats  # <‚Äî you call stats.* below; make sure this import exists

# === Confirm View for /givepokemon ===
# === Form Selection View for /givepokemon ===
class GivePokemonFormView(discord.ui.View):
    """Button-based form selection for /givepokemon"""
    def __init__(self, cog, interaction: Interaction, species_id: int, species_name: str, 
                 available_forms: List[dict], target: discord.User, gen: int, **kwargs):
        super().__init__(timeout=300)
        self.cog = cog
        self.original_interaction = interaction
        self.species_id = species_id
        self.species_name = species_name
        self.available_forms = available_forms
        self.target = target
        self.gen = gen
        self.kwargs = kwargs
        
        # Add buttons for each form
        for i, form_data in enumerate(available_forms[:25]):
            button = discord.ui.Button(
                label=form_data['display_name'],
                style=discord.ButtonStyle.primary,
                row=i // 5,
                custom_id=f"giveform_{form_data['form_key'] or 'base'}"
            )
            button.callback = self._make_callback(form_data['form_key'], form_data['display_name'])
            self.add_item(button)
    
    def _make_callback(self, form_key: Optional[str], form_display: str):
        async def callback(interaction: Interaction):
            await interaction.response.defer(ephemeral=True)
            
            try:
                # Load species data to build proper payload
                sp = await ensure_species_and_learnsets(self.species_name)
                base_stats = sp.get("stats") or {}
                if isinstance(base_stats, str):
                    try: base_stats = json.loads(base_stats)
                    except Exception: base_stats = {}
                base_stats = self.cog._normalize_stats_long(base_stats)
                
                # Form stats are stored in base species stats already, no need to override
                
                abilities = sp.get("abilities") or []
                if isinstance(abilities, str):
                    try: abilities = json.loads(abilities)
                    except Exception: abilities = []
                
                # Use command parameters if provided, otherwise use defaults
                conn = await db.connect()
                try:
                    # If a form is selected, fetch form-specific abilities
                    if form_key:
                        try:
                            form_data_row = await _safe_pokedex_forms_fetchone(
                                conn,
                                "SELECT abilities FROM pokedex_forms WHERE species_id = ? AND form_key = ?",
                                (self.species_id, form_key),
                            )

                            if form_data_row and form_data_row.get('abilities'):
                                # Override base species abilities with form abilities
                                form_abilities = form_data_row['abilities']
                                if isinstance(form_abilities, str):
                                    try:
                                        form_abilities = json.loads(form_abilities)
                                    except Exception:
                                        form_abilities = []
                                if form_abilities:
                                    abilities = form_abilities
                        except Exception:
                            # If form lookup fails, fall back to base abilities
                            pass
                
                    gender_ratio = sp.get("gender_ratio") or {}
                    if isinstance(gender_ratio, str):
                        try: gender_ratio = json.loads(gender_ratio)
                        except Exception: gender_ratio = {}
                
                    # Level
                    lvl = max(1, min(100, int(self.kwargs.get('level')) if self.kwargs.get('level') else 100))
                
                    # Nature
                    nat = self.kwargs.get('nature')
                    if nat:
                        nat = nat.strip().lower()
                    else:
                        nat = stats.pick_random_nature().lower()
                
                    # Ability - now uses form abilities if form was selected
                    ab = await self.cog._species_autocorrect_ability(abilities, self.kwargs.get('ability'))
                
                    # Gender
                    chosen_gender, gender_note = self.cog._roll_gender_legal(gender_ratio, self.kwargs.get('gender'))
                
                    # Shiny - use explicit parameter if provided, otherwise random chance
                    shiny_param = self.kwargs.get('shiny')
                    if shiny_param is not None:
                        shiny_val = bool(shiny_param)
                    else:
                        shiny_val = (random.random() < (1/4096))
                
                    # Ball
                    pokeball = self.cog._norm_name(self.kwargs.get('ball') or "poke-ball")
                
                    # Item
                    item_id = None
                    if self.kwargs.get('item'):
                        matched_item, confidence, suggestions = await FuzzyMatcher.fuzzy_item(conn, self.kwargs['item'])
                        if matched_item and confidence >= 0.70:
                            item_id = matched_item
                
                    # Moves - use provided moves or get random legal ones
                    if self.kwargs.get('moves'):
                        wanted_moves = self.cog._parse_moves(self.kwargs['moves'])
                        default_moves = await self.cog._choose_default_moves(self.species_id, lvl, self.gen)
                        moves_list, move_notes = await self.cog._validate_moves(self.species_id, self.gen, wanted_moves, default_moves)
                    else:
                        # Get random legal moves (fetch NAMES not IDs)
                        # Subquery: PostgreSQL requires ORDER BY expressions to appear in SELECT when using DISTINCT,
                        # so we get distinct names first then order by random in the outer query.
                        cur = await conn.execute("""
                            SELECT name FROM (
                                SELECT DISTINCT m.name AS name
                                FROM moves m
                                JOIN learnsets l ON m.id = l.move_id
                                WHERE l.species_id = ? AND l.generation <= ?
                            ) sub
                            ORDER BY RANDOM()
                            LIMIT 4
                        """, (self.species_id, self.gen))
                        random_moves = await cur.fetchall()
                        await cur.close()
                        moves_list = [self.cog._norm_name(row['name']) for row in random_moves]

                        # IVs and EVs
                        ivs_dict = self.cog._parse_six_csv(self.kwargs.get('ivs'), kind="ivs")
                        evs_dict = self.cog._parse_six_csv(self.kwargs.get('evs'), kind="evs")
                finally:
                    try:
                        await conn.close()
                    except Exception:
                        pass
                
                species_types = _extract_species_types(sp)
                tera_param = self.kwargs.get('tera_type')
                explicit_tera = None
                tera_type_source = "auto"
                tera_notes: list[str] = []
                if tera_param:
                    explicit_tera = _normalize_type_id(tera_param)
                    if explicit_tera not in VALID_TERA_TYPES:
                        return await interaction.followup.send(
                            f"‚ùå Invalid Tera Type `{tera_param}`.",
                            ephemeral=True
                        )
                    tera_type_source = "manual"
                    if explicit_tera not in species_types:
                        tera_notes.append(f"Tera Type `{explicit_tera.title()}` is not in this species' native pool.")
                resolved_tera = explicit_tera or _roll_default_tera_type(species_types)
                if tera_type_source == "auto" and resolved_tera is None:
                    tera_notes.append("Tera Type could not be rolled; species has no type data.")
                
                # Calculate friendship (same logic as main command)
                base_friendship = await _get_base_friendship(self.species_name)
                # For Missing n0, if base_friendship is None/0, default to 50
                if self.species_name.lower() == "missing n0" and (base_friendship is None or base_friendship == 0):
                    base_friendship = 50
                friendship_param = self.kwargs.get('friendship')
                if friendship_param is None:
                    starting_friendship = base_friendship
                else:
                    requested = int(friendship_param)
                    starting_friendship = max(0, min(255, requested))

                # Build full payload for OLD confirmation view
                target_id = str(self.target.id)
                payload = {
                    "target_id": target_id,
                    "target_mention": self.target.mention,
                    "target_display": getattr(self.target, "display_name", None),
                    "target_tag": f"{self.target.name}#{getattr(self.target, 'discriminator', '0')}" if hasattr(self.target, "discriminator") else self.target.name,
                    "species_id": self.species_id,
                    "species_name": self.species_name,  # Base species name (e.g., "rotom")
                    "form_display_name": form_display,  # Display name for preview (e.g., "Rotom (Heat)")
                    "base_stats": base_stats,
                    "gen": self.gen,
                    "level": lvl,  # Use resolved level
                    "nature": nat,
                    "ability": ab,
                    "gender": chosen_gender,
                    "gender_note": gender_note,
                    "shiny": shiny_val,  # Use resolved shiny (respects command param)
                    "pokeball": pokeball,  # Use resolved ball
                    "item_id": item_id,  # Use resolved item
                    "moves": moves_list,
                    "autoslot": bool(self.kwargs.get('autoslot', True)),  # Use command param or default True
                    "ivs": ivs_dict,  # Use resolved IVs
                    "evs": evs_dict,  # Use resolved EVs
                    "form": form_key,
                    "tera_type": resolved_tera,
                    "tera_type_source": tera_type_source,
                    "species_types": species_types,
                    "friendship": starting_friendship,
                    "base_friendship": base_friendship,
                }
                
                # Get sprite - pass form_key so it looks in the right folder (e.g., "kyurem-white")
                sprite_file = self.cog._pick_sprite_file(self.species_name, chosen_gender, shiny_val, form_key)
                
                # Use OLD confirmation view (same as non-form Pokemon)
                view = AdminGivePokemon._ConfirmView(payload)
                emb = await self.cog._preview_embed(interaction, payload, tera_notes, sprite_file)
                
                if sprite_file:
                    msg = await interaction.followup.send(
                        embed=emb, 
                        view=view, 
                        files=[sprite_file], 
                        ephemeral=True,
                        allowed_mentions=discord.AllowedMentions(users=True)
                    )
                else:
                    msg = await interaction.followup.send(
                        embed=emb, 
                        view=view, 
                        ephemeral=True,
                        allowed_mentions=discord.AllowedMentions(users=True)
                    )
                view.message = msg
                
            except Exception as e:
                await interaction.followup.send(
                    f"‚ùå Error loading form data: {e}",
                    ephemeral=True
                )
        
        return callback

class AdminGivePokemon(commands.Cog):
    """Give a Pok√©mon with quick options, preview (with sprite), legality checks, and autocomplete."""

    # List of Pokemon that can Gigantamax (by default, not all individuals have the factor)
    GIGANTAMAX_CAPABLE = {
        "venusaur", "charizard", "blastoise", "butterfree", "pikachu", "meowth", "machamp",
        "gengar", "kingler", "lapras", "eevee", "snorlax", "garbodor", "melmetal", "rillaboom",
        "cinderace", "inteleon", "corviknight", "orbeetle", "drednaw", "coalossal", "flapple",
        "appletun", "sandaconda", "toxtricity", "centiskorch", "hatterene", "grimmsnarl",
        "alcremie", "copperajah", "duraludon", "urshifu", "toxtricity-low-key", "urshifu-rapid-strike"
    }

    @classmethod
    def can_gigantamax(cls, species_name: str) -> bool:
        """Check if a Pokemon species can Gigantamax."""
        normalized = cls._norm_name(species_name)
        return normalized in cls.GIGANTAMAX_CAPABLE

    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.sprites_base = Path(__file__).resolve().parent / "pvp" / "_common" / "sprites"

    # ---------- small utils ----------
    @staticmethod
    def _norm_name(s: str) -> str:
        return s.strip().lower().replace(" ", "-")

    @staticmethod
    def _norm_gender(s: Optional[str]) -> Optional[str]:
        if not s:
            return None
        s = s.strip().lower()
        if s in {"m", "male", "‚ôÇÔ∏è"}: return "male"
        if s in {"f", "female", "‚ôÄÔ∏è"}: return "female"
        if s in {"n", "none", "genderless", "gender-less"}: return "genderless"
        return None

    @staticmethod
    def _fmt6(d: dict | None) -> str:
        d = d or {}
        return (
            f"HP {int(d.get('hp',0))} | Atk {int(d.get('attack',0))} | Def {int(d.get('defense',0))}\n"
            f"SpA {int(d.get('special_attack',0))} | SpD {int(d.get('special_defense',0))} | Spe {int(d.get('speed',0))}"
        )

    @staticmethod
    def _normalize_stats_long(stats_like: dict | None) -> dict:
        """
        Convert DB stats into long keys expected by calc_all_stats:
        hp, attack, defense, special_attack, special_defense, speed
        Supports {atk, def, spa, spd, spe} and hyphen keys.
        """
        d = {k.lower().replace("-", "_"): v for k, v in (stats_like or {}).items()}
        return {
            "hp": d.get("hp", 0),
            "attack": d.get("attack", d.get("atk", 0)),
            "defense": d.get("defense", d.get("def", 0)),
            "special_attack": d.get("special_attack", d.get("spa", d.get("specialattack", 0))),
            "special_defense": d.get("special_defense", d.get("spd", d.get("specialdefense", 0))),
            "speed": d.get("speed", d.get("spe", 0)),
        }

    @staticmethod
    def _parse_six_csv(
        csv_text: Optional[str],
        *,
        kind: Literal["ivs", "evs"],
        default_ivs: tuple[int, int, int, int, int, int] = (31,31,31,31,31,31),
        default_evs: tuple[int, int, int, int, int, int] = (0,0,0,0,0,0),
    ) -> dict:
        if kind == "ivs":
            defaults = default_ivs
            lo, hi = 0, 31
        else:
            defaults = default_evs
            lo, hi = 0, 252

        vals = list(defaults)
        if csv_text:
            parts = [p.strip() for p in csv_text.split(",")]
            for i in range(min(6, len(parts))):
                try:
                    n = int(parts[i])
                except Exception:
                    n = defaults[i]
                n = max(lo, min(hi, n))
                vals[i] = n

        d = {
            "hp": vals[0],
            "attack": vals[1],
            "defense": vals[2],
            "special_attack": vals[3],
            "special_defense": vals[4],
            "speed": vals[5],
        }

        if kind == "evs":
            total = sum(vals)
            if total > 510 and total > 0:
                scale = 510 / total
                vals = [max(0, min(252, math.floor(v * scale))) for v in vals]
                d.update({
                    "hp": vals[0], "attack": vals[1], "defense": vals[2],
                    "special_attack": vals[3], "special_defense": vals[4], "speed": vals[5]
                })
        return d

    @classmethod
    def _roll_gender_legal(cls, gender_ratio: dict, requested: Optional[str]) -> tuple[str, Optional[str]]:
        if isinstance(gender_ratio, dict) and gender_ratio.get("genderless") is True:
            chosen = "genderless"
            note = None
            req = cls._norm_gender(requested)
            if req and req != "genderless":
                note = "Species is genderless; forced to genderless."
            return chosen, note

        male_pct = float((gender_ratio or {}).get("male", 0.0) or 0.0)
        fem_pct  = float((gender_ratio or {}).get("female", 0.0) or 0.0)

        if male_pct > 0 and fem_pct == 0:
            allowed = {"male"}
        elif fem_pct > 0 and male_pct == 0:
            allowed = {"female"}
        elif male_pct == 0 and fem_pct == 0:
            chosen = "genderless"
            note = None
            req = cls._norm_gender(requested)
            if req and req != "genderless":
                note = "Species is genderless; forced to genderless."
            return chosen, note
        else:
            allowed = {"male", "female"}

        req = cls._norm_gender(requested)
        if req in allowed:
            return req, None

        if allowed == {"male", "female"}:
            total = max(1.0, male_pct + fem_pct)
            roll = random.random() * total
            chosen = "male" if roll < male_pct else "female"
            note = None
            if req and req != chosen:
                note = f"Requested {req}, but species ratio applied; rolled {chosen}."
            return chosen, note

        chosen = next(iter(allowed))
        note = None
        if req and req != chosen:
            note = f"Species is {chosen}-only; forced to {chosen}."
        return chosen, note

    @staticmethod
    async def _species_autocorrect_ability(abilities_raw: Sequence, requested: Optional[str]) -> str:
        pool = [(a if isinstance(a, dict) else {"name": a, "is_hidden": False}) for a in (abilities_raw or [])]
        names = {AdminGivePokemon._norm_name(a.get("name") or "") for a in pool}
        if requested:
            rq = AdminGivePokemon._norm_name(requested)
            if rq in names:
                return rq
        # Prefer non-hidden if helper is missing
        try:
            pick = stats.choose_ability(pool)
        except Exception:
            non_hidden = [AdminGivePokemon._norm_name(a["name"]) for a in pool if not a.get("is_hidden")]
            pick = non_hidden[0] if non_hidden else (AdminGivePokemon._norm_name(pool[0]["name"]) if pool else "")
        return AdminGivePokemon._norm_name(pick or "")

    @staticmethod
    def _parse_moves(s: Optional[str]) -> list[str]:
        if not s: return []
        parts = re.split(r"[,/]+|\s{2,}", s.strip())
        return [AdminGivePokemon._norm_name(p) for p in parts if p.strip()][:4]

    @staticmethod
    async def _choose_default_moves(species_id: int, level: int, generation: int) -> list[str]:
        conn = await db.connect()
        try:
            cur = await conn.execute(
                """
                SELECT m.name, COALESCE(l.level_learned, 0) AS lvl
                FROM learnsets l
                JOIN moves m ON m.id = l.move_id
                WHERE l.species_id=? AND l.generation=? AND l.method='level-up'
                      AND COALESCE(l.level_learned,0) <= ?
                ORDER BY lvl DESC, m.name
                LIMIT 60
                """,
                (species_id, generation, level),
            )
            rows = await cur.fetchall()
            await cur.close()
            out, seen = [], set()
            for r in rows:
                nm = AdminGivePokemon._norm_name(r["name"] or "")
                if nm and nm not in seen:
                    seen.add(nm); out.append(nm)
                if len(out) == 4: break
            return out
        finally:
            try:
                await conn.close()
            except Exception:
                pass

    @staticmethod
    async def _validate_moves(species_id: int, gen: int, wanted: list[str], fallbacks: list[str]) -> tuple[list[str], list[str]]:
        """
        Validate move names against the database using fuzzy matching.
        Corrects typos and only accepts moves that exist.
        """
        notes: list[str] = []
        final: list[str] = []
        
        if wanted:
            conn = await db.connect()
            try:
                for mv in wanted:
                    if not mv or not mv.strip():
                        continue
                    
                    # Try to find the move in database using fuzzy matching
                    matched_move, confidence, suggestions = await FuzzyMatcher.fuzzy_move(conn, mv)
                    
                    if matched_move and confidence >= 0.70:
                        # Move found and matched with good confidence
                        normalized = AdminGivePokemon._norm_name(matched_move)
                        if normalized and normalized not in final:
                            final.append(normalized)
                            # Add note if it was corrected (not an exact match)
                            query_norm = FuzzyMatcher.normalize(mv)
                            matched_norm = FuzzyMatcher.normalize(matched_move)
                            if query_norm != matched_norm:
                                notes.append(f"`{mv}` ‚Üí `{matched_move}` (corrected)")
                    else:
                        # Move not found or low confidence
                        sugg_text = f" Did you mean: {', '.join(suggestions[:3])}?" if suggestions else ""
                        notes.append(f"‚ùå Move `{mv}` not found.{sugg_text}")
            finally:
                try:
                    await conn.close()
                except Exception:
                    pass

        # Only use fallbacks if no wanted moves provided or all wanted moves were invalid
        if not final:
            for mv in fallbacks:
                if len(final) >= 4:
                    break
                if mv not in final:
                    final.append(mv)

        return final[:4], notes

    @staticmethod
    def _ball_emoji(guild: Optional[discord.Guild], ball_id: Optional[str]) -> str:
        if not guild or not ball_id:
            return ""
        base = ball_id.lower()
        cand = {base, base.replace("-", ""), base.replace("-", " "), base.split("-")[0]}
        try:
            for e in guild.emojis:
                en = e.name.lower()
                if en in cand:
                    return str(e)
        except Exception:
            pass
        return ""

    def _pick_sprite_file(self, species_name: str, gender: str, shiny: bool, form_key: Optional[str] = None) -> Optional[discord.File]:
        # Use EXACT same logic as pokeinfo's attach_sprite_to_embed
        if form_key:
            # If form_key already contains the species name (e.g., "kyurem-white"), use it as-is
            # Otherwise, prepend species (e.g., species="rotom", form_key="heat" ‚Üí "rotom-heat")
            if form_key.startswith(f"{species_name}-"):
                lookup_species = form_key
            else:
                lookup_species = f"{species_name}-{form_key}"
        else:
            lookup_species = species_name
        
        sp_dir = self.sprites_base / self._norm_name(lookup_species)
        if not sp_dir.is_dir():
            return None

        def exists(name: str) -> Optional[Path]:
            p = sp_dir / name
            return p if p.exists() else None

        cand: List[str] = []
        if gender == "female":
            if shiny:
                cand += [
                    "female-animated-shiny-front.gif",
                    "female-shiny-front.png",
                    "animated-shiny-front.gif",
                    "shiny-front.png",
                    "female-animated-front.gif",
                    "female-front.png",
                    "animated-front.gif",
                    "front.png",
                ]
            else:
                cand += [
                    "female-animated-front.gif",
                    "female-front.png",
                    "animated-front.gif",
                    "front.png",
                ]
        else:
            if shiny:
                cand += ["animated-shiny-front.gif", "shiny-front.png", "animated-front.gif", "front.png"]
            else:
                cand += ["animated-front.gif", "front.png"]

        for fname in cand:
            fp = exists(fname)
            if fp:
                return discord.File(fp, filename=fname)
        return None

    async def _preview_embed(self, inter: Interaction, payload: dict, notes: list[str], sprite_file: Optional[discord.File]) -> Embed:
        title_user = payload.get("target_display") or payload.get("target_tag") or "user"
        # Use form_display_name if available (e.g., "Rotom (Heat)"), otherwise base species_name
        display_name = payload.get("form_display_name") or payload['species_name']
        emb = Embed(
            title=f"Give to {title_user} ‚Äî {display_name} (Lv {payload['level']})" + (" ‚≠ê" if payload.get("shiny") else ""),
            colour=discord.Colour.blurple(),
            description="**Preview** ‚Äî nothing saved yet.",
        )
        emb.add_field(name="User", value=payload["target_mention"], inline=True)
        emb.add_field(name="Gender", value=payload.get("gender", "?").title(), inline=True)
        emb.add_field(name="Nature", value=payload.get("nature", "?").title(), inline=True)
        emb.add_field(name="Ability", value=payload.get("ability", "?").replace("-", " ").title(), inline=True)
        tera_type_value = payload.get("tera_type")
        if tera_type_value:
            tera_label = tera_type_value.replace("-", " ").title()
        else:
            tera_label = "None"
        if payload.get("tera_type_source") == "auto":
            if tera_type_value:
                tera_label += " (auto)"
            else:
                pool = payload.get("species_types") or []
                if pool:
                    pool_str = ", ".join(t.replace("-", " ").title() for t in pool)
                    tera_label = f"Random (pool: {pool_str})"
                else:
                    tera_label = "Random (no species data)"
        emb.add_field(name="Tera Type", value=tera_label, inline=True)

        ball_label = payload.get("pokeball") or "pokeball"
        ball_emoji = self._ball_emoji(inter.guild, ball_label)
        emb.add_field(name="Item", value=(str(payload.get("item_id")) if payload.get("item_id") else "‚Äî"), inline=True)
        emb.add_field(name="Ball", value=f"{ball_emoji} {ball_label}" if ball_emoji else ball_label, inline=True)
        emb.add_field(name="Autoslot", value="Yes" if payload.get("autoslot") else "No", inline=True)

        mv = payload.get("moves") or []
        emb.add_field(name="Moves", value=(", ".join(m.replace("-", " ").title() for m in mv) or "‚Äî"), inline=False)

        emb.add_field(name="IVs", value=self._fmt6(payload.get("ivs")), inline=False)
        emb.add_field(name="EVs", value=self._fmt6(payload.get("evs")), inline=False)
        emb.add_field(name="Friendship", value=str(payload.get("friendship", "‚Äî")), inline=True)

        footer = f"Gen {payload.get('gen')} legality: {'‚úÖ' if not notes else '‚ö†Ô∏è ' + '; '.join(notes)}"
        if payload.get("gender_note"):
            footer += f" | {payload['gender_note']}"
        emb.set_footer(text=footer)

        if sprite_file:
            emb.set_thumbnail(url=f"attachment://{sprite_file.filename}")
        return emb

    class _SlotSelectionView(ui.View):
        """View for selecting which team slot to replace when team is full"""
        def __init__(self, cog, payload: dict, team_mons: list, sprite_file: Optional[discord.File] = None, *, timeout: float = 120.0):
            super().__init__(timeout=timeout)
            self.cog = cog
            self.payload = payload
            self.team_mons = team_mons
            self.sprite_file = sprite_file
            self.message: Optional[discord.Message] = None
            self._handled = False
            
            # Add buttons for each slot (1-6)
            for slot in range(1, 7):
                # Find the Pok√©mon in this slot
                mon_in_slot = next((m for m in team_mons if m['team_slot'] == slot), None)
                if mon_in_slot:
                    label = f"Slot {slot}: {mon_in_slot['species'].title()} Lv{mon_in_slot['level']}"
                    # Truncate if too long
                    if len(label) > 80:
                        label = f"Slot {slot}: {mon_in_slot['species'].title()[:20]}..."
                else:
                    label = f"Slot {slot}: Empty"
                
                button = ui.Button(
                    label=label[:80],  # Discord limit
                    style=discord.ButtonStyle.secondary,
                    row=(slot - 1) // 3,  # 3 buttons per row
                    custom_id=f"slot_{slot}"
                )
                button.callback = self._make_slot_callback(slot)
                self.add_item(button)
            
            # Cancel button
            cancel_btn = ui.Button(
                label="Cancel",
                style=discord.ButtonStyle.danger,
                row=2
            )
            cancel_btn.callback = self._cancel
            self.add_item(cancel_btn)
        
        def _make_slot_callback(self, slot: int):
            async def callback(interaction: Interaction):
                if self._handled:
                    if not interaction.response.is_done():
                        await interaction.response.send_message("Already handled.", ephemeral=True)
                    else:
                        await interaction.followup.send("Already handled.", ephemeral=True)
                    return
                self._handled = True
                if not interaction.response.is_done():
                    await interaction.response.defer(ephemeral=True)
                
                # Update payload with selected slot
                self.payload["selected_slot"] = slot
                self.payload["autoslot"] = False  # Disable autoslot since we're manually selecting
                
                # Remove the old Pok√©mon from team slot (clear its slot)
                target_id = self.payload["target_id"]
                mon_in_slot = next((m for m in self.team_mons if m['team_slot'] == slot), None)
                if mon_in_slot:
                    conn = await db.connect()
                    try:
                        await conn.execute(
                            "UPDATE pokemons SET team_slot=NULL WHERE owner_id=? AND id=?",
                            (target_id, mon_in_slot['id'])
                        )
                        await conn.commit()
                        db.invalidate_pokemons_cache(target_id)
                    except Exception:
                        pass
                    finally:
                        try:
                            await conn.close()
                        except Exception:
                            pass
                
                # Now finalize with the selected slot
                try:
                    await AdminGivePokemon._finalize(interaction, self.payload)
                except Exception as e:
                    await interaction.followup.send(f"‚ùå Failed to give Pok√©mon: {e}", ephemeral=True)
                
                # Disable all buttons
                if self.message:
                    try:
                        for child in self.children:
                            if isinstance(child, ui.Button):
                                child.disabled = True
                        await self.message.edit(view=self)
                    except:
                        pass
            return callback
        
        async def _cancel(self, interaction: Interaction):
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùé Canceled. Nothing saved.", ephemeral=True)
            else:
                await interaction.followup.send("‚ùé Canceled. Nothing saved.", ephemeral=True)
            if self.message:
                try:
                    for child in self.children:
                        if isinstance(child, ui.Button):
                            child.disabled = True
                    await self.message.edit(view=self)
                except:
                    pass
        
        async def on_timeout(self):
            if self.message:
                try:
                    await self.message.edit(content="‚è≥ Slot selection expired.", view=None)
                except:
                    pass
    
    class _ConfirmView(ui.View):
        def __init__(self, payload: dict, *, timeout: float = 90.0):
            super().__init__(timeout=timeout)
            self.payload = payload
            self.message: Optional[discord.Message] = None
            self.gigantamax_enabled = False
            self._handled = False
            
            # Add Gigantamax toggle if species can Gigantamax
            species_name = payload.get("species_name", "")
            if AdminGivePokemon.can_gigantamax(species_name):
                # Initialize to False (user must explicitly enable)
                self.payload["can_gigantamax"] = False
                # Add toggle button
                self.toggle_btn = ui.Button(
                    label="Enable Gigantamax",
                    style=discord.ButtonStyle.secondary,
                    row=1
                )
                self.toggle_btn.callback = self.toggle_gigantamax
                self.add_item(self.toggle_btn)

        async def toggle_gigantamax(self, interaction: Interaction):
            species_name = self.payload.get("species_name", "")
            if not AdminGivePokemon.can_gigantamax(species_name):
                await interaction.response.send_message("This Pok√©mon cannot Gigantamax.", ephemeral=True)
                return
            
            self.gigantamax_enabled = not self.gigantamax_enabled
            self.payload["can_gigantamax"] = self.gigantamax_enabled
            
            if self.gigantamax_enabled:
                self.toggle_btn.label = "Disable Gigantamax"
                self.toggle_btn.style = discord.ButtonStyle.success
            else:
                self.toggle_btn.label = "Enable Gigantamax"
                self.toggle_btn.style = discord.ButtonStyle.secondary
            
            await interaction.response.edit_message(view=self)

        async def on_timeout(self):
            if self.message:
                try:
                    await self.message.edit(content="‚è≥ Preview expired.", view=None)
                except Exception:
                    pass

        @ui.button(label="Confirm", style=discord.ButtonStyle.primary)
        async def confirm(self, interaction: Interaction, button: ui.Button):
            if self._handled:
                if not interaction.response.is_done():
                    await interaction.response.send_message("Already handled.", ephemeral=True)
                else:
                    await interaction.followup.send("Already handled.", ephemeral=True)
                return
            self._handled = True
            if not interaction.response.is_done():
                await interaction.response.defer(ephemeral=True)
            try:
                # Ensure can_gigantamax is set (default to False if not already set)
                if "can_gigantamax" not in self.payload:
                    self.payload["can_gigantamax"] = False
                await AdminGivePokemon._finalize(interaction, self.payload)
            except Exception as e:
                try:
                    await interaction.followup.send(f"‚ùå Failed to give Pok√©mon: {e}", ephemeral=True)
                except Exception:
                    pass
            if self.message:
                try:
                    for child in self.children:
                        if isinstance(child, ui.Button):
                            child.disabled = True
                    await self.message.edit(view=self)
                except Exception:
                    pass

        @ui.button(label="Cancel", style=discord.ButtonStyle.danger)
        async def cancel(self, interaction: Interaction, button: ui.Button):
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùé Canceled. Nothing saved.", ephemeral=True)
            else:
                await interaction.followup.send("‚ùé Canceled. Nothing saved.", ephemeral=True)
            if self.message:
                try:
                    for child in self.children:
                        if isinstance(child, ui.Button):
                            child.disabled = True
                    await self.message.edit(view=self)
                except Exception:
                    pass

    # ---------- DB finalize ----------
    @staticmethod
    async def _finalize(inter: Interaction, p: dict):
        # Normalize stats from DB to long keys before calc
        base_stats_long = AdminGivePokemon._normalize_stats_long(p["base_stats"])

        ivs = p.get("ivs") or {k: 31 for k in ["hp","attack","defense","special_attack","special_defense","speed"]}
        evs = p.get("evs") or {k: 0  for k in ["hp","attack","defense","special_attack","special_defense","speed"]}

        final_stats = stats.calc_all_stats(
            base_stats=base_stats_long, ivs=ivs, evs=evs, level=p["level"], nature=p["nature"]
        )

        # Get Gigantamax status (default to False if not specified)
        can_gigantamax = p.get("can_gigantamax", False)

        tera_type = p.get("tera_type")
        if tera_type is None:
            try:
                species_entry = await ensure_species_and_learnsets(p["species_name"])
                species_types = _extract_species_types(species_entry)
                tera_type = _roll_default_tera_type(species_types)
            except Exception:
                tera_type = None
        
        # Get form from payload (if specified)
        form_key = p.get("form")
        
        mon_id = await db.add_pokemon_with_stats(
            owner_id=p["target_id"], species=p["species_name"], level=p["level"],
            final_stats=final_stats, ivs=ivs, evs=evs, nature=p["nature"], ability=p["ability"], 
            gender=p["gender"], form=form_key, can_gigantamax=can_gigantamax, tera_type=tera_type
        )

        # Save shiny + ball + form + friendship using your columns
        conn = await db.connect()
        try:
            # Always include friendship in the update (use value from payload or default to base_friendship)
            friendship_value = p.get("friendship")
            if friendship_value is None:
                # Fallback to base_friendship if not explicitly set
                friendship_value = p.get("base_friendship", 50)
            
            # Update form only if it wasn't already set in add_pokemon_with_stats (for consistency)
            # But we'll still update it here to ensure it's correct
            await conn.execute(
                "UPDATE pokemons SET shiny=?, pokeball=?, form=?, friendship=? WHERE owner_id=? AND id=?",
                (1 if p.get("shiny") else 0, (p.get("pokeball") or None), form_key, int(friendship_value), p["target_id"], mon_id),
            )
            await conn.commit()
            db.invalidate_pokemons_cache(p["target_id"])
        except Exception as e:
            # Log error but don't fail the entire command
            import traceback
            print(f"[GivePokemon] Error updating pokemon (shiny/ball/form/friendship): {e}")
            traceback.print_exc()
        finally:
            try:
                await conn.close()
            except Exception:
                pass
        # Held item - add to bag first, then set as held
        try:
            if p.get("item_id"):
                conn = await db.connect()
                try:
                    # Ensure user exists in users table (for foreign key constraint)
                    cur = await conn.execute("SELECT 1 FROM users WHERE user_id = ?", (p["target_id"],))
                    exists = await cur.fetchone()
                    await cur.close()
                    if not exists:
                        await conn.execute("INSERT INTO users(user_id, coins, currencies) VALUES(?, 3000, '{\"coins\": 3000}'::jsonb)", (p["target_id"],))
                        await conn.commit()
                    # Add 1 of the item to the user's bag (if not already present)
                    await conn.execute(
                        "INSERT INTO user_items(owner_id, item_id, qty) VALUES(?,?,1) "
                        "ON CONFLICT(owner_id, item_id) DO UPDATE SET qty = user_items.qty + 1;",
                        (p["target_id"], p["item_id"])
                    )
                    await conn.commit()
                    db.invalidate_bag_cache(p["target_id"])
                    # Now set it as held
                    await db.set_held_item(p["target_id"], mon_id, p["item_id"])
                finally:
                    try:
                        await conn.close()
                    except Exception:
                        pass
        except Exception:
            pass

        # Moves
        try:
            await db.set_pokemon_moves(p["target_id"], mon_id, p.get("moves") or [])
        except Exception:
            pass

        # Team autoslot or slot selection
        slotted = None
        if p.get("autoslot"):
            try:
                slot = await db.next_free_team_slot(p["target_id"])
                if slot is not None:
                    await db.set_team_slot(p["target_id"], mon_id, slot)
                    slotted = slot
                else:
                    # Team is full - slot selection should have been handled before finalize
                    # If we get here and no slot was pre-selected, use slot 1 as fallback
                    if "selected_slot" in p:
                        await db.set_team_slot(p["target_id"], mon_id, p["selected_slot"])
                        slotted = p["selected_slot"]
            except Exception:
                pass
        elif "selected_slot" in p:
            # Slot was manually selected (team full scenario)
            try:
                await db.set_team_slot(p["target_id"], mon_id, p["selected_slot"])
                slotted = p["selected_slot"]
            except Exception:
                pass

        try:
            await db.log_event(
                user_id=p["target_id"], type_="givepokemon",
                payload={k: v for k, v in p.items() if k != "base_stats"}
            )
        except Exception:
            pass

        suffix = f" ‚Ä¢ Autoslotted to **Slot {slotted}**" if slotted else ""
        success_name = str(p.get("form_display_name") or p.get("species_name") or "pokemon").strip()
        if not success_name:
            success_name = "pokemon"
        # Keep Mimikyu default naming clean when using disguised-as-base handling.
        if success_name.lower() in {"mimikyu (base)", "mimikyu (disguised)", "mimikyu (disguised form)"}:
            success_name = "Mimikyu"
        elif success_name == str(p.get("species_name") or ""):
            success_name = success_name.replace("-", " ").title()
        await inter.followup.send(
            f"‚úÖ Gave **{success_name}** (Lv {p['level']}) to <@{p['target_id']}>.{suffix}",
            ephemeral=True,
            allowed_mentions=discord.AllowedMentions(users=True),
        )

    # ---------- AUTOCOMPLETE helpers ----------
    @staticmethod
    async def _ac_species_choices(current: str) -> List[app_commands.Choice[str]]:
        q = f"%{(current or '').lower()}%" if current else "%"
        conn = await db.connect()
        try:
            cur = await conn.execute("SELECT id, name FROM pokedex WHERE LOWER(name) LIKE ? ORDER BY name LIMIT 25", (q,))
            rows = await cur.fetchall(); await cur.close()
            return [app_commands.Choice(name=r["name"].title(), value=str(r["name"])) for r in rows]
        except Exception:
            base = ["Pikachu","Charizard","Garchomp","Gardevoir","Gengar","Dragonite","Mewtwo","Latios","Latias"]
            return [app_commands.Choice(name=n, value=n.lower()) for n in base if n.lower().startswith((current or "").lower())][:25]
        finally:
            try:
                await conn.close()
            except Exception:
                pass

    @staticmethod
    async def _ac_item_choices(current: str) -> List[app_commands.Choice[str]]:
        q = f"%{(current or '').lower()}%" if current else "%"
        conn = await db.connect()
        try:
            cur = await conn.execute("SELECT id, name FROM items WHERE LOWER(name) LIKE ? ORDER BY name LIMIT 25", (q,))
            rows = await cur.fetchall(); await cur.close()
            return [app_commands.Choice(name=r["name"].title(), value=str(r["name"])) for r in rows]
        except Exception:
            base = ["Choice Scarf","Choice Band","Choice Specs","Leftovers","Life Orb","Sitrus Berry","Lum Berry","Focus Sash"]
            return [app_commands.Choice(name=n, value=AdminGivePokemon._norm_name(n)) for n in base if n.lower().startswith((current or "").lower())][:25]
        finally:
            try:
                await conn.close()
            except Exception:
                pass

    @staticmethod
    async def _ac_ball_choices(current: str) -> List[app_commands.Choice[str]]:
        q = f"%{(current or '').lower()}%" if current else "%"
        conn = await db.connect()
        try:
            cur = await conn.execute(
                "SELECT name FROM items WHERE LOWER(name) LIKE ? AND LOWER(name) LIKE '%ball%' ORDER BY name LIMIT 25", (q,)
            )
            rows = await cur.fetchall(); await cur.close()
            res = [r["name"] for r in rows]
            if res:
                return [app_commands.Choice(name=n.title(), value=AdminGivePokemon._norm_name(n)) for n in res]
        except Exception:
            pass
        finally:
            try:
                await conn.close()
            except Exception:
                pass
        base = ["Poke Ball","Great Ball","Ultra Ball","Premier Ball","Luxury Ball","Quick Ball","Dusk Ball","Net Ball","Dive Ball","Repeat Ball","Timer Ball","Heal Ball","Nest Ball","Friend Ball","Level Ball","Love Ball","Moon Ball","Fast Ball","Lure Ball","Heavy Ball"]
        return [app_commands.Choice(name=n, value=AdminGivePokemon._norm_name(n)) for n in base if n.lower().startswith((current or "").lower())][:25]

    @staticmethod
    async def _ac_moves_choices(inter: Interaction, current: str) -> List[app_commands.Choice[str]]:
        conn = await db.connect()
        try:
            gen = await _ruleset_gen(conn, inter.guild)
            sp_opt = getattr(inter, "namespace", None)
            sp_name = getattr(sp_opt, "species", None) if sp_opt else None
            species_id = None
            if sp_name:
                sp = await ensure_species_and_learnsets(sp_name)
                species_id = int(sp["id"])
            moves: List[str] = []
            if species_id:
                try:
                    legal = await legal_moves(species_id, gen)
                    moves = [m for m in legal if (current or "").lower() in m.lower()]
                except Exception:
                    cur = await conn.execute("SELECT name FROM moves WHERE LOWER(name) LIKE ? ORDER BY name LIMIT 25", (f"%{(current or '').lower()}%",))
                    rows = await cur.fetchall(); await cur.close()
                    moves = [r["name"] for r in rows]
            else:
                cur = await conn.execute("SELECT name FROM moves WHERE LOWER(name) LIKE ? ORDER BY name LIMIT 25", (f"%{(current or '').lower()}%",))
                rows = await cur.fetchall(); await cur.close()
                moves = [r["name"] for r in rows]
            return [app_commands.Choice(name=m.replace("-", " ").title(), value=AdminGivePokemon._norm_name(m)) for m in moves[:25]]
        except Exception:
            base = ["Tackle","Growl","Dragon Dance","Draco Meteor","Earthquake","Fire Fang","Ice Beam","Thunderbolt"]
            return [app_commands.Choice(name=n, value=AdminGivePokemon._norm_name(n)) for n in base if (current or "").lower() in n.lower()][:25]
        finally:
            try:
                await conn.close()
            except Exception:
                pass

    # ---------- command ----------
    @app_commands.command(
        name="givepokemon",
        description="Give a Pok√©mon to a user (quick mode with preview).",
    )
    @app_commands.describe(
        user="Target user (defaults to you)",
        species="Species (name or Dex id)",
        level="Level (default 1)",
        gender="male/female/genderless (auto-legal if omitted)",
        nature="Nature (random if omitted)",
        ability="Ability (id or name; legal default if omitted)",
        item="Held item (optional)",
        moves="Comma- or slash-separated moves (‚â§4)",
        shiny="Make it shiny? (default random)",
        ball="Pok√© Ball (default pokeball)",
        tera_type="Override Tera Type (default: roll from species' native types)",
        autoslot="Put into first free team slot (default Yes)",
        dry_run="Preview only; don‚Äôt save (default No)",
        ivs="Six comma-separated IVs: HP,Atk,Def,SpA,SpD,Spe (default 31,31,31,31,31,31)",
        evs="Six comma-separated EVs: HP,Atk,Def,SpA,SpD,Spe (default 0,0,0,0,0,0)",
        friendship="Starting friendship (0-255, default uses Pok√©dex base friendship)",
    )
    async def givepokemon(
        self,
        interaction: Interaction,
        user: Optional[discord.User] = None,
        species: Optional[str] = None,
        level: Optional[int] = None,
        gender: Optional[str] = None,
        nature: Optional[str] = None,
        ability: Optional[str] = None,
        item: Optional[str] = None,
        moves: Optional[str] = None,
        shiny: Optional[bool] = None,
        ball: Optional[str] = None,
        tera_type: Optional[str] = None,
        autoslot: Optional[bool] = True,
        dry_run: Optional[bool] = False,
        ivs: Optional[str] = None,
        evs: Optional[str] = None,
        friendship: Optional[int] = None,
    ):
        await interaction.response.defer(ephemeral=True)

        # Owner-only safety lock.
        if int(interaction.user.id) not in OWNER_IDS:
            return await interaction.followup.send(
                "‚ùå `/givepokemon` is owner-only.",
                ephemeral=True,
            )
        
        target = user or interaction.user
        target_id = str(target.id)

        # Species
        if not species:
            species = random.choice(["garchomp","latios","latias","dragonite","charizard","gengar","mewtwo","pikachu"])
        try:
            sp = await ensure_species_and_learnsets(species)
        except Exception as e:
            # If species not found, give Missing n0 instead
            try:
                sp = await ensure_species_and_learnsets("missing n0")
                # Clear ability if specified (Missing n0 abilities are rolled at battle start)
                if ability:
                    ability = None
            except Exception:
                return await interaction.followup.send(f"Couldn't load species `{species}`: {e}", ephemeral=True)

        species_id   = int(sp["id"])
        species_name = sp["name"]
        species_types = _extract_species_types(sp)
        friendship_note_msg = ""
        base_friendship = await _get_base_friendship(species_name)
        # For Missing n0, if base_friendship is None/0, default to 50
        if species_name.lower() == "missing n0" and (base_friendship is None or base_friendship == 0):
            base_friendship = 50
        if friendship is None:
            starting_friendship = base_friendship
            friendship_note_msg = f"Starting friendship defaults to base {base_friendship}."
        else:
            requested = int(friendship)
            starting_friendship = max(0, min(255, requested))
            clamp_note = " (clamped)" if starting_friendship != requested else ""
            friendship_note_msg = f"Starting friendship set to {starting_friendship}{clamp_note}; base {base_friendship}."

        explicit_tera = None
        tera_type_source = "auto"
        tera_type_notes: list[str] = []
        if tera_type:
            explicit_tera = _normalize_type_id(tera_type)
            if explicit_tera not in VALID_TERA_TYPES:
                valid_list = ", ".join(t.title() for t in VALID_TERA_TYPES)
                return await interaction.followup.send(
                    f"‚ùå Invalid Tera Type `{tera_type}`. Choose one of: {valid_list}.",
                    ephemeral=True
                )
            tera_type_source = "manual"
            if explicit_tera not in species_types:
                tera_type_notes.append(f"Tera Type `{explicit_tera.title()}` is not in this species' native pool.")
        resolved_tera_type = explicit_tera or _roll_default_tera_type(species_types)

        # Check for available forms and show buttons if needed (exclude battle-only forms, mega/primal/origin forms)
        conn = await db.connect()
        try:
            form_rows = await _safe_pokedex_forms_fetchall(
                conn,
                """SELECT form_key, display_name, abilities FROM pokedex_forms 
                   WHERE species_id = ? 
                   AND (is_battle_only IS NOT TRUE)
                   AND (LOWER(form_key) NOT LIKE 'mega%')
                   AND (LOWER(form_key) NOT LIKE '%mega%')
                   AND (LOWER(form_key) NOT LIKE '%primal%')
                   AND (LOWER(form_key) NOT LIKE '%origin%')
                   AND form_key NOT IN ('mega-x', 'mega-y', 'mega-charizard-x', 'mega-charizard-y', 
                                        'mega-venusaur', 'mega-blastoise', 'primal-groudon', 'primal-kyogre',
                                        'origin-dialga', 'origin-palkia', 'origin-giratina')
                   ORDER BY form_key""",
                (species_id,),
            )
            
            if form_rows:
                # === SPECIAL HANDLING FOR GRENINJA ===
                # Greninja is unique: ability determines the form
                # - battle-bond ability ‚Üí Battle Bond form
                # - torrent/protean ‚Üí Base form
                # - no ability specified ‚Üí ask user to choose
                # If user specified ability, auto-select the correct form
                if species_name.lower() == "greninja" and ability:
                    ability_norm = ability.lower().replace(" ", "-").replace("_", "-")
                    
                    # If ability is battle-bond, use battle-bond form
                    if ability_norm == "battle-bond":
                        selected_form_key = "battle-bond"
                        # Continue with this form (don't show selection UI)
                        # We'll let the code below handle it by not returning early
                    # If ability is torrent or protean, use base form
                    elif ability_norm in ["torrent", "protean"]:
                        selected_form_key = None  # Base form
                    else:
                        # Unknown ability for Greninja, show form selection
                        selected_form_key = None
                        ability = None  # Clear it so user can choose
                    
                    # If we auto-selected a form, skip the UI and continue
                    if ability:
                        # Continue to normal givepokemon flow with the selected form
                        # We need to fetch form data if it's not base
                        if selected_form_key:
                            # Fetch form-specific data
                            form_data_row = await _safe_pokedex_forms_fetchone(
                                conn,
                                "SELECT abilities FROM pokedex_forms WHERE species_id = ? AND form_key = ?",
                                (species_id, selected_form_key),
                            )
                            
                            if form_data_row and form_data_row['abilities']:
                                # Override base species abilities with form abilities
                                sp = dict(sp)  # Make a copy
                                sp['abilities'] = form_data_row['abilities']
                        
                        # Set form in the species dict for later use
                        sp['_selected_form'] = selected_form_key
                        # Continue to normal flow below
                        await conn.close()
                        # Don't return, let it continue to normal givepokemon logic
                    else:
                        # Show form selection for Greninja without ability specified
                        pass  # Fall through to form selection UI
                else:
                    # Not Greninja or no ability specified for other species
                    pass
                
                # If we didn't auto-select for Greninja, show form selection UI
                # Skip form selection for Wishiwashi - solo form is the base form (temporary battle forms don't need selection)
                if (species_name.lower() != "greninja" or not ability) and species_name.lower() != "wishiwashi":
                    # Base option handling:
                    # - Mimikyu: default/base should be the Disguised form and labeled just "Mimikyu".
                    # - Others: include explicit base option.
                    available_forms: list[dict] = []
                    if species_name.lower() == "mimikyu":
                        disguised_row = None
                        remaining_rows = []
                        for row in form_rows:
                            fk = str((row["form_key"] if hasattr(row, "keys") else row[0]) or "").strip().lower()
                            dn = str((row["display_name"] if hasattr(row, "keys") else row[1]) or "").strip().lower()
                            if disguised_row is None and ("disguised" in fk or "disguised" in dn):
                                disguised_row = row
                            else:
                                remaining_rows.append(row)
                        if disguised_row is not None:
                            disguised_key = disguised_row["form_key"] if hasattr(disguised_row, "keys") else disguised_row[0]
                            available_forms.append({"form_key": disguised_key, "display_name": species_name.title()})
                            # If only disguised is available, auto-select it without showing a form picker.
                            if not remaining_rows:
                                sp = dict(sp)
                                sp["_selected_form"] = disguised_key
                        else:
                            available_forms.append({"form_key": None, "display_name": species_name.title()})
                            remaining_rows = list(form_rows)
                        available_forms.extend([
                            {
                                "form_key": (row["form_key"] if hasattr(row, "keys") else row[0]),
                                "display_name": (row["display_name"] if hasattr(row, "keys") else row[1]),
                            }
                            for row in remaining_rows
                        ])
                    else:
                        available_forms.append({'form_key': None, 'display_name': f"{species_name.title()} (Base)"})
                        available_forms.extend([{'form_key': row['form_key'], 'display_name': row['display_name']} for row in form_rows])
                    
                    if len(available_forms) > 1:
                        # Get gen for legality
                        gen_val = await _ruleset_gen(conn, interaction.guild)
                        
                        # Show form selection buttons - pass all original command params
                        view = GivePokemonFormView(
                            cog=self,
                            interaction=interaction,
                            species_id=species_id,
                            species_name=species_name,
                            available_forms=available_forms,
                            target=target,
                            gen=gen_val,
                            # Pass original command parameters
                            level=level,
                            gender=gender,
                            nature=nature,
                            ability=ability,
                            item=item,
                            moves=moves,
                            shiny=shiny,
                            ball=ball,
                            tera_type=tera_type,
                            autoslot=autoslot,
                            ivs=ivs,
                            evs=evs,
                            friendship=friendship
                        )
                        await conn.close()
                        return await interaction.followup.send(
                            f"üîÑ **Select a form for {species_name.title()}:**",
                            view=view,
                            ephemeral=True
                        )
        finally:
            await conn.close()

        base_stats = sp.get("stats") or {}
        if isinstance(base_stats, str):
            try: base_stats = json.loads(base_stats)
            except Exception: base_stats = {}
        base_stats = self._normalize_stats_long(base_stats)  # <‚Äî normalize for calc_all_stats

        abilities    = sp.get("abilities") or []
        if isinstance(abilities, str):
            try: abilities = json.loads(abilities)
            except Exception: abilities = []
        gender_ratio = sp.get("gender_ratio") or {}
        if isinstance(gender_ratio, str):
            try: gender_ratio = json.loads(gender_ratio)
            except Exception: gender_ratio = {}

        conn = await db.connect()
        try:
            gen = await _ruleset_gen(conn, interaction.guild)

            lvl = max(1, min(100, int(level) if level else 1))

            # Fuzzy match nature
            nat = (nature or "").strip().lower()
            if not nat:
                nat = stats.pick_random_nature().lower()
            else:
                matched_nature, confidence, suggestions = FuzzyMatcher.fuzzy_nature(nat)
                if matched_nature and confidence >= 0.70:
                    nat = matched_nature.lower()
                elif nat not in stats.NATURE_PLUS_MINUS:
                    sugg_text = f" Did you mean: {', '.join(suggestions[:3])}?" if suggestions else ""
                    return await interaction.followup.send(f"Unknown nature `{nature}`.{sugg_text}", ephemeral=True)

            # For Missing n0, ignore ability (abilities are rolled at battle start)
            if species_name.lower() == "missing n0":
                ab = None
                if ability:
                    notes.append("Ability ignored for Missing n0 (abilities are rolled at battle start).")
            else:
                ab = await self._species_autocorrect_ability(abilities, ability)
            chosen_gender, gender_note = self._roll_gender_legal(gender_ratio, gender)
            shiny_val = (random.random() < (1/4096)) if shiny is None else bool(shiny)

            pokeball = self._norm_name(ball or "pokeball")
            item_id = None
            notes: list[str] = []
            notes.extend(tera_type_notes)
            if tera_type_source == "auto" and resolved_tera_type is None:
                notes.append("Tera Type could not be rolled; species has no type data.")
            if item:
                # Fuzzy match item
                matched_item, confidence, suggestions = await FuzzyMatcher.fuzzy_item(conn, item)
                if matched_item and confidence >= 0.70:
                    item_id = matched_item
                    if item.lower().replace(" ", "-") != matched_item.lower():
                        notes.append(f"Item autocorrected: '{item}' ‚Üí '{matched_item}'")
                else:
                    sugg_text = f" Did you mean: {', '.join(suggestions[:3])}?" if suggestions else ""
                    notes.append(f"Item `{item}` not found.{sugg_text} Will be omitted.")
        finally:
            try:
                await conn.close()
            except Exception:
                pass

        wanted_moves = self._parse_moves(moves)
        default_moves = await self._choose_default_moves(species_id, lvl, gen)
        final_moves, move_notes = await self._validate_moves(species_id, gen, wanted_moves, default_moves)
        notes.extend(move_notes)

        ivs_dict = self._parse_six_csv(ivs, kind="ivs")
        evs_dict = self._parse_six_csv(evs, kind="evs")

        # Get form if auto-selected (for Greninja)
        form_key = sp.get("_selected_form") if isinstance(sp, dict) else None
        form_display_name = None
        try:
            if species_name.lower() == "mimikyu" and form_key and "disguised" in str(form_key).lower():
                form_display_name = "Mimikyu"
        except Exception:
            form_display_name = None
        
        payload = {
            "target_id": target_id,
            "target_mention": target.mention,
            "target_display": getattr(target, "display_name", None),
            "target_tag": f"{target.name}#{getattr(target, 'discriminator', '0')}" if hasattr(target, "discriminator") else target.name,
            "species_id": species_id,
            "species_name": species_name,
            "form_display_name": form_display_name,
            "base_stats": base_stats,  # already normalized
            "gen": gen,
            "level": lvl,
            "nature": nat,
            "ability": ab,
            "gender": chosen_gender,
            "gender_note": gender_note,
            "shiny": shiny_val,
            "pokeball": pokeball,
            "item_id": item_id,
            "moves": final_moves,
            "autoslot": bool(autoslot),
            "ivs": ivs_dict,
            "evs": evs_dict,
            "form": form_key,  # Include form if auto-selected
            "tera_type": resolved_tera_type,
            "tera_type_source": tera_type_source,
            "species_types": species_types,
            "friendship": starting_friendship,
            "base_friendship": base_friendship,
        }

        sprite_file = self._pick_sprite_file(species_name, chosen_gender, shiny_val, form_key)

        view = AdminGivePokemon._ConfirmView(payload)
        emb = await self._preview_embed(interaction, payload, notes, sprite_file)
        if sprite_file:
            msg = await interaction.followup.send(embed=emb, view=view, files=[sprite_file], ephemeral=True,
                                                  allowed_mentions=discord.AllowedMentions(users=True))
        else:
            msg = await interaction.followup.send(embed=emb, view=view, ephemeral=True,
                                                  allowed_mentions=discord.AllowedMentions(users=True))
        view.message = msg

        if dry_run:
            await msg.edit(content="üß™ Dry run ‚Äî no DB changes will be made.", view=None)
            return

    # ---- Autocomplete bindings ----
    @givepokemon.autocomplete("species")
    async def _ac_species(self, interaction: Interaction, current: str):
        return await self._ac_species_choices(current)

    @givepokemon.autocomplete("item")
    async def _ac_item(self, interaction: Interaction, current: str):
        return await self._ac_item_choices(current)

    @givepokemon.autocomplete("ball")
    async def _ac_ball(self, interaction: Interaction, current: str):
        return await self._ac_ball_choices(current)

    @givepokemon.autocomplete("moves")
    async def _ac_moves(self, interaction: Interaction, current: str):
        return await self._ac_moves_choices(interaction, current)


async def setup(bot: commands.Bot):
    await bot.add_cog(AdminGivePokemon(bot))

# =========================
#  Gameplay commands (DB-backed)
# =========================
# Test
def render_item_line(name: str, qty: int, emoji: str | None = None) -> str:
    prefix = f"{emoji} " if emoji else ""
    return f"{prefix}**{name}** √ó{qty}"
@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: Exception):
    # Log to console
    import traceback
    traceback.print_exception(type(error), error, error.__traceback__)
    # Try to respond if nothing was sent yet
    try:
        if not interaction.response.is_done():
            await interaction.response.send_message("‚ùå An error occurred running this command.", ephemeral=True)
        else:
            await interaction.followup.send("‚ùå An error occurred running this command.", ephemeral=True)
    except Exception:
        pass
@bot.tree.command(name="test", description="Check if the bot is online.")
async def test_slash(interaction: discord.Interaction):
    await interaction.response.send_message("Bot Online.", ephemeral=True)


@bot.tree.command(name="code", description="Enter the access code to unlock the bot.")
@app_commands.describe(code="The access code you were given")
async def code_cmd(interaction: discord.Interaction, code: str):
    if not BOT_ACCESS_CODE:
        await interaction.response.send_message(
            "Access codes are not required right now.",
            ephemeral=True,
        )
        return
    uid = str(interaction.user.id)
    if interaction.user.id in (OWNER_IDS | CODE_BYPASS_IDS):
        await interaction.response.send_message(
            "‚úÖ You're already whitelisted ‚Äî no code needed!",
            ephemeral=True,
        )
        return
    if (code or "").strip() == BOT_ACCESS_CODE:
        await db.set_access_verified(uid)
        _set_cached_access_verified(int(uid), True)
        await interaction.response.send_message(
            "‚úÖ Access granted! You can now use the bot.",
            ephemeral=True,
        )
    else:
        _set_cached_access_verified(int(uid), False)
        await interaction.response.send_message(
            "‚ùå Invalid code. Please check and try again.",
            ephemeral=True,
        )
# --- OAK Dialogue images ---
OAK_IMAGE_URL = "https://archives.bulbagarden.net/media/upload/thumb/3/3e/Lets_Go_Pikachu_Eevee_Professor_Oak.png/180px-Lets_Go_Pikachu_Eevee_Professor_Oak.png"
STARTER_PICK_IMAGE_URL = "https://pokemonblog.com/wp-content/uploads/2018/06/pokemon_trainer_spotlight_professor_oak_with_kanto_starters_bulbasaur_charmander_and_squirtle.jpg"

import json
import discord
from discord import app_commands

# If you renamed your package to "pokelib", switch these imports accordingly.
from lib.poke_ingest import ensure_species_and_learnsets
from lib.stats        import generate_mon
from lib import db

# NOTE: You said you already added these helpers elsewhere:
#   shiny_roll(), parse_abilities(), roll_hidden_ability()
# I will CALL them below and NOT redefine them here.

# ---------------- per-user gen helpers ----------------
def _normalize_stats_for_generator(stats: dict) -> dict:
    """
    Convert DB stats into underscore long-form keys required by generate_mon():
    {hp, attack, defense, special_attack, special_defense, speed}
    Supports short keys {atk, def, spa, spd, spe} or hyphen keys.
    """
    if not isinstance(stats, dict):
        return {}
    lk = {str(k).lower().replace("-", "_"): v for k, v in stats.items()}
    return {
        "hp": lk.get("hp", 0),
        "attack": lk.get("attack", lk.get("atk", 0)),
        "defense": lk.get("defense", lk.get("def", 0)),
        "special_attack": lk.get("special_attack", lk.get("spa", lk.get("specialattack", 0))),
        "special_defense": lk.get("special_defense", lk.get("spd", lk.get("specialdefense", 0))),
        "speed": lk.get("speed", lk.get("spe", 0)),
    }
async def _ensure_user_in_gen1(user_id: str) -> None:
    """
    Make sure a user exists and is initialized at Gen 1 with user_rulesets.
    Safe to call repeatedly.
    """
    conn = await db.connect()
    try:
        # users row (basic user data)
        await conn.execute("INSERT OR IGNORE INTO users (user_id) VALUES (?)", (user_id,))
        # user_rulesets row with gen 1 defaults
        await conn.execute(
            "INSERT OR IGNORE INTO user_rulesets (user_id, generation, max_unlocked_gen, updated_at_utc) "
            "VALUES (?, 1, 1, CURRENT_TIMESTAMP)",
            (user_id,),
        )
        await conn.commit()
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _ensure_starter_mon_row(uid: str, species: str, mon: dict, entry: dict, *, tera_type: Optional[str], base_friend: int) -> bool:
    """
    If the user somehow has no pokemons row (e.g., a prior transaction rolled back),
    insert a minimal starter in team_slot=1. Best-effort; returns True if a row
    exists or was inserted.
    """
    try:
        async with db.session() as conn:
            cur = await conn.execute("SELECT id FROM pokemons WHERE owner_id=? LIMIT 1", (uid,))
            row = await cur.fetchone()
            await cur.close()
            if row:
                return True
    except Exception:
        return False

    stats = mon.get("stats") or {}
    ivs = mon.get("ivs") or {}
    evs = mon.get("evs") or {}

    # Gen 1 level-up moves up to level 5
    moves: list[str] = []
    try:
        species_id = entry.get("id")
        if species_id:
            moves = await _default_levelup_moves(int(species_id), 5, 1)
    except Exception:
        moves = []
    if not moves:
        moves = ["Tackle"]
    pps = [_base_pp(m, generation=1) for m in moves[:4]]

    try:
        async with db.session() as conn:
            try:
                col_flags = await _pg_pokemons_column_flags(conn)
            except Exception:
                col_flags = {"hp_now": True, "moves_pp": True, "shiny": True, "is_hidden_ability": True}

            exp_group = await _get_exp_group_for_species(conn, species)
            initial_exp = await _get_exp_total_for_level(conn, exp_group, 5)
            cols = [
                "owner_id", "species", "level",
                "hp", "atk", "def", "spa", "spd", "spe",
                "ivs", "evs", "nature", "ability", "gender",
                "moves", "friendship",
                "team_slot", "box_no", "box_pos",
                "tera_type",
                "exp", "exp_group",
            ]
            vals = [
                uid, species, 5,
                int(stats.get("hp", 1)),
                int(stats.get("attack", 1)),
                int(stats.get("defense", 1)),
                int(stats.get("special_attack", 1)),
                int(stats.get("special_defense", 1)),
                int(stats.get("speed", 1)),
                json.dumps(ivs, ensure_ascii=False),
                json.dumps(evs, ensure_ascii=False),
                mon.get("nature") or "hardy",
                mon.get("ability"),
                mon.get("gender"),
                json.dumps([m.title() for m in moves[:4]], ensure_ascii=False),
                int(base_friend),
                1, 1, 1,
                tera_type,
                initial_exp, exp_group,
            ]
            if col_flags.get("hp_now"):
                cols.insert(4, "hp_now")
                vals.insert(4, int(stats.get("hp", 1)))
            if col_flags.get("moves_pp"):
                cols.append("moves_pp")
                vals.append(json.dumps(pps, ensure_ascii=False))
            if col_flags.get("shiny"):
                cols.append("shiny")
                vals.append(int(bool(mon.get("is_shiny"))))
            if col_flags.get("is_hidden_ability"):
                cols.append("is_hidden_ability")
                vals.append(int(bool(mon.get("is_hidden_ability"))))
            cols.append("can_gigantamax")
            vals.append(False)

            await _tx_begin(conn)
            await conn.execute(
                f"INSERT INTO pokemons ({', '.join(cols)}) VALUES ({', '.join('?' for _ in cols)})",
                tuple(vals),
            )
            await _tx_commit(conn)
            db.invalidate_pokemons_cache(uid)
            return True
    except Exception:
        try:
            await _tx_rollback(conn)
        except Exception:
            pass
        return False

async def _user_selected_gen(user_id: str) -> int:
    """Return the player's currently selected gen (defaults to 1)."""
    uid = str(user_id)
    cached = _get_cached_user_gen(uid)
    if cached is not None:
        return cached
    conn = await db.connect()
    try:
        cur  = await conn.execute("SELECT generation FROM user_rulesets WHERE user_id=?", (uid,))
        row  = await cur.fetchone(); await cur.close()
        val = int(row["generation"]) if row and row.get("generation") is not None else 1
        _set_cached_user_gen(uid, val)
        return val
    except Exception:
        return 1
    finally:
        try:
            await conn.close()
        except Exception:
            pass


# ---------------- helper functions for storing extra fields ----------------
async def _default_levelup_moves(species_id: int, level: int, generation: int, limit: int = 4) -> list[str]:
    """Best-effort: choose up to 4 highest-level level-up moves from cache or DB."""
    if db_cache is not None:
        try:
            learnsets = db_cache.get_cached_learnsets()
            if learnsets:
                rows = [
                    r for r in learnsets
                    if int(r.get("species_id") or -1) == int(species_id)
                    and int(r.get("generation") or 0) == generation
                    and str(r.get("method") or "").strip().lower() == "level-up"
                    and int(r.get("level_learned") or 0) <= level
                ]
                rows.sort(key=lambda r: (int(r.get("level_learned") or 0), str(r.get("move_id") or "")), reverse=True)
                seen, out = set(), []
                for r in rows[:40]:
                    move_id = r.get("move_id")
                    move = db_cache.get_cached_move(str(move_id)) if move_id is not None else None
                    name = (move.get("name") if move else None) or ""
                    if name:
                        name = name.replace("-", " ").title()
                        if name not in seen:
                            seen.add(name)
                            out.append(name)
                    if len(out) == limit:
                        break
                if out:
                    return out
        except Exception:
            pass
    conn = await db.connect()
    try:
        cur = await conn.execute("""
            SELECT m.name, COALESCE(l.level_learned, 0) AS lvl
            FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE l.species_id = ? AND l.generation = ? AND l.method = 'level-up'
                  AND COALESCE(l.level_learned, 0) <= ?
            ORDER BY lvl DESC, m.name
            LIMIT 40
        """, (species_id, generation, level))
        rows = await cur.fetchall(); await cur.close()
        seen, out = set(), []
        for r in rows:
            name = r["name"].replace("-", " ").title()
            if name not in seen:
                seen.add(name); out.append(name)
            if len(out) == limit:
                break
        return out
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _get_move_id(move_name: str) -> Optional[int]:
    """Return moves.id for move by name (LOWER match, space->hyphen)."""
    if not move_name:
        return None
    norm = str(move_name).strip().lower().replace(" ", "-")
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT id FROM moves WHERE LOWER(name)=? OR LOWER(REPLACE(name,' ','-'))=? LIMIT 1",
                (norm, norm),
            )
            row = await cur.fetchone()
            await cur.close()
        return int(row["id"]) if row and row.get("id") is not None else None
    except Exception:
        return None

async def _species_can_learn_move_by_machine(species_id: int, move_id: int, gen: int) -> bool:
    """True if this species can learn this move by TM/HM (method=machine) in this gen."""
    if db_cache is not None:
        try:
            learnsets = db_cache.get_cached_learnsets()
            if learnsets:
                for r in learnsets:
                    if int(r.get("species_id") or -1) != int(species_id) or int(r.get("move_id") or -1) != int(move_id):
                        continue
                    if int(r.get("generation") or 0) != gen:
                        continue
                    if str(r.get("method") or "").strip().lower() != "machine":
                        continue
                    return True
        except Exception:
            pass
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT 1 FROM learnsets WHERE species_id=? AND move_id=? AND generation=? AND LOWER(TRIM(method))='machine' LIMIT 1",
                (species_id, move_id, gen),
            )
            row = await cur.fetchone()
            await cur.close()
        return row is not None
    except Exception:
        return False

async def _get_team_can_learn_move(owner_id: str, move_name: str, gen: int) -> List[Dict[str, Any]]:
    """Return list of team Pok√©mon (id, species, level, team_slot, moves, ...) that can learn this move by machine in this gen. Excludes mons that already have the move."""
    move_id = await _get_move_id(move_name)
    if move_id is None:
        return []
    move_name_norm = (move_name or "").strip().lower().replace(" ", "-")
    out = []
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT p.id, p.species, p.level, p.team_slot, p.moves FROM pokemons p WHERE p.owner_id=? AND p.team_slot BETWEEN 1 AND 6 ORDER BY p.team_slot",
                (str(owner_id),),
            )
            rows = await cur.fetchall()
            await cur.close()
        for row in rows or []:
            r = dict(row) if hasattr(row, "keys") else {"id": row[0], "species": row[1], "level": row[2], "team_slot": row[3], "moves": row[4]}
            species_id = await _get_species_id(r.get("species") or "")
            if species_id is None:
                continue
            if not await _species_can_learn_move_by_machine(species_id, move_id, gen):
                continue
            moves_raw = r.get("moves")
            if isinstance(moves_raw, str):
                try:
                    moves_raw = json.loads(moves_raw)
                except Exception:
                    moves_raw = []
            if not isinstance(moves_raw, (list, tuple)):
                moves_raw = []
            current = [str(m).strip().lower().replace(" ", "-") for m in moves_raw[:4]]
            if move_name_norm in current:
                continue
            out.append(r)
        return out
    except Exception:
        return []

async def _get_species_id(species_name: str) -> Optional[int]:
    """Return pokedex id for species by name (LOWER match)."""
    if not species_name:
        return None
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT id FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1",
                (species_name.strip(),),
            )
            row = await cur.fetchone()
            await cur.close()
        return int(row["id"]) if row and row.get("id") is not None else None
    except Exception:
        return None

async def _get_team_tutor_eligible(user_id: str, gen: int) -> List[Dict[str, Any]]:
    """Return list of {id, species, display_name, species_id} for team Pok√©mon that can learn at least one tutor move in this gen."""
    out: List[Dict[str, Any]] = []
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT id, species FROM pokemons WHERE owner_id=? AND team_slot IS NOT NULL ORDER BY team_slot",
                (str(user_id),),
            )
            rows = await cur.fetchall()
            await cur.close()
        for row in rows or []:
            mon_id = row.get("id")
            species = (row.get("species") or "").strip()
            if not species:
                continue
            species_id = await _get_species_id(species)
            if species_id is None:
                continue
            tutor_moves = await _get_tutor_learnset_moves(species_id, gen)
            if not tutor_moves:
                continue
            display_name = species.replace("-", " ").title()
            out.append({"id": mon_id, "species": species, "display_name": display_name, "species_id": species_id})
        return out
    except Exception:
        return []

async def _get_tutor_learnset_moves(species_id: int, generation: int) -> list[str]:
    """Return move names from learnset that are tutor-only for this species in this gen."""
    if db_cache is not None:
        try:
            learnsets = db_cache.get_cached_learnsets()
            if learnsets:
                move_ids_seen = set()
                out = []
                for r in learnsets:
                    if int(r.get("species_id") or -1) != int(species_id) or int(r.get("generation") or 0) != generation:
                        continue
                    if str(r.get("method") or "").strip().lower() != "tutor":
                        continue
                    move_id = r.get("move_id")
                    if move_id in move_ids_seen:
                        continue
                    move_ids_seen.add(move_id)
                    move = db_cache.get_cached_move(str(move_id)) if move_id is not None else None
                    name = (move.get("name") if move else None) or ""
                    if name:
                        out.append(name.replace("-", " ").title())
                if out:
                    return sorted(out)
        except Exception:
            pass
    conn = await db.connect()
    try:
        cur = await conn.execute("""
            SELECT DISTINCT m.name
            FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE l.species_id = ? AND l.generation = ?
              AND LOWER(TRIM(l.method)) = 'tutor'
            ORDER BY m.name
        """, (species_id, generation))
        rows = await cur.fetchall()
        await cur.close()
        return [r["name"].replace("-", " ").title() for r in rows]
    except Exception:
        return []
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _get_egg_machine_learnset_moves(species_id: int, generation: int) -> list[str]:
    """Return move names from learnset that are egg or machine only (no tutor ‚Äî tutor doesn't exist in Gen 1)."""
    if db_cache is not None:
        try:
            learnsets = db_cache.get_cached_learnsets()
            if learnsets:
                methods = ("egg", "machine")
                move_ids_seen = set()
                out = []
                for r in learnsets:
                    if int(r.get("species_id") or -1) != int(species_id) or int(r.get("generation") or 0) != generation:
                        continue
                    m = str(r.get("method") or "").strip().lower()
                    if m not in methods:
                        continue
                    move_id = r.get("move_id")
                    if move_id in move_ids_seen:
                        continue
                    move_ids_seen.add(move_id)
                    move = db_cache.get_cached_move(str(move_id)) if move_id is not None else None
                    name = (move.get("name") if move else None) or ""
                    if name:
                        out.append(name.replace("-", " ").title())
                if out:
                    return sorted(out)
        except Exception:
            pass
    conn = await db.connect()
    try:
        cur = await conn.execute("""
            SELECT DISTINCT m.name
            FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE l.species_id = ? AND l.generation = ?
              AND LOWER(TRIM(l.method)) IN ('egg', 'machine')
            ORDER BY m.name
        """, (species_id, generation))
        rows = await cur.fetchall()
        await cur.close()
        return [r["name"].replace("-", " ").title() for r in rows]
    except Exception:
        return []
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _get_non_levelup_learnset_moves(species_id: int, generation: int) -> list[str]:
    """Return move names from learnset that are not level-up (egg, tutor, machine)."""
    if db_cache is not None:
        try:
            learnsets = db_cache.get_cached_learnsets()
            if learnsets:
                methods = ("egg", "tutor", "machine")
                move_ids_seen = set()
                out = []
                for r in learnsets:
                    if int(r.get("species_id") or -1) != int(species_id) or int(r.get("generation") or 0) != generation:
                        continue
                    m = str(r.get("method") or "").strip().lower()
                    if m not in methods:
                        continue
                    move_id = r.get("move_id")
                    if move_id in move_ids_seen:
                        continue
                    move_ids_seen.add(move_id)
                    move = db_cache.get_cached_move(str(move_id)) if move_id is not None else None
                    name = (move.get("name") if move else None) or ""
                    if name:
                        out.append(name.replace("-", " ").title())
                if out:
                    return sorted(out)
        except Exception:
            pass
    conn = await db.connect()
    try:
        cur = await conn.execute("""
            SELECT DISTINCT m.name
            FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE l.species_id = ? AND l.generation = ?
              AND LOWER(TRIM(l.method)) IN ('egg', 'tutor', 'machine')
            ORDER BY m.name
        """, (species_id, generation))
        rows = await cur.fetchall()
        await cur.close()
        return [r["name"].replace("-", " ").title() for r in rows]
    except Exception:
        return []
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _set_held_item(owner_id: str, mon_id: int, item_id: str | None) -> None:
    if hasattr(db, "set_held_item"):
        return await db.set_held_item(owner_id, mon_id, item_id)
    conn = await db.connect()
    try:
        await conn.execute("UPDATE pokemons SET held_item=? WHERE owner_id=? AND id=?",
                           (item_id, owner_id, mon_id))
        await conn.commit()
        db.invalidate_pokemons_cache(owner_id)
    finally:
        try:
            await conn.close()
        except Exception:
            pass


async def _set_pokemon_moves(owner_id: str, mon_id: int, moves: list[str]) -> None:
    if hasattr(db, "set_pokemon_moves"):
        return await db.set_pokemon_moves(owner_id, mon_id, moves[:4])
    conn = await db.connect()
    try:
        base_pps = []
        for m in moves[:4]:
            pp_val = None
            try:
                if db_cache is not None:
                    cached = db_cache.get_cached_move(m) or db_cache.get_cached_move(m.lower()) or db_cache.get_cached_move(m.lower().replace(" ", "-"))
                    if cached and cached.get("pp") is not None:
                        pp_val = int(cached["pp"])
            except Exception:
                pp_val = None
            base_pps.append(int(pp_val) if pp_val is not None else 20)
        try:
            await conn.execute(
                "UPDATE pokemons SET moves=?, moves_pp=?, moves_pp_min=?, moves_pp_max=? WHERE owner_id=? AND id=?",
                (
                    json.dumps(moves[:4], ensure_ascii=False),
                    json.dumps(base_pps, ensure_ascii=False),
                    json.dumps([0] * len(base_pps), ensure_ascii=False),
                    json.dumps(base_pps, ensure_ascii=False),
                    owner_id,
                    mon_id,
                ),
            )
        except Exception:
            await conn.execute(
                "UPDATE pokemons SET moves=?, moves_pp=? WHERE owner_id=? AND id=?",
                (json.dumps(moves[:4], ensure_ascii=False), json.dumps(base_pps, ensure_ascii=False), owner_id, mon_id),
            )
        await conn.commit()
        db.invalidate_pokemons_cache(owner_id)
    finally:
        try:
            await conn.close()
        except Exception:
            pass
# ------------------------ Views ------------------------
class OakIntroView(discord.ui.View):
    def __init__(self, author_id: int, timeout: float = 120):
        super().__init__(timeout=timeout)
        self.author_id = author_id
        for label in ("Boy", "Girl"):
            self.add_item(self._make_gender_button(label))

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    def _make_gender_button(self, label: str) -> discord.ui.Button:
        async def cb(itx: discord.Interaction):
            if not self._guard(itx):
                return await itx.response.send_message("This isn‚Äôt for you.", ephemeral=True)

            emb = discord.Embed(title="Welcome Trainer to Kanto")
            emb.description = (
                "Our world is full of mysterious creatures called pokemons. "
                "At the age of 10 most new trainers go for an adventure to travel across the region and discover new pokemons!\n\n"
                "**Do you want to begin your journey?**"
            )
            emb.set_thumbnail(url=OAK_IMAGE_URL)
            # Persist trainer gender selection (best-effort)
            try:
                gender_value = "boy" if label.lower().startswith("b") else "girl"
                async with db.session() as conn:
                    await conn.execute(
                        "INSERT INTO users (user_id, user_gender) VALUES (?, ?) "
                        "ON CONFLICT (user_id) DO UPDATE SET user_gender = EXCLUDED.user_gender",
                        (str(itx.user.id), gender_value),
                    )
            except Exception:
                pass

            await itx.response.edit_message(embed=emb, view=self._make_yesno_view())
            await itx.followup.send(f"Confirmed you are **{label}**", ephemeral=False)

        btn = discord.ui.Button(label=label, style=discord.ButtonStyle.secondary, custom_id=f"gender:{label}")
        btn.callback = cb
        return btn

    def _make_yesno_view(self) -> discord.ui.View:
        view = discord.ui.View(timeout=60)

        async def yes_cb(itx):
            if not self._guard(itx):
                return await itx.response.send_message("This isn‚Äôt for you.", ephemeral=True)

            starter_embed = discord.Embed(title="Alright, let‚Äôs go!!!")
            starter_embed.description = (
                "As a gift, choose one of these Pok√©mon.\n\n"
                "**Charmander** ‚Äî fire type\n"
                "**Bulbasaur** ‚Äî grass type\n"
                "**Squirtle** ‚Äî water type\n\n"
                "_You also get 6√ó Pok√© Balls._"
            )
            starter_embed.set_image(url=STARTER_PICK_IMAGE_URL)

            await itx.response.edit_message(
                content=None,
                embed=starter_embed,
                view=StarterView(self.author_id)
            )

        async def no_cb(itx):
            if not self._guard(itx):
                return await itx.response.send_message("This isn‚Äôt for you.", ephemeral=True)
            await itx.response.edit_message(
                content="No worries. Come back with `/start` when you‚Äôre ready.",
                embed=None,
                view=None
            )

        yes_btn = discord.ui.Button(label="Yes", style=discord.ButtonStyle.success, custom_id="begin:yes")
        no_btn  = discord.ui.Button(label="No",  style=discord.ButtonStyle.danger,  custom_id="begin:no")
        yes_btn.callback = yes_cb
        no_btn.callback  = no_cb
        view.add_item(yes_btn)
        view.add_item(no_btn)
        return view


class EvolutionConfirmView(discord.ui.View):
    """Yes/No view for level-up evolution prompt. One view per Pok√©mon."""

    def __init__(self, author_id: int, owner_id: str, mon_db_id: int, current_species: str, evolved_species: str, level: int, timeout: float = 120):
        super().__init__(timeout=timeout)
        self.author_id = author_id
        self.owner_id = owner_id
        self.mon_db_id = mon_db_id
        self.current_species = (current_species or "").replace("-", " ").title()
        self.evolved_species = (evolved_species or "").replace("-", " ").title()
        self.level = level
        self._handled = False

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    @discord.ui.button(label="Yes", style=discord.ButtonStyle.success, custom_id="evo:yes")
    async def yes_btn(self, itx: discord.Interaction, button: discord.ui.Button):
        if not self._guard(itx):
            await itx.response.send_message("This evolution prompt isn't for you.", ephemeral=True)
            return
        if self._handled:
            await itx.response.defer()
            return
        self._handled = True
        ok = await _apply_evolution(self.owner_id, self.mon_db_id, self.evolved_species, self.level)
        if ok:
            await itx.response.edit_message(
                embed=discord.Embed(
                    description=f"Congratulations! Your **{self.current_species}** evolved into **{self.evolved_species}**!",
                    color=0x57F287,
                ),
                view=None,
            )
        else:
            await itx.response.edit_message(
                embed=discord.Embed(description="Evolution could not be applied.", color=0xED4245),
                view=None,
            )

    @discord.ui.button(label="No", style=discord.ButtonStyle.danger, custom_id="evo:no")
    async def no_btn(self, itx: discord.Interaction, button: discord.ui.Button):
        if not self._guard(itx):
            await itx.response.send_message("This evolution prompt isn't for you.", ephemeral=True)
            return
        if self._handled:
            await itx.response.defer()
            return
        self._handled = True
        await itx.response.edit_message(
            embed=discord.Embed(
                description=f"Your **{self.current_species}** did not evolve!",
                color=0xED4245,
            ),
            view=None,
        )


class StarterView(discord.ui.View):
    PIKA_LABELS = [
        "Pikachu",
        "I don't want these",
        "Give me Pikachu",
        "I'll catch them all!"
    ]
    
    # Class-level dict to track users currently picking starters
    _picking_in_progress: set = set()

    def __init__(self, author_id: int, timeout: float = 120, pikachu_state: int = 0):
        super().__init__(timeout=timeout)
        self.author_id = author_id
        self.pikachu_state = pikachu_state
        self.picked = False  # Instance flag to prevent double-pick
        self.add_item(self._make_pick_button("Bulbasaur"))
        self.add_item(self._make_pick_button("Charmander"))
        self.add_item(self._make_pick_button("Squirtle"))
        self.add_item(self._make_pikachu_button())

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    def _disable_all(self):
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                child.disabled = True

    def _make_pick_button(self, species: str) -> discord.ui.Button:
        async def cb(itx: discord.Interaction):
            if not self._guard(itx):
                return await itx.response.send_message("This menu isn‚Äôt for you.", ephemeral=True)

            # disable all buttons immediately to prevent double-picks
            self._disable_all()
            try:
                await itx.response.edit_message(view=self)
            except Exception:
                pass

            try:
                await self._finalize_pick(itx, species)
            except Exception as e:
                import traceback
                traceback.print_exc()
                try:
                    details = f"{type(e).__name__}: {e!r}"
                    if getattr(db, "DB_IS_POSTGRES", False) and "hp_now" in str(e):
                        try:
                            async with db.session() as conn:
                                await _ensure_pg_pokemons_columns(conn)
                        except Exception:
                            pass
                        await itx.followup.send(
                            f"Error while giving {species}: {details}\n"
                            "Tried to auto-fix schema (missing hp_now). Please retry /start.",
                            ephemeral=True,
                        )
                    else:
                        await itx.followup.send(
                            f"Error while giving {species}: {details}",
                            ephemeral=True,
                        )
                except Exception:
                    pass

        btn = discord.ui.Button(label=species, style=discord.ButtonStyle.primary, custom_id=f"starter:{species}")
        btn.callback = cb
        return btn

    def _make_pikachu_button(self) -> discord.ui.Button:
        label = self.PIKA_LABELS[self.pikachu_state]
        style = discord.ButtonStyle.secondary if self.pikachu_state < 3 else discord.ButtonStyle.success
        btn = discord.ui.Button(label=label, style=style, custom_id=f"starter:pikachu:{self.pikachu_state}")

        async def cb(itx: discord.Interaction):
            if not self._guard(itx):
                return await itx.response.send_message("This menu isn‚Äôt for you.", ephemeral=True)

            # If we‚Äôre still in the ‚Äútease‚Äù states, just advance the state,
            # otherwise finalize with Pikachu. We also disable buttons when finalizing.
            await itx.response.defer(ephemeral=True, thinking=False)

            if self.pikachu_state == 0:
                return await itx.edit_original_response(view=StarterView(self.author_id, pikachu_state=1))
            if self.pikachu_state == 1:
                return await itx.edit_original_response(view=StarterView(self.author_id, pikachu_state=2))
            if self.pikachu_state == 2:
                return await itx.edit_original_response(view=StarterView(self.author_id, pikachu_state=3))

            # Final: pick Pikachu
            self._disable_all()
            try:
                await itx.edit_original_response(view=self)
            except Exception:
                pass
            try:
                await self._finalize_pick(itx, "Pikachu")
            except Exception as e:
                import traceback
                traceback.print_exc()
                try:
                    details = f"{type(e).__name__}: {e!r}"
                    if getattr(db, "DB_IS_POSTGRES", False) and "hp_now" in str(e):
                        try:
                            async with db.session() as conn:
                                await _ensure_pg_pokemons_columns(conn)
                        except Exception:
                            pass
                        await itx.followup.send(
                            f"Error while giving Pikachu: {details}\n"
                            "Tried to auto-fix schema (missing hp_now). Please retry /start.",
                            ephemeral=True,
                        )
                    else:
                        await itx.followup.send(
                            f"Error while giving Pikachu: {details}",
                            ephemeral=True,
                        )
                except Exception:
                    pass

        btn.callback = cb
        return btn

    async def _finalize_pick(self, itx: discord.Interaction, species: str):
        uid = str(itx.user.id)
        starter_ball_item_id = item_id_from_user("poke ball")
        starter_balls_granted = False
        
        # Prevent double-pick (instance-level)
        if self.picked:
            return await itx.followup.send("You already picked a starter from this menu.", ephemeral=False)
        
        # Prevent race condition from multiple /start commands (class-level)
        if uid in StarterView._picking_in_progress:
            return await itx.followup.send("You're already picking a starter in another menu!", ephemeral=False)
        
        StarterView._picking_in_progress.add(uid)
        self.picked = True
        
        try:
            try:
                await itx.followup.send("‚è≥ Creating your profile, please wait‚Ä¶", ephemeral=False)
            except Exception:
                pass

            # ensure user exists + is in gen 1
            await _ensure_user_in_gen1(uid)

            if not await db.get_user(uid):
                await db.create_user(uid)

            # one-time only starter
            try:
                if hasattr(db, "has_starter") and await db.has_starter(uid):
                    return await itx.followup.send("You already picked a starter.", ephemeral=False)
            except Exception:
                pass

            # fetch cache row (prefer in-memory cache to avoid slow DB/network)
            try:
                entry = None
                if db_cache is not None:
                    entry = db_cache.get_cached_pokedex(species) or db_cache.get_cached_pokedex(species.lower())
                    if not entry:
                        entry = db_cache.get_cached_pokedex(species.replace(" ", "-"))
                if not entry:
                    entry = await ensure_species_and_learnsets(species)
            except Exception as e:
                return await itx.followup.send(f"PokeAPI/cache error: {e}", ephemeral=False)

            # decode + normalize stats
            def _j(v, d):
                return json.loads(v) if isinstance(v, str) else (v if v is not None else d)
            raw_stats   = _j(entry.get("stats"), {})
            base_stats  = _normalize_stats_for_generator(raw_stats)
            abilities   = _j(entry.get("abilities"), [])
            species_types = _extract_species_types(entry)
            gender_ratio = _j(entry.get("gender_ratio"), None)

            # derive gender ratio fallback
            if not gender_ratio:
                gr = entry.get("gender_rate")
                if isinstance(gr, str):
                    try: gr = json.loads(gr)
                    except Exception: pass
                if isinstance(gr, int):
                    if gr == -1:
                        gender_ratio = {"genderless": True}
                    else:
                        female = gr * 12.5
                        gender_ratio = {"male": 100 - female, "female": female}
            if not gender_ratio:
                gender_ratio = {"male": 50, "female": 50}

            # roll HA + shiny (you already have these helpers)
            ability_name, is_hidden = roll_hidden_ability(abilities, ha_denominator=50)
            is_shiny = await shiny_roll()
            # roll gender from the Pok√©dex ratio and make it authoritative
            rolled_gender = _roll_gender_from_ratio(gender_ratio)
            # generate, then override with rolls
            mon = generate_mon(
                base_stats   = base_stats,
                abilities    = abilities,
                gender_ratio = gender_ratio,
                level        = 5
            )
            if ability_name:
                mon["ability"] = ability_name
            mon["is_hidden_ability"] = bool(is_hidden)
            mon["is_shiny"] = bool(is_shiny)
            mon["gender"] = rolled_gender
            tera_type = _roll_default_tera_type(species_types)
            # Friendship (avoid extra DB call; use Pokedex data)
            bf = entry.get("base_happiness")
            if bf is None:
                bf = entry.get("base_friendship")
            try:
                base_friend = int(bf) if bf is not None else 70
            except Exception:
                base_friend = 70
            # Precompute level-up moves from cache if possible (avoid DB round-trip)
            cached_moves: list[str] | None = None
            cached_pps: list[int] | None = None
            try:
                if db_cache is not None:
                    learnsets = db_cache.get_cached_learnsets()
                    if learnsets:
                        species_id = entry.get("id")
                        if species_id is not None:
                            rows = [
                                r for r in learnsets
                                if int(r.get("species_id") or -1) == int(species_id)
                                and int(r.get("generation") or 0) == 1
                                and str(r.get("method") or "").lower() == "level-up"
                                and int(r.get("level_learned") or 0) <= 5
                            ]
                            rows.sort(key=lambda r: (int(r.get("level_learned") or 0), str(r.get("move_id") or "")))
                            rows = list(reversed(rows))
                            seen = set()
                            out = []
                            for r in rows:
                                move_id = r.get("move_id")
                                move = db_cache.get_cached_move(str(move_id)) if move_id is not None else None
                                name = (move.get("name") if move else None) or ""
                                if name:
                                    name = name.replace("-", " ").title()
                                    if name not in seen:
                                        seen.add(name)
                                        out.append(name)
                                if len(out) >= 4:
                                    break
                            cached_moves = out if out else None
                            if cached_moves:
                                pps = []
                                for m in cached_moves:
                                    mv = db_cache.get_cached_move(m) or db_cache.get_cached_move(m.lower()) or db_cache.get_cached_move(m.lower().replace(" ", "-"))
                                    if mv and mv.get("pp") is not None:
                                        try:
                                            pps.append(int(mv["pp"]))
                                        except Exception:
                                            pps.append(20)
                                    else:
                                        pps.append(20)
                                cached_pps = pps
            except Exception:
                cached_moves = None
                cached_pps = None

            # insert & setup (single DB session for speed)
            try:
                for attempt in range(2):
                    try:
                        async with db.session() as conn:
                            try:
                                await _ensure_pg_pokemons_columns(conn)
                                col_flags = await _pg_pokemons_column_flags(conn)
                                await _tx_begin(conn)
                                await conn.execute(
                                    "INSERT INTO users (user_id, starter, coins, currencies) VALUES (?, ?, 6000, '{\"coins\": 6000}'::jsonb) "
                                    "ON CONFLICT (user_id) DO UPDATE SET starter = EXCLUDED.starter, "
                                    "currencies = CASE WHEN COALESCE((users.currencies->>'coins')::int, 0) = 0 THEN jsonb_set(COALESCE(users.currencies, '{}'::jsonb), '{coins}', '6000'::jsonb) ELSE users.currencies END",
                                    (uid, species),
                                )

                                empty_moves_json = json.dumps([], ensure_ascii=False)
                                exp_group = await _get_exp_group_for_species(conn, entry["name"])
                                initial_exp = await _get_exp_total_for_level(conn, exp_group, 5)
                                cols = [
                                    "owner_id", "species", "level",
                                    "hp", "atk", "def", "spa", "spd", "spe",
                                    "ivs", "evs", "nature", "ability", "gender",
                                    "moves", "form", "can_gigantamax", "tera_type", "friendship",
                                    "exp", "exp_group",
                                ]
                                vals = [
                                    uid, entry["name"], 5,
                                    int(mon["stats"]["hp"]),
                                    int(mon["stats"]["attack"]),
                                    int(mon["stats"]["defense"]),
                                    int(mon["stats"]["special_attack"]),
                                    int(mon["stats"]["special_defense"]),
                                    int(mon["stats"]["speed"]),
                                    json.dumps(mon["ivs"], ensure_ascii=False),
                                    json.dumps(mon["evs"], ensure_ascii=False),
                                    mon["nature"],
                                    mon["ability"],
                                    rolled_gender,
                                    empty_moves_json,
                                    None,
                                    False,
                                    tera_type,
                                    int(base_friend),
                                    initial_exp, exp_group,
                                ]
                                if col_flags.get("hp_now"):
                                    cols.insert(4, "hp_now")
                                    vals.insert(4, int(mon["stats"]["hp"]))
                                if col_flags.get("shiny"):
                                    cols.append("shiny")
                                    vals.append(1 if is_shiny else 0)
                                if col_flags.get("is_hidden_ability"):
                                    cols.append("is_hidden_ability")
                                    vals.append(1 if is_hidden else 0)
                                placeholders = ", ".join(["?"] * len(cols))
                                cur = await conn.execute(
                                    f"INSERT INTO pokemons ({', '.join(cols)}) VALUES ({placeholders})",
                                    tuple(vals),
                                )
                                pid = int(cur.lastrowid)
                                await cur.close()

                                # Give 6 Pok√© Balls (ensure item master row exists first to satisfy FK).
                                try:
                                    await conn.execute(
                                        """
                                        INSERT INTO items (id, name)
                                        VALUES (?, ?)
                                        ON CONFLICT (id) DO UPDATE SET
                                            name = COALESCE(items.name, EXCLUDED.name)
                                        """,
                                        (starter_ball_item_id, "Pok√© Ball"),
                                    )
                                except Exception:
                                    pass
                                try:
                                    await conn.execute(
                                        """
                                        INSERT INTO user_items (owner_id, item_id, qty)
                                        VALUES (?, ?, ?)
                                        ON CONFLICT(owner_id, item_id)
                                        DO UPDATE SET qty = user_items.qty + excluded.qty
                                        """,
                                        (uid, starter_ball_item_id, 6),
                                    )
                                    db.invalidate_bag_cache(uid)
                                    starter_balls_granted = True
                                except Exception:
                                    starter_balls_granted = False

                                # learn level-up moves for user's selected gen
                                try:
                                    moves = cached_moves
                                    pps = cached_pps
                                    if not moves:
                                        species_id = entry.get("id")
                                        if not species_id:
                                            cur = await conn.execute("SELECT id FROM pokedex WHERE LOWER(name)=LOWER(?)", (entry["name"].lower(),))
                                            srow = await cur.fetchone(); await cur.close()
                                            species_id = int(srow["id"]) if srow else None
                                        if species_id:
                                            cur = await conn.execute("""
                                                SELECT m.name, COALESCE(l.level_learned, 0) AS lvl, m.pp AS pp
                                                FROM learnsets l
                                                JOIN moves m ON m.id = l.move_id
                                                WHERE l.species_id = ? AND l.generation = ? AND l.method = 'level-up'
                                                      AND COALESCE(l.level_learned, 0) <= ?
                                                ORDER BY lvl DESC, m.name
                                                LIMIT 40
                                            """, (species_id, 1, 5))
                                            rows = await cur.fetchall(); await cur.close()
                                            seen, moves, pps = set(), [], []
                                            for r in rows:
                                                name = r["name"].replace("-", " ").title()
                                                if name not in seen:
                                                    seen.add(name); moves.append(name)
                                                    try:
                                                        pp_val = r["pp"]
                                                        pps.append(int(pp_val) if pp_val is not None else 20)
                                                    except Exception:
                                                        pps.append(20)
                                                if len(moves) == 4:
                                                    break
                                    if not moves:
                                        moves = ["Tackle"]
                                        pps = [20]
                                    if col_flags.get("moves_pp"):
                                        pp_vals = pps or [20] * len(moves)
                                        if col_flags.get("moves_pp_min") and col_flags.get("moves_pp_max"):
                                            await conn.execute(
                                                "UPDATE pokemons SET moves=?, moves_pp=?, moves_pp_min=?, moves_pp_max=? WHERE owner_id=? AND id=?",
                                                (
                                                    json.dumps(moves, ensure_ascii=False),
                                                    json.dumps(pp_vals, ensure_ascii=False),
                                                    json.dumps([0] * len(pp_vals), ensure_ascii=False),
                                                    json.dumps(pp_vals, ensure_ascii=False),
                                                    uid,
                                                    pid,
                                                ),
                                            )
                                        else:
                                            await conn.execute(
                                                "UPDATE pokemons SET moves=?, moves_pp=? WHERE owner_id=? AND id=?",
                                                (json.dumps(moves, ensure_ascii=False), json.dumps(pp_vals, ensure_ascii=False), uid, pid),
                                            )
                                    else:
                                        await conn.execute(
                                            "UPDATE pokemons SET moves=? WHERE owner_id=? AND id=?",
                                            (json.dumps(moves, ensure_ascii=False), uid, pid),
                                        )
                                except Exception:
                                    pass

                                # put into first free team slot
                                try:
                                    cur = await conn.execute(
                                        "SELECT team_slot FROM pokemons WHERE owner_id=? AND team_slot BETWEEN 1 AND 6",
                                        (uid,),
                                    )
                                    used = {int(r[0]) for r in await cur.fetchall()}
                                    await cur.close()
                                    slot = next((s for s in range(1, 7) if s not in used), None)
                                    if slot is not None:
                                        await conn.execute(
                                            "UPDATE pokemons SET team_slot=? WHERE owner_id=? AND id=?",
                                            (slot, uid, pid),
                                        )
                                except Exception:
                                    pass

                                # Grant 6000 Pok√©Dollars on start (only if not already set)
                                try:
                                    await conn.execute(
                                        "UPDATE users SET currencies = jsonb_set(COALESCE(NULLIF(currencies::text, 'null')::jsonb, '{}'::jsonb), '{coins}', '6000'::jsonb) WHERE user_id = ? AND COALESCE((currencies->>'coins')::int, 0) = 0",
                                        (uid,),
                                    )
                                except Exception:
                                    pass

                                await _tx_commit(conn)
                                db.invalidate_pokemons_cache(uid)
                            except Exception:
                                await _tx_rollback(conn)
                                raise
                        break
                    except (TimeoutError, asyncio.TimeoutError):
                        if attempt == 0:
                            await asyncio.sleep(1.5)
                            continue
                        raise
            except Exception as e:
                return await itx.followup.send(f"Insert error: {e!r}", ephemeral=False)

            # Safety net: ensure the starter flag and 6000 Pok√©Dollars are persisted (handles edge cases where the UPSERT was rolled back).
            try:
                async with db.session() as conn:
                    await conn.execute(
                        "UPDATE users SET starter = COALESCE(starter, ?) WHERE user_id = ?",
                        (species, uid),
                    )
                    await conn.execute(
                        "UPDATE users SET currencies = jsonb_set(COALESCE(NULLIF(currencies::text, 'null')::jsonb, '{}'::jsonb), '{coins}', '6000'::jsonb) WHERE user_id = ? AND COALESCE((currencies->>'coins')::int, 0) = 0",
                        (uid,),
                    )
            except Exception:
                pass

            # Safety net: if no Pok√©mon row exists yet, insert the starter into team slot 1.
            try:
                await _ensure_starter_mon_row(uid, species, mon, entry, tera_type=tera_type, base_friend=base_friend)
            except Exception:
                pass

            # Fallback safety net for starter balls if the in-transaction insert failed.
            if not starter_balls_granted:
                try:
                    await db.upsert_item_master(starter_ball_item_id, name="Pok√© Ball")
                    await db.give_item(uid, starter_ball_item_id, 6)
                    starter_balls_granted = True
                except Exception:
                    starter_balls_granted = False

            # remove the view and confirm
            try:
                await itx.edit_original_response(view=None)
            except Exception:
                pass
            balls_line = "üéÅ You also received **6√ó Pok√© Balls**."
            if not starter_balls_granted:
                balls_line = "‚ö†Ô∏è Could not grant starter Pok√© Balls automatically. Please run `/bag` and report this if still missing."
            await itx.followup.send(
                f"‚úÖ You received **{entry['name']}** as your starter!"
                f"{' ‚ú® (Shiny!)' if is_shiny else ''}"
                f"{' (Hidden Ability)' if is_hidden else ''}\n"
                f"{balls_line}",
                ephemeral=True
            )

            # Initialize adventure state and send rival challenge
            try:
                state = await _get_adventure_state(uid)
                state["area_id"] = "pallet-town"
                await _save_adventure_state(uid, state)
            except Exception as e:
                try:
                    print(f"[Adventure] state init failed: {e}")
                except Exception:
                    pass

            try:
                city = ADVENTURE_CITIES["pallet-town"]
                rival_lines = [
                    "**Blue:** I'll take this one, then!",
                    "**Blue:** Heh, my Pok√©mon looks a lot stronger.",
                ]
                rival_text = "\n".join(rival_lines)
                rival_embed, rival_files = _embed_with_image(
                    "Your Rival Appears!",
                    rival_text,
                    city["image_uncleared"],
                )
                teaser_msg = await itx.followup.send(
                    embed=rival_embed,
                    files=rival_files,
                    ephemeral=True,
                    wait=True,
                )

                async def _send_challenge_followup():
                    try:
                        await asyncio.sleep(1.5)
                        preview_desc = f"**Blue:** Wait {itx.user.display_name if hasattr(itx.user, 'display_name') else itx.user.name}! Let's check out our Pok√©mon! Come on, I'll take you on!"
                        preview_emb, preview_files = _embed_with_image("Rival Challenge!", preview_desc, city["image_uncleared"])
                        await teaser_msg.edit(
                            embed=preview_emb,
                            attachments=preview_files,
                            view=RivalIntroView(itx.user.id, "pallet-town"),
                        )
                    except Exception:
                        try:
                            preview_desc = f"**Blue:** Wait {itx.user.display_name if hasattr(itx.user, 'display_name') else itx.user.name}! Let's check out our Pok√©mon! Come on, I'll take you on!"
                            preview_emb, preview_files = _embed_with_image("Rival Challenge!", preview_desc, city["image_uncleared"])
                            await itx.followup.send(embed=preview_emb, files=preview_files, view=RivalIntroView(itx.user.id, "pallet-town"), ephemeral=True)
                        except Exception:
                            pass

                asyncio.create_task(_send_challenge_followup())
            except Exception as e:
                try:
                    print(f"[Adventure] rival intro send failed: {e}")
                except Exception:
                    pass
                # Fallback: send without files/view if attachments fail
                try:
                    city = ADVENTURE_CITIES["pallet-town"]
                    rival_lines = [
                        "**Blue:** I'll take this one, then!",
                        "**Blue:** Heh, my Pok√©mon looks a lot stronger.",
                    ]
                    rival_text = "\n".join(rival_lines)
                    rival_embed, _ = _embed_with_image(
                        "Your Rival Appears!",
                        rival_text,
                        city["image_uncleared"],
                    )
                    await itx.followup.send(
                        embed=rival_embed,
                        ephemeral=True,
                    )
                except Exception:
                    pass
        finally:
            # Always remove from in-progress set, even if error occurs
            StarterView._picking_in_progress.discard(uid)

# =========================
#  Adventure / Routes (Story Mode)
# =========================
ASSETS_DIR = Path(__file__).resolve().parent / "assets"
ASSETS_CITIES = ASSETS_DIR / "cities"
ASSETS_ROUTES = ASSETS_DIR / "routes"
ASSETS_DAYCARE = ASSETS_DIR / "ui" / "daycare.png"
ASSETS_EGG_STAGES_DIR = ASSETS_DIR / "ui" / "egg-stages"
ASSETS_EGG_STAGE_1_INTACT = ASSETS_EGG_STAGES_DIR / "egg-stage-1-intact.png"
ASSETS_EGG_STAGE_2_SLIGHT = ASSETS_EGG_STAGES_DIR / "egg-stage-2-slightly-cracked.png"
ASSETS_EGG_STAGE_3_CRACKED = ASSETS_EGG_STAGES_DIR / "egg-stage-3-cracked.png"
ASSETS_EGG_STAGE_4_MORE = ASSETS_EGG_STAGES_DIR / "egg-stage-4-more-cracked.png"
ASSETS_EGG_STAGE_5_HEAVY = ASSETS_EGG_STAGES_DIR / "egg-stage-5-heavily-cracked.png"
ASSETS_EGG_STAGE_6_EXTREME = ASSETS_EGG_STAGES_DIR / "egg-stage-6-extremely-cracked.png"
ASSETS_DAYCARE_EGG = ASSETS_EGG_STAGE_1_INTACT

DAYCARE_CITY_ID = "viridian-city"
DAYCARE_AREA_ID = "pallet-daycare"
ROUTE_22_ENABLED = False  # Set True to show Route 22 button in Viridian City
DAYCARE_EGG_CAP = 3
DAYCARE_INCUBATE_MAX = 6
DAYCARE_BREED_THRESHOLD = 22.0
DAYCARE_EGG_INTERVAL_SECONDS = 3600.0
DAYCARE_OVAL_CHARM_INTERVAL_MULT = 0.75
DAYCARE_OVAL_CHARM_BONUS_EGG_CHANCE = 0.15
DAYCARE_HATCH_MIN = 45.0
DAYCARE_HATCH_MAX = 80.0
DAYCARE_HATCH_BOOST_ABILITIES = {"flame-body", "magma-armor"}
DAYCARE_HATCH_COMMAND_BONUS_CAP = 0.18
DAYCARE_MIRROR_HERB_ITEMS = {"mirror-herb", "mirror_herb"}
DAYCARE_HATCH_BOOST_CACHE_TTL_SECONDS = 15.0
DAYCARE_OVAL_CHARM_CACHE_TTL_SECONDS = 30.0
DAYCARE_INCENSE_BABIES: dict[str, tuple[str, str]] = {
    "snorlax": ("munchlax", "full-incense"),
    "mr-mime": ("mime-jr", "odd-incense"),
    "chansey": ("happiny", "luck-incense"),
    "blissey": ("happiny", "luck-incense"),
    "roselia": ("budew", "rose-incense"),
    "roserade": ("budew", "rose-incense"),
    "sudowoodo": ("bonsly", "rock-incense"),
    "wobbuffet": ("wynaut", "lax-incense"),
    "marill": ("azurill", "sea-incense"),
    "azumarill": ("azurill", "sea-incense"),
    "chimecho": ("chingling", "pure-incense"),
    "mantine": ("mantyke", "wave-incense"),
}

_DAYCARE_HATCH_BOOST_CACHE: dict[str, tuple[bool, float]] = {}
_DAYCARE_OVAL_CHARM_CACHE: dict[str, tuple[bool, float]] = {}
DAYCARE_MAX_ANIM_FRAMES = 16
DAYCARE_GIF_MAX_SIZE: tuple[int, int] = (56, 56)
DAYCARE_BOX_MAX_SIZE: tuple[int, int] = (52, 52)
DAYCARE_STATIC_MAX_SIZE: tuple[int, int] = (52, 52)
BOX_SPRITES_DIR = Path(__file__).resolve().parent / "pvp" / "_common" / "box_sprites"
LEGACY_SPRITES_DIR = Path(__file__).resolve().parent / "pvp" / "_common" / "sprites"
POKESPRITE_MASTER_ZIP = Path(__file__).resolve().parent / "pokesprite-master.zip"
DAYCARE_ZIP_CACHE_DIR = BOX_SPRITES_DIR / "_pokesprite_zip_cache"
ASSETS_BOX_BACKGROUNDS_DIR = ASSETS_DIR / "ui" / "box-backgrounds"
BOX_SPRITES_BACKGROUNDS_DIR = BOX_SPRITES_DIR / "backgrounds"
BOX_BACKGROUND_FILENAMES: tuple[str, ...] = (
    "box-bg-meadow.png",
    "box-bg-space.png",
    "box-bg-pond.png",
)

ADVENTURE_CITIES = {
    "pallet-town": {
        "name": "Pallet Town",
        "image_uncleared": ASSETS_CITIES / "pallet-town-start.png",
        "image_cleared": ASSETS_CITIES / "pallet-town-cleared.png",
        "next": "route-1",
        "rival_battle": "rival-1",
        "heal": False,
        "sub_areas": [
            ("pallet-pokemon-center", "Pok√©mon Center"),
        ],
    },
    "pallet-pokemon-center": {
        "name": "Pok√©mon Center",
        "parent_city": "pallet-town",
        "image": ASSETS_CITIES / "viridian-pokecenter.png",  # Same image as Viridian
        "heal": True,
    },
    DAYCARE_AREA_ID: {
        "name": "Viridian Daycare",
        "image_uncleared": ASSETS_DAYCARE,
        "image_cleared": ASSETS_DAYCARE,
        "is_daycare": True,
        "heal": True,
    },
    "viridian-city": {
        "name": "Viridian City",
        "image_uncleared": ASSETS_CITIES / "viridian-city-uncleared.png",
        "image_cleared": ASSETS_CITIES / "viridian-city-cleared.png",
        "routes": ["route-2", "route-22"],
        "gym_leader": "viridian",
        "gym_badge": "boulder",
        "gym_closed": True,
        "heal": False,
        # Sub-areas: (area_id, label) - buttons that navigate to buildings with sprite sheet regions
        "sub_areas": [
            ("viridian-pokemon-center", "Pok√©mon Center"),
            ("viridian-pokemart", "Pok√© Mart"),
        ],
    },
    # Viridian City sub-areas - direct images
    "viridian-pokemon-center": {
        "name": "Pok√©mon Center",
        "parent_city": "viridian-city",
        "image": ASSETS_CITIES / "viridian-pokecenter.png",
        "heal": True,
        "daycare_area": DAYCARE_AREA_ID,
        "daycare_label": "Daycare",
    },
    "viridian-pokemart": {
        "name": "Pok√© Mart",
        "parent_city": "viridian-city",
        "image": ASSETS_CITIES / "viridian-pokemart.png",
        "is_pokemart": True,
    },
    "pallet-pokemart": {
        "name": "Pok√© Mart",
        "parent_city": "pallet-town",
        "image": ASSETS_CITIES / "pallet-town-start.png",
        "is_pokemart": True,
    },
}

# Gen 1 TMs (consumable) and HMs (permanent) for TM Machine / TM Seller
GEN1_TMS: List[Tuple[str, str]] = [
    ("tm-01", "Mega Punch"), ("tm-02", "Razor Wind"), ("tm-03", "Swords Dance"), ("tm-04", "Whirlwind"),
    ("tm-05", "Mega Kick"), ("tm-06", "Toxic"), ("tm-07", "Horn Drill"), ("tm-08", "Body Slam"),
    ("tm-09", "Take Down"), ("tm-10", "Double-Edge"), ("tm-11", "Bubble Beam"), ("tm-12", "Water Gun"),
    ("tm-13", "Ice Beam"), ("tm-14", "Blizzard"), ("tm-15", "Hyper Beam"), ("tm-16", "Pay Day"),
    ("tm-17", "Submission"), ("tm-18", "Counter"), ("tm-19", "Seismic Toss"), ("tm-20", "Rage"),
    ("tm-21", "Mega Drain"), ("tm-22", "Solar Beam"), ("tm-23", "Dragon Rage"), ("tm-24", "Thunderbolt"),
    ("tm-25", "Thunder"), ("tm-26", "Earthquake"), ("tm-27", "Fissure"), ("tm-28", "Dig"),
    ("tm-29", "Psychic"), ("tm-30", "Teleport"), ("tm-31", "Mimic"), ("tm-32", "Double Team"),
    ("tm-33", "Reflect"), ("tm-34", "Bide"), ("tm-35", "Metronome"), ("tm-36", "Self-Destruct"),
    ("tm-37", "Egg Bomb"), ("tm-38", "Fire Blast"), ("tm-39", "Swift"), ("tm-40", "Skull Bash"),
    ("tm-41", "Soft-Boiled"), ("tm-42", "Dream Eater"), ("tm-43", "Sky Attack"), ("tm-44", "Rest"),
    ("tm-45", "Thunder Wave"), ("tm-46", "Psywave"), ("tm-47", "Explosion"), ("tm-48", "Rock Slide"),
    ("tm-49", "Tri Attack"), ("tm-50", "Substitute"),
]
GEN1_HMS: List[Tuple[str, str]] = [
    ("hm-01", "Cut"), ("hm-02", "Fly"), ("hm-03", "Surf"), ("hm-04", "Strength"), ("hm-05", "Flash"),
]
TM_FRAGMENT_ITEM_ID = "tm-fragment"  # Rare encounter drop; display name "TM Fragment"
TM_FRAGMENT_DROP_CHANCE = 0.02  # Rolled for every adventure wild win (grass path + /route)
TM_SELLER_PRICE = 500  # Coins per TM (Gen 1)
# Seller has 25 TMs (rolled from 1‚Äì50 via script, fixed)
TM_SELLER_ITEMS = [GEN1_TMS[i - 1] for i in (1, 3, 5, 6, 7, 9, 11, 12, 15, 17, 20, 21, 22, 23, 24, 31, 34, 35, 37, 40, 42, 44, 45, 49, 50)]

# Route move loot-ball encounter rates (absolute percentages per roll, not normalized by table sum).
# Repeat Ball and Timer Ball use special handling in _roll_and_give_route_move_item_async.
ROUTE_MOVE_BALL_ENCOUNTER_RATES: List[Tuple[str, str, float]] = [
    ("poke_ball", "Pok√© Ball", 0.9),
    ("great_ball", "Great Ball", 0.6),
    ("ultra_ball", "Ultra Ball", 0.2),
    ("master_ball", "Master Ball", 0.008),
    ("nest_ball", "Nest Ball", 0.4),
    ("net_ball", "Net Ball", 0.4),
    ("dive_ball", "Dive Ball", 0.4),
    ("heal_ball", "Heal Ball", 0.4),
    ("dusk_ball", "Dusk Ball", 0.4),
    ("dream_ball", "Dream Ball", 0.4),
    ("sport_ball", "Sport Ball", 0.4),
    ("level_ball", "Level Ball", 0.4),
    ("moon_ball", "Moon Ball", 0.4),
    ("friend_ball", "Friend Ball", 0.4),
    ("love_ball", "Love Ball", 0.4),
    ("heavy_ball", "Heavy Ball", 0.4),
    ("fast_ball", "Fast Ball", 0.4),
    ("premier_ball", "Premier Ball", 0.4),
    ("repeat_ball", "Repeat Ball", 0.4),
    ("tm_ball", "TM Ball", 0.4),
    ("great_tm_ball", "Great TM Ball", 0.4),
    ("ultra_tm_ball", "Ultra TM Ball", 0.4),
    ("timer_ball", "Timer Ball", 0.4),
]

ROUTE_MOVE_ITEMS_BY_BALL: Dict[str, List[Tuple[str, str, float]]] = {
    "poke_ball": [
        ("poke_ball", "Pok√© Ball", 15.69),
        ("escape_rope", "Escape Rope", 15.69),
        ("poke_doll", "Pok√© Doll", 15.69),
        ("antidote", "Antidote", 5.88),
        ("burn_heal", "Burn Heal", 5.88),
        ("awakening", "Awakening", 5.88),
        ("paralyze_heal", "Paralyze Heal", 5.88),
        ("ice_heal", "Ice Heal", 5.88),
        ("repel", "Repel", 5.88),
        ("oran_berry", "Oran Berry", 5.88),
        ("tiny_mushroom", "Tiny Mushroom", 5.88),
        ("stardust", "Stardust", 3.92),
        ("potion", "Potion", 1.96),
    ],
    "great_ball": [
        ("great_ball", "Great Ball", 9.52),
        ("antidote", "Antidote", 9.52),
        ("awakening", "Awakening", 9.52),
        ("burn_heal", "Burn Heal", 9.52),
        ("paralyze_heal", "Paralyze Heal", 9.52),
        ("repel", "Repel", 9.52),
        ("berry_juice", "Berry Juice", 9.52),
        ("shoal_shell", "Shoal Shell", 4.76),
        ("shoal_salt", "Shoal Salt", 4.76),
        ("stardust", "Stardust", 4.76),
        ("pearl", "Pearl", 4.76),
        ("super_repel", "Super Repel", 4.76),
        ("super_potion", "Super Potion", 4.76),
    ],
    "ultra_ball": [
        ("ultra_ball", "Ultra Ball", 10.53),
        ("lemonade", "Lemonade", 10.53),
        ("sitrus_berry", "Sitrus Berry", 10.53),
        ("moomoo_milk", "Moomoo Milk", 10.53),
        ("full_heal", "Full Heal", 10.53),
        ("max_repel", "Max Repel", 10.53),
        ("hyper_potion", "Hyper Potion", 5.26),
        ("nugget", "Nugget", 5.26),
        ("revive", "Revive", 5.26),
        ("elixir", "Elixir", 5.26),
        ("leftovers", "Leftovers", 1.05),
    ],
    "master_ball": [
        ("max_elixir", "Max Elixir", 23.26),
        ("revive", "Revive", 23.26),
        ("revival_herb", "Revival Herb", 9.30),
        ("max_revive", "Max Revive", 9.30),
        ("pp_max", "PP Max", 5.81),
        ("master_ball", "Master Ball", 5.81),
    ],
    "nest_ball": [
        ("nest_ball", "Nest Ball", 9.80),
        ("heal_powder", "Heal Powder", 9.80),
        ("lum_berry", "Lum Berry", 9.80),
        ("berry_juice", "Berry Juice", 9.80),
        ("energy_powder", "Energy Powder", 9.80),
        ("sitrus_berry", "Sitrus Berry", 9.80),
        ("stick", "Stick", 9.80),
        ("leaf_stone", "Leaf Stone", 4.90),
        ("miracle_seed", "Miracle Seed", 4.90),
        ("energy_root", "Energy Root", 4.90),
        ("silver_powder", "Silver Powder", 4.90),
        ("bright_powder", "Bright Powder", 4.90),
        ("revival_herb", "Revival Herb", 0.98),
        ("leftovers", "Leftovers", 0.98),
    ],
    "net_ball": [
        ("net_ball", "Net Ball", 22.22),
        ("super_potion", "Super Potion", 22.22),
        ("silver_powder", "Silver Powder", 11.11),
        ("mystic_water", "Mystic Water", 11.11),
        ("sharp_beak", "Sharp Beak", 11.11),
        ("pearl", "Pearl", 11.11),
        ("nugget", "Nugget", 11.11),
    ],
    "dive_ball": [
        ("dive_ball", "Dive Ball", 10.64),
        ("fresh_water", "Fresh Water", 10.64),
        ("soda_pop", "Soda Pop", 10.64),
        ("lemonade", "Lemonade", 10.64),
        ("moomoo_milk", "Moomoo Milk", 10.64),
        ("sea_incense", "Sea Incense", 10.64),
        ("deep_sea_tooth", "Deep Sea Tooth", 10.64),
        ("deep_sea_scale", "Deep Sea Scale", 10.64),
        ("zinc", "Zinc", 2.14),
        ("helix_fossil", "Helix Fossil", 2.14),
        ("dome_fossil", "Dome Fossil", 2.14),
    ],
    "heal_ball": [
        ("heal_ball", "Heal Ball", 18.18),
        ("potion", "Potion", 18.18),
        ("super_potion", "Super Potion", 14.55),
        ("moomoo_milk", "Moomoo Milk", 14.55),
        ("full_heal", "Full Heal", 14.55),
        ("hyper_potion", "Hyper Potion", 5.45),
        ("max_potion", "Max Potion", 5.45),
        ("full_restore", "Full Restore", 5.45),
        ("revive", "Revive", 5.45),
        ("hp_up", "HP Up", 5.45),
    ],
    "dusk_ball": [
        ("dusk_ball", "Dusk Ball", 12.66),
        ("super_potion", "Super Potion", 12.66),
        ("ether", "Ether", 12.66),
        ("lava_cookie", "Lava Cookie", 12.66),
        ("stardust", "Stardust", 12.66),
        ("pearl", "Pearl", 12.66),
        ("black_flute", "Black Flute", 3.80),
        ("spell_tag", "Spell Tag", 3.80),
        ("black_glasses", "Black Glasses", 3.80),
    ],
    "dream_ball": [
        ("dream_ball", "Dream Ball", 10.75),
        ("awakening", "Awakening", 10.75),
        ("chesto_berry", "Chesto Berry", 10.75),
        ("super_potion", "Super Potion", 10.75),
        ("ether", "Ether", 10.75),
        ("lava_cookie", "Lava Cookie", 10.75),
        ("smoke_ball", "Smoke Ball", 10.75),
        ("stardust", "Stardust", 10.75),
        ("pearl", "Pearl", 3.23),
        ("twisted_spoon", "Twisted Spoon", 3.23),
    ],
    "sport_ball": [
        ("sport_ball", "Sport Ball", 5.43),
        ("black_belt", "Black Belt", 5.43),
        ("black_glasses", "Black Glasses", 5.43),
        ("bright_powder", "Bright Powder", 5.43),
        ("mystic_water", "Mystic Water", 5.43),
        ("miracle_seed", "Miracle Seed", 5.43),
        ("charcoal", "Charcoal", 5.43),
        ("spell_tag", "Spell Tag", 5.43),
        ("never_melt_ice", "Never Melt Ice", 5.43),
        ("soft_sand", "Soft Sand", 5.43),
        ("metal_coat", "Metal Coat", 5.43),
        ("sharp_beak", "Sharp Beak", 5.43),
        ("silk_scarf", "Silk Scarf", 5.43),
        ("poison_barb", "Poison Barb", 5.43),
        ("twisted_spoon", "Twisted Spoon", 5.43),
        ("dragon_fang", "Dragon Fang", 5.43),
        ("hard_stone", "Hard Stone", 5.43),
        ("magnet", "Magnet", 5.43),
        ("choice_band", "Choice Band", 2.17),
    ],
    "tm_ball": [
        ("tm-04", "Whirlwind", 6.67),
        ("tm-06", "Toxic", 6.67),
        ("tm-08", "Body Slam", 6.67),
        ("tm-09", "Take Down", 6.67),
        ("tm-11", "Bubble Beam", 6.67),
        ("tm-12", "Water Gun", 6.67),
        ("tm-20", "Rage", 6.67),
        ("tm-31", "Mimic", 6.67),
        ("tm-32", "Double Team", 6.67),
        ("tm-33", "Reflect", 6.67),
        ("tm-39", "Swift", 6.67),
        ("tm-44", "Rest", 6.67),
        ("tm-45", "Thunder Wave", 6.67),
        ("tm-48", "Rock Slide", 6.67),
        ("tm-50", "Substitute", 6.67),
    ],
    "great_tm_ball": [
        ("tm-03", "Swords Dance", 6.25),
        ("tm-05", "Mega Kick", 6.25),
        ("tm-13", "Ice Beam", 6.25),
        ("tm-14", "Blizzard", 6.25),
        ("tm-17", "Submission", 6.25),
        ("tm-21", "Mega Drain", 6.25),
        ("tm-22", "Solar Beam", 6.25),
        ("tm-23", "Dragon Rage", 6.25),
        ("tm-24", "Thunderbolt", 6.25),
        ("tm-25", "Thunder", 6.25),
        ("tm-26", "Earthquake", 6.25),
        ("tm-28", "Dig", 6.25),
        ("tm-29", "Psychic", 6.25),
        ("tm-38", "Fire Blast", 6.25),
        ("tm-42", "Dream Eater", 6.25),
        ("tm-49", "Tri Attack", 6.25),
    ],
    "ultra_tm_ball": [
        ("tm-01", "Mega Punch", 5.26),
        ("tm-02", "Razor Wind", 5.26),
        ("tm-07", "Horn Drill", 5.26),
        ("tm-10", "Double-Edge", 5.26),
        ("tm-15", "Hyper Beam", 5.26),
        ("tm-16", "Pay Day", 5.26),
        ("tm-18", "Counter", 5.26),
        ("tm-19", "Seismic Toss", 5.26),
        ("tm-27", "Fissure", 5.26),
        ("tm-30", "Teleport", 5.26),
        ("tm-34", "Bide", 5.26),
        ("tm-35", "Metronome", 5.26),
        ("tm-36", "Self-Destruct", 5.26),
        ("tm-37", "Egg Bomb", 5.26),
        ("tm-40", "Skull Bash", 5.26),
        ("tm-41", "Soft-Boiled", 5.26),
        ("tm-43", "Sky Attack", 5.26),
        ("tm-46", "Psywave", 5.26),
        ("tm-47", "Explosion", 5.26),
    ],
    "level_ball": [
        ("fire_stone", "Fire Stone", 8.85),
        ("water_stone", "Water Stone", 8.85),
        ("leaf_stone", "Leaf Stone", 8.85),
        ("thunder_stone", "Thunder Stone", 8.85),
        ("moon_stone", "Moon Stone", 8.85),
        ("sun_stone", "Sun Stone", 8.85),
        ("metal_coat", "Metal Coat", 8.85),
        ("kings_rock", "King's Rock", 8.85),
        ("up_grade", "Up-Grade", 8.85),
        ("dragon_scale", "Dragon Scale", 8.85),
        ("rare_candy", "Rare Candy", 2.65),
    ],
    "moon_ball": [
        ("berry_juice", "Berry Juice", 8.55),
        ("ether", "Ether", 8.55),
        ("shoal_shell", "Shoal Shell", 8.55),
        ("shoal_salt", "Shoal Salt", 8.55),
        ("stardust", "Stardust", 8.55),
        ("pearl", "Pearl", 8.55),
        ("super_repel", "Super Repel", 8.55),
        ("super_potion", "Super Potion", 8.55),
        ("spell_tag", "Spell Tag", 5.98),
    ],
    "friend_ball": [
        ("cheri_berry", "Cheri Berry", 4.0),
        ("chesto_berry", "Chesto Berry", 4.0),
        ("pecha_berry", "Pecha Berry", 4.0),
        ("rawst_berry", "Rawst Berry", 4.0),
        ("aspear_berry", "Aspear Berry", 4.0),
        ("persim_berry", "Persim Berry", 4.0),
        ("sitrus_berry", "Sitrus Berry", 4.0),
        ("aguav_berry", "Aguav Berry", 4.0),
        ("figy_berry", "Figy Berry", 4.0),
        ("iapapa_berry", "Iapapa Berry", 4.0),
        ("lum_berry", "Lum Berry", 4.0),
        ("liechi_berry", "Liechi Berry", 4.0),
        ("salac_berry", "Salac Berry", 4.0),
        ("lansat_berry", "Lansat Berry", 4.0),
        ("starf_berry", "Starf Berry", 4.0),
        ("__bonus_berry__", "Bonus Berry", 4.0),
    ],
    "love_ball": [
        ("everstone", "Everstone", 7.69),
        ("destiny_knot", "Destiny Knot", 7.69),
        ("oval_stone", "Oval Stone", 7.69),
        ("lax_incense", "Lax Incense", 7.69),
        ("sea_incense", "Sea Incense", 7.69),
        ("heart_scale", "Heart Scale", 7.69),
        ("power_weight", "Power Weight", 7.69),
        ("power_bracer", "Power Bracer", 7.69),
        ("power_belt", "Power Belt", 7.69),
        ("power_lens", "Power Lens", 7.69),
        ("power_band", "Power Band", 7.69),
        ("macho_brace", "Macho Brace", 7.69),
    ],
    "heavy_ball": [
        ("super_potion", "Super Potion", 10.64),
        ("lemonade", "Lemonade", 10.64),
        ("hard_stone", "Hard Stone", 10.64),
        ("everstone", "Everstone", 10.64),
        ("metal_coat", "Metal Coat", 5.32),
        ("pp_up", "PP Up", 5.32),
        ("dome_fossil", "Dome Fossil", 1.06),
        ("helix_fossil", "Helix Fossil", 1.06),
        ("old_amber", "Old Amber", 1.06),
    ],
    "fast_ball": [
        ("fresh_water", "Fresh Water", 10.53),
        ("soda_pop", "Soda Pop", 10.53),
        ("thunder_stone", "Thunder Stone", 10.53),
        ("pearl", "Pearl", 10.53),
        ("stardust", "Stardust", 10.53),
        ("magnet", "Magnet", 10.53),
    ],
    "premier_ball": [
        ("tiny_mushroom", "Tiny Mushroom", 20.41),
        ("stardust", "Stardust", 20.41),
        ("pearl", "Pearl", 20.41),
        ("nugget", "Nugget", 20.41),
        ("big_pearl", "Big Pearl", 6.12),
        ("star_piece", "Star Piece", 6.12),
        ("big_nugget", "Big Nugget", 6.12),
    ],
}
ROUTE_MOVE_TIMER_POOL_KEY = "poke_ball"
ROUTE_MOVE_LAST_STANDARD_ROLL: dict[str, tuple[str, str, str, str]] = {}
ROUTE_MOVE_BONUS_BERRIES: List[Tuple[str, str]] = [
    ("cheri_berry", "Cheri Berry"),
    ("chesto_berry", "Chesto Berry"),
    ("pecha_berry", "Pecha Berry"),
    ("rawst_berry", "Rawst Berry"),
    ("aspear_berry", "Aspear Berry"),
    ("persim_berry", "Persim Berry"),
    ("sitrus_berry", "Sitrus Berry"),
    ("aguav_berry", "Aguav Berry"),
    ("figy_berry", "Figy Berry"),
    ("iapapa_berry", "Iapapa Berry"),
    ("lum_berry", "Lum Berry"),
]

# :: market catalog moved to lib.market_catalog

ADVENTURE_ROUTES = {
    "route-1": {
        "name": "Route 1",
        "image_uncleared": ASSETS_ROUTES / "route-1-panel-1.png",
        "image_cleared": ASSETS_ROUTES / "route-1-panel-1.png",
        "panels": [
            ASSETS_ROUTES / "route-1-panel-1.png",
            ASSETS_ROUTES / "route-1-panel-2.png",
            ASSETS_ROUTES / "route-1-panel-3.png",
        ],
        "next": "viridian-city",
        "grass_paths": {
            # Weighted, leveled encounters (Gen 1 Route 1)
            1: {
                "encounters": [
                    {"species": "pidgey", "weight": 55, "min_level": 2, "max_level": 5},
                    {"species": "rattata", "weight": 45, "min_level": 2, "max_level": 4},
                ],
                "blocker": None,
            },
            2: {
                "encounters": [
                    {"species": "pidgey", "weight": 55, "min_level": 2, "max_level": 5},
                    {"species": "rattata", "weight": 45, "min_level": 2, "max_level": 4},
                ],
                "blocker": "trainer-1",
            },
            3: {
                "encounters": [
                    {"species": "pidgey", "weight": 55, "min_level": 2, "max_level": 5},
                    {"species": "rattata", "weight": 45, "min_level": 2, "max_level": 4},
                ],
                "blocker": None,  # No blocker ‚Äî path 2 has the only trainer
            },
        },
        "trainers": {
            "trainer-1": {
                "name": "Youngster Tim",
                "blocker_quote": "Hey! You can't cross the grass without battling me first! My Rattata is in the top percentage of Rattata!",
                "team": [{"species": "Rattata", "level": 4}],
            },
        },
    },
    "route-2": {
        "name": "Route 2",
        "image_uncleared": ASSETS_ROUTES / "route-2-panel-1.png",
        "image_cleared": ASSETS_ROUTES / "route-2-panel-1.png",
        "panels": [
            ASSETS_ROUTES / "route-2-panel-1.png",
            ASSETS_ROUTES / "route-2-panel-2.png",
            ASSETS_ROUTES / "route-2-panel-3.png",
        ],
        "prev": "viridian-city",
        "next": "Viridian-Forest",
        "next_always": True,
        # Sign on panel 1: button appears only when on that panel
        "panel_signs": {
            1: {
                "label": "Read Sign",
                "text": "Remember to stock up on healing items when you explore long routes!",
                "text_alt": "Come over here and kiss me on my hot mouth, I'm feeling romantical",
                "text_chance": 0.999,
            },
        },
        # 3-panel navigation like Route 1; encounters per panel
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "rattata", "weight": 45, "min_level": 2, "max_level": 5},
                    {"species": "pidgey",  "weight": 40, "min_level": 3, "max_level": 5},
                    {"species": "weedle",   "weight": 15, "min_level": 3, "max_level": 5, "version": "red"},
                    {"species": "caterpie", "weight": 15, "min_level": 3, "max_level": 5, "version": "blue"},
                ],
                "blocker": None,
            },
            2: {
                "encounters": [
                    {"species": "rattata", "weight": 45, "min_level": 2, "max_level": 5},
                    {"species": "pidgey",  "weight": 40, "min_level": 3, "max_level": 5},
                    {"species": "weedle",   "weight": 15, "min_level": 3, "max_level": 5, "version": "red"},
                    {"species": "caterpie", "weight": 15, "min_level": 3, "max_level": 5, "version": "blue"},
                ],
                "blocker": None,
            },
            3: {
                "encounters": [
                    {"species": "rattata", "weight": 45, "min_level": 2, "max_level": 5},
                    {"species": "pidgey",  "weight": 40, "min_level": 3, "max_level": 5},
                    {"species": "weedle",   "weight": 15, "min_level": 3, "max_level": 5, "version": "red"},
                    {"species": "caterpie", "weight": 15, "min_level": 3, "max_level": 5, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "Viridian-Forest": {   # <-- ADD HERE (new line)
        "name": "Viridian Forest",
        "layout": "maze",
        "entry_node": "2-1",
        "exit_node": "1-3",
        "next": "route-2-2",
        "prev": "route-2",
        "nodes": {
            "2-1": {
                "image": ASSETS_ROUTES / "viridian-forest-2-1.png",
                "exits": [
                    {"id": "north", "label": "‚¨ÜÔ∏è North", "target": "2-2"},
                    {"id": "east", "label": "‚û°Ô∏è East", "target": "3-1"},
                    {"id": "west", "label": "‚¨ÖÔ∏è West", "target": "1-1"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 3, "max_level": 5},
                ],
            },
            "1-1": {
                "image": ASSETS_ROUTES / "viridian-forest-1-1.png",
                "exits": [
                    {"id": "south", "label": "‚û°Ô∏è East", "target": "2-1"},
                    {"id": "north", "label": "‚¨ÜÔ∏è North", "target": "1-2"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 3, "max_level": 5},
                ],
            },
            "1-2": {
                "image": ASSETS_ROUTES / "viridian-forest-1-2.png",
                "exits": [
                    {"id": "east", "label": "‚û°Ô∏è East", "target": "2-2"},
                    {"id": "south", "label": "‚¨áÔ∏è South", "target": "1-1"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 17.5, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 17.5, "min_level": 5, "max_level": 6},
                    {"species": "ralts", "weight": 0.5, "min_level": 2, "max_level": 4},
                ],
            },
            "2-2": {
                "image": ASSETS_ROUTES / "viridian-forest-2-2.png",
                "exits": [
                    {"id": "west", "label": "‚¨ÖÔ∏è West", "target": "1-2"},
                    {"id": "south", "label": "‚¨áÔ∏è South", "target": "2-1"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "3-1": {
                "image": ASSETS_ROUTES / "viridian-forest-3-1.png",
                "exits": [
                    {"id": "west", "label": "‚¨ÖÔ∏è West", "target": "2-1"},
                    {"id": "north", "label": "‚¨ÜÔ∏è North", "target": "3-2"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "3-2": {
                "image": ASSETS_ROUTES / "viridian-forest-3-2.png",
                "exits": [
                    {"id": "south", "label": "‚¨áÔ∏è South", "target": "3-1"},
                    {"id": "north", "label": "‚¨ÜÔ∏è North", "target": "3-3"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "3-3": {
                "image": ASSETS_ROUTES / "viridian-forest-3-3.png",
                "exits": [
                    {"id": "west", "label": "‚¨ÖÔ∏è West", "target": "2-3"},
                    {"id": "south", "label": "‚¨áÔ∏è South", "target": "3-2"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "2-3": {
                "image": ASSETS_ROUTES / "viridian-forest-2-3.png",
                "exits": [
                    {"id": "west", "label": "‚¨ÖÔ∏è West", "target": "2.5-3"},
                    {"id": "east", "label": "‚û°Ô∏è East", "target": "3-3"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "2.5-3": {
                "image": ASSETS_ROUTES / "viridian-forest-2.5-3.png",
                "exits": [
                    {"id": "west", "label": "‚¨ÖÔ∏è West", "target": "1.5-3"},
                    {"id": "east", "label": "‚û°Ô∏è East", "target": "2-3"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "1.5-3": {
                "image": ASSETS_ROUTES / "viridian-forest-1.5-3.png",
                "exits": [
                    {"id": "south", "label": "‚¨áÔ∏è South", "target": "1-2.5"},
                    {"id": "east", "label": "‚û°Ô∏è East", "target": "2.5-3"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "1-2.5": {
                "image": ASSETS_ROUTES / "viridian-forest-1-2.5.png",
                "exits": [
                    {"id": "northwest", "label": "‚ÜñÔ∏è Northwest", "target": "1-3"},
                    {"id": "northeast", "label": "‚ÜóÔ∏è Northeast", "target": "1.5-3"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
            "1-3": {
                "image": ASSETS_ROUTES / "viridian-forest-1-3.png",
                "exits": [
                    {"id": "exit", "label": "üö™ Exit to Route 2", "target": "1-3"},
                ],
                "encounters": [
                    {"species": "caterpie", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "weedle", "weight": 30, "min_level": 3, "max_level": 5},
                    {"species": "kakuna", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "metapod", "weight": 15, "min_level": 5, "max_level": 6},
                    {"species": "pikachu", "weight": 10, "min_level": 2, "max_level": 4},
                ],
            },
        },
        "trainers": {},
    },
    "route-2-2": {
        "name": "Route 2",
        "image_uncleared": ASSETS_ROUTES / "route-2-2.png",
        "image_cleared": ASSETS_ROUTES / "route-2-2.png",
        "next": None,
        "next_always": True,
        "grass_paths": {},
        "trainers": {},
    },
    "route-3": {
        "name": "Route 3",
        "image_uncleared": ASSETS_ROUTES / "route-3-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-3-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "pidgey", "weight": 50, "min_level": 6, "max_level": 8},
                    {"species": "spearow", "weight": 40, "min_level": 5, "max_level": 8},
                    {"species": "jigglypuff", "weight": 10, "min_level": 3, "max_level": 7},
                ],
                "blocker": "trainer-route-3-colton",
            },
        },
        "trainers": {
            "trainer-route-3-colton": {
                "name": "Bug Catcher Colton",
                "blocker_quote": "You'll have to battle me to pass!",
                "team": [
                    {"species": "caterpie", "level": 10, "moves": ["Tackle", "String Shot"], "stats": {"hp": 29, "atk": 11, "defn": 10, "spa": 9, "spd": 9, "spe": 14}},
                    {"species": "weedle", "level": 10, "moves": ["Poison Sting", "String Shot"], "stats": {"hp": 28, "atk": 12, "defn": 9, "spa": 9, "spd": 9, "spe": 16}},
                    {"species": "caterpie", "level": 10, "moves": ["Tackle", "String Shot"], "stats": {"hp": 29, "atk": 11, "defn": 10, "spa": 9, "spd": 9, "spe": 14}},
                ],
            },
        },
    },
    "route-4": {
        "name": "Route 4",
        "image_uncleared": ASSETS_ROUTES / "route-4-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-4-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "rattata", "weight": 45, "min_level": 8, "max_level": 12},
                    {"species": "spearow", "weight": 30, "min_level": 8, "max_level": 12},
                    {"species": "ekans", "weight": 25, "min_level": 6, "max_level": 12, "version": "red"},
                    {"species": "sandshrew", "weight": 25, "min_level": 6, "max_level": 12, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-5": {
        "name": "Route 5",
        "image_uncleared": ASSETS_ROUTES / "route-5-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-5-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "oddish", "weight": 40, "min_level": 13, "max_level": 16, "version": "red"},
                    {"species": "bellsprout", "weight": 40, "min_level": 13, "max_level": 16, "version": "blue"},
                    {"species": "pidgey", "weight": 35, "min_level": 13, "max_level": 16},
                    {"species": "mankey", "weight": 25, "min_level": 10, "max_level": 16, "version": "red"},
                    {"species": "meowth", "weight": 25, "min_level": 10, "max_level": 16, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-6": {
        "name": "Route 6",
        "image_uncleared": ASSETS_ROUTES / "route-6-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-6-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "oddish", "weight": 40, "min_level": 13, "max_level": 16, "version": "red"},
                    {"species": "bellsprout", "weight": 40, "min_level": 13, "max_level": 16, "version": "blue"},
                    {"species": "pidgey", "weight": 35, "min_level": 13, "max_level": 16},
                    {"species": "mankey", "weight": 25, "min_level": 10, "max_level": 16, "version": "red"},
                    {"species": "meowth", "weight": 25, "min_level": 10, "max_level": 16, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-7": {
        "name": "Route 7",
        "image_uncleared": ASSETS_ROUTES / "route-7-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-7-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "pidgey", "weight": 35, "min_level": 19, "max_level": 22},
                    {"species": "mankey", "weight": 30, "min_level": 17, "max_level": 20, "version": "red"},
                    {"species": "meowth", "weight": 30, "min_level": 17, "max_level": 20, "version": "blue"},
                    {"species": "oddish", "weight": 25, "min_level": 19, "max_level": 22, "version": "red"},
                    {"species": "bellsprout", "weight": 25, "min_level": 19, "max_level": 22, "version": "blue"},
                    {"species": "growlithe", "weight": 10, "min_level": 18, "max_level": 20, "version": "red"},
                    {"species": "vulpix", "weight": 10, "min_level": 18, "max_level": 20, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-8": {
        "name": "Route 8",
        "image_uncleared": ASSETS_ROUTES / "route-8-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-8-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "pidgey", "weight": 35, "min_level": 18, "max_level": 20},
                    {"species": "mankey", "weight": 25, "min_level": 18, "max_level": 20, "version": "red"},
                    {"species": "meowth", "weight": 25, "min_level": 18, "max_level": 20, "version": "blue"},
                    {"species": "ekans", "weight": 20, "min_level": 17, "max_level": 19, "version": "red"},
                    {"species": "sandshrew", "weight": 20, "min_level": 17, "max_level": 19, "version": "blue"},
                    {"species": "growlithe", "weight": 20, "min_level": 15, "max_level": 18, "version": "red"},
                    {"species": "vulpix", "weight": 20, "min_level": 15, "max_level": 18, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-9": {
        "name": "Route 9",
        "image_uncleared": ASSETS_ROUTES / "route-9-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-9-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "rattata", "weight": 45, "min_level": 14, "max_level": 17},
                    {"species": "spearow", "weight": 30, "min_level": 13, "max_level": 17},
                    {"species": "ekans", "weight": 25, "min_level": 11, "max_level": 17, "version": "red"},
                    {"species": "sandshrew", "weight": 25, "min_level": 11, "max_level": 17, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-10": {
        "name": "Route 10",
        "image_uncleared": ASSETS_ROUTES / "route-10-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-10-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "voltorb", "weight": 45, "min_level": 14, "max_level": 17},
                    {"species": "spearow", "weight": 30, "min_level": 13, "max_level": 17},
                    {"species": "ekans", "weight": 25, "min_level": 11, "max_level": 17, "version": "red"},
                    {"species": "sandshrew", "weight": 25, "min_level": 11, "max_level": 17, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-11": {
        "name": "Route 11",
        "image_uncleared": ASSETS_ROUTES / "route-11-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-11-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "ekans", "weight": 45, "min_level": 12, "max_level": 15, "version": "red"},
                    {"species": "sandshrew", "weight": 45, "min_level": 12, "max_level": 15, "version": "blue"},
                    {"species": "spearow", "weight": 30, "min_level": 13, "max_level": 17},
                    {"species": "drowzee", "weight": 25, "min_level": 9, "max_level": 15},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-12": {
        "name": "Route 12",
        "image_uncleared": ASSETS_ROUTES / "route-12-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-12-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "oddish", "weight": 40, "min_level": 22, "max_level": 26, "version": "red"},
                    {"species": "bellsprout", "weight": 40, "min_level": 22, "max_level": 26, "version": "blue"},
                    {"species": "pidgey", "weight": 35, "min_level": 23, "max_level": 27},
                    {"species": "venonat", "weight": 20, "min_level": 24, "max_level": 26},
                    {"species": "gloom", "weight": 5, "min_level": 28, "max_level": 30, "version": "red"},
                    {"species": "weepinbell", "weight": 5, "min_level": 28, "max_level": 30, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-13": {
        "name": "Route 13",
        "image_uncleared": ASSETS_ROUTES / "route-13-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-13-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "oddish", "weight": 40, "min_level": 22, "max_level": 26, "version": "red"},
                    {"species": "bellsprout", "weight": 40, "min_level": 22, "max_level": 26, "version": "blue"},
                    {"species": "pidgey", "weight": 30, "min_level": 25, "max_level": 27},
                    {"species": "venonat", "weight": 20, "min_level": 24, "max_level": 26},
                    {"species": "gloom", "weight": 5, "min_level": 28, "max_level": 30, "version": "red"},
                    {"species": "weepinbell", "weight": 5, "min_level": 28, "max_level": 30, "version": "blue"},
                    {"species": "ditto", "weight": 5, "min_level": 25, "max_level": 25},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-14": {
        "name": "Route 14",
        "image_uncleared": ASSETS_ROUTES / "route-14-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-14-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "oddish", "weight": 40, "min_level": 22, "max_level": 26, "version": "red"},
                    {"species": "bellsprout", "weight": 40, "min_level": 22, "max_level": 26, "version": "blue"},
                    {"species": "venonat", "weight": 20, "min_level": 24, "max_level": 26},
                    {"species": "pidgey", "weight": 15, "min_level": 26, "max_level": 26},
                    {"species": "ditto", "weight": 15, "min_level": 23, "max_level": 23},
                    {"species": "pidgeotto", "weight": 5, "min_level": 28, "max_level": 30},
                    {"species": "gloom", "weight": 5, "min_level": 30, "max_level": 30, "version": "red"},
                    {"species": "weepinbell", "weight": 5, "min_level": 30, "max_level": 30, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-15": {
        "name": "Route 15",
        "image_uncleared": ASSETS_ROUTES / "route-15-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-15-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "oddish", "weight": 40, "min_level": 22, "max_level": 26, "version": "red"},
                    {"species": "bellsprout", "weight": 40, "min_level": 22, "max_level": 26, "version": "blue"},
                    {"species": "venonat", "weight": 20, "min_level": 26, "max_level": 28},
                    {"species": "pidgey", "weight": 15, "min_level": 23, "max_level": 23},
                    {"species": "ditto", "weight": 15, "min_level": 26, "max_level": 26},
                    {"species": "pidgeotto", "weight": 5, "min_level": 28, "max_level": 30},
                    {"species": "gloom", "weight": 5, "min_level": 30, "max_level": 30, "version": "red"},
                    {"species": "weepinbell", "weight": 5, "min_level": 30, "max_level": 30, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-16": {
        "name": "Route 16",
        "image_uncleared": ASSETS_ROUTES / "route-16-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-16-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "spearow", "weight": 40, "min_level": 20, "max_level": 22},
                    {"species": "rattata", "weight": 30, "min_level": 18, "max_level": 22},
                    {"species": "doduo", "weight": 25, "min_level": 18, "max_level": 22},
                    {"species": "raticate", "weight": 5, "min_level": 23, "max_level": 25},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-17": {
        "name": "Route 17",
        "image_uncleared": ASSETS_ROUTES / "route-17-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-17-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "spearow", "weight": 40, "min_level": 20, "max_level": 22},
                    {"species": "raticate", "weight": 30, "min_level": 25, "max_level": 29},
                    {"species": "doduo", "weight": 25, "min_level": 24, "max_level": 28},
                    {"species": "fearow", "weight": 5, "min_level": 25, "max_level": 27},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-18": {
        "name": "Route 18",
        "image_uncleared": ASSETS_ROUTES / "route-18-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-18-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "spearow", "weight": 40, "min_level": 20, "max_level": 22},
                    {"species": "doduo", "weight": 25, "min_level": 24, "max_level": 28},
                    {"species": "raticate", "weight": 20, "min_level": 25, "max_level": 29},
                    {"species": "fearow", "weight": 15, "min_level": 25, "max_level": 29},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-19": {
        "name": "Route 19",
        "image_uncleared": ASSETS_ROUTES / "route-19-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-19-cleared.png",
        "next": None,
        # Surf encounters only (water route) - 100% Tentacool, level 5-40
        "water_encounters": [
            {"species": "tentacool", "weight": 100, "min_level": 5, "max_level": 40},
        ],
        "grass_paths": {},
        "trainers": {},
    },
    "route-21": {
        "name": "Route 21",
        "image_uncleared": ASSETS_ROUTES / "route-21-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-21-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "rattata", "weight": 35, "min_level": 21, "max_level": 23},
                    {"species": "pidgey", "weight": 25, "min_level": 21, "max_level": 23},
                    {"species": "pidgeotto", "weight": 15, "min_level": 30, "max_level": 32},
                    {"species": "raticate", "weight": 15, "min_level": 30, "max_level": 30},
                    {"species": "tangela", "weight": 10, "min_level": 28, "max_level": 32},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-22": {
        "name": "Route 22",
        "image_rival_not_arrived": ASSETS_ROUTES / "route-22-rival-barrived.png",
        "image_rival_arrived": ASSETS_ROUTES / "route-22-rival-arrived.png",
        "image_uncleared": ASSETS_ROUTES / "route-22-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-22-cleared.png",
        "next": "viridian-city",
        "rival_battle": "rival-route-22",
        "back_always": True,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "rattata", "weight": 50, "min_level": 2, "max_level": 4},
                    {"species": "nidoran-m", "weight": 35, "min_level": 2, "max_level": 4, "version": "red"},
                    {"species": "nidoran-f", "weight": 35, "min_level": 2, "max_level": 4, "version": "blue"},
                    {"species": "spearow", "weight": 10, "min_level": 3, "max_level": 5},
                    {"species": "nidoran-f", "weight": 5, "min_level": 3, "max_level": 4, "version": "red"},
                    {"species": "nidoran-m", "weight": 5, "min_level": 3, "max_level": 4, "version": "blue"},
                ],
                "blocker": "trainer-route-22-1",
            },
            2: {
                "encounters": [
                    {"species": "rattata", "weight": 50, "min_level": 2, "max_level": 4},
                    {"species": "nidoran-m", "weight": 35, "min_level": 2, "max_level": 4, "version": "red"},
                    {"species": "nidoran-f", "weight": 35, "min_level": 2, "max_level": 4, "version": "blue"},
                    {"species": "spearow", "weight": 10, "min_level": 3, "max_level": 5},
                    {"species": "nidoran-f", "weight": 5, "min_level": 3, "max_level": 4, "version": "red"},
                    {"species": "nidoran-m", "weight": 5, "min_level": 3, "max_level": 4, "version": "blue"},
                ],
                "blocker": "trainer-route-22-1",  # Path 2 is after path 1; same trainer blocks both until defeated
            },
        },
        "trainers": {
            "trainer-route-22-1": {
                "name": "Route 22 Trainer",
                "blocker_quote": "You'll have to beat me first if you want to cross!",
                "team": [
                    {"species": "rattata", "level": 10, "moves": ["Tackle", "Tail Whip", "Quick Attack"], "stats": {"hp": 26, "atk": 16, "defn": 12, "spa": 10, "spd": 13, "spe": 19}},
                    {"species": "nidoran-f", "level": 10, "moves": ["Growl", "Scratch", "Tail Whip"], "stats": {"hp": 31, "atk": 12, "defn": 15, "spa": 13, "spd": 13, "spe": 14}},
                ],
            },
        },
    },
    "route-23": {
        "name": "Route 23",
        "image_uncleared": ASSETS_ROUTES / "route-23-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-23-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "ditto", "weight": 30, "min_level": 33, "max_level": 43},
                    {"species": "fearow", "weight": 25, "min_level": 38, "max_level": 43},
                    {"species": "ekans", "weight": 25, "min_level": 26, "max_level": 26, "version": "red"},
                    {"species": "sandshrew", "weight": 25, "min_level": 26, "max_level": 26, "version": "blue"},
                    {"species": "spearow", "weight": 15, "min_level": 26, "max_level": 26},
                    {"species": "arbok", "weight": 5, "min_level": 41, "max_level": 41, "version": "red"},
                    {"species": "sandslash", "weight": 5, "min_level": 41, "max_level": 41, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-24": {
        "name": "Route 24",
        "image_uncleared": ASSETS_ROUTES / "route-24-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-24-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "weedle", "weight": 25, "min_level": 7, "max_level": 7, "version": "red"},
                    {"species": "caterpie", "weight": 25, "min_level": 7, "max_level": 7, "version": "blue"},
                    {"species": "oddish", "weight": 25, "min_level": 12, "max_level": 14, "version": "red"},
                    {"species": "bellsprout", "weight": 25, "min_level": 12, "max_level": 14, "version": "blue"},
                    {"species": "pidgey", "weight": 20, "min_level": 12, "max_level": 13},
                    {"species": "kakuna", "weight": 15, "min_level": 8, "max_level": 8, "version": "red"},
                    {"species": "metapod", "weight": 15, "min_level": 8, "max_level": 8, "version": "blue"},
                    {"species": "abra", "weight": 15, "min_level": 8, "max_level": 12},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
    "route-25": {
        "name": "Route 25",
        "image_uncleared": ASSETS_ROUTES / "route-25-uncleared.png",
        "image_cleared": ASSETS_ROUTES / "route-25-cleared.png",
        "next": None,
        "grass_paths": {
            1: {
                "encounters": [
                    {"species": "weedle", "weight": 25, "min_level": 8, "max_level": 8, "version": "red"},
                    {"species": "caterpie", "weight": 25, "min_level": 8, "max_level": 8, "version": "blue"},
                    {"species": "oddish", "weight": 25, "min_level": 12, "max_level": 14, "version": "red"},
                    {"species": "bellsprout", "weight": 25, "min_level": 12, "max_level": 14, "version": "blue"},
                    {"species": "kakuna", "weight": 15, "min_level": 9, "max_level": 9, "version": "red"},
                    {"species": "metapod", "weight": 15, "min_level": 9, "max_level": 9, "version": "blue"},
                    {"species": "pidgey", "weight": 15, "min_level": 13, "max_level": 13},
                    {"species": "abra", "weight": 15, "min_level": 10, "max_level": 12},
                    {"species": "metapod", "weight": 4, "min_level": 7, "max_level": 7, "version": "red"},
                    {"species": "kakuna", "weight": 4, "min_level": 7, "max_level": 7, "version": "blue"},
                    {"species": "caterpie", "weight": 1, "min_level": 8, "max_level": 8, "version": "red"},
                    {"species": "weedle", "weight": 1, "min_level": 8, "max_level": 8, "version": "blue"},
                ],
                "blocker": None,
            },
        },
        "trainers": {},
    },
}


RIVAL_BATTLES = {
    "rival-1": {
        "name": "Rival",
        # First encounter: keep it low and use Gen 1 level-up moves available at/below this level.
        "level": 5,
    },
    "rival-route-22": {
        "name": "Rival",
        # Route 22: rival appears when user clicks any button other than Back. Team depends on player's starter.
        "teams_by_starter": {
            "charmander": [
                {"species": "pidgey", "level": 9, "moves": ["Tackle", "Sand-Attack"], "stats": {"hp": 26, "atk": 13, "defn": 12, "spa": 11, "spd": 11, "spe": 15}},
                {"species": "squirtle", "level": 9, "moves": ["Tackle", "Tail Whip"], "stats": {"hp": 27, "atk": 14, "defn": 17, "spa": 14, "spd": 17, "spe": 13}},
            ],
            "squirtle": [
                {"species": "pidgey", "level": 9, "moves": ["Tackle", "Sand-Attack"], "stats": {"hp": 26, "atk": 13, "defn": 12, "spa": 11, "spd": 11, "spe": 15}},
                {"species": "bulbasaur", "level": 9, "moves": ["Tackle", "Growl"], "stats": {"hp": 27, "atk": 14, "defn": 17, "spa": 14, "spd": 17, "spe": 13}},
            ],
            "bulbasaur": [
                {"species": "pidgey", "level": 9, "moves": ["Tackle", "Sand-Attack"], "stats": {"hp": 26, "atk": 13, "defn": 12, "spa": 11, "spd": 11, "spe": 15}},
                {"species": "charmander", "level": 9, "moves": ["Scratch", "Growl"], "stats": {"hp": 26, "atk": 12, "defn": 13, "spa": 17, "spd": 14, "spe": 17}},
            ],
            "pikachu": [
                {"species": "eevee", "level": 9, "moves": ["Tackle", "Tail Whip", "Sand-Attack"], "stats": {"hp": 29, "atk": 14, "defn": 12, "spa": 12, "spd": 16, "spe": 14}},
                {"species": "vaporeon", "level": 9, "moves": ["Water Gun", "Tackle", "Tail Whip"], "stats": {"hp": 38, "atk": 14, "defn": 14, "spa": 20, "spd": 18, "spe": 14}},
            ],
        },
    },
}


def _weighted_choice(items: Sequence[Tuple[str, str, float]]) -> Tuple[str, str]:
    """Pick (id, display_name) from weighted tuples (id, name, weight)."""
    if not items:
        return ("", "")
    total = 0.0
    norm: list[tuple[str, str, float]] = []
    for key, name, weight in items:
        w = max(0.0, float(weight or 0.0))
        if w <= 0:
            continue
        norm.append((str(key), str(name), w))
        total += w
    if total <= 0 or not norm:
        key, name, _ = items[-1]
        return str(key), str(name)
    r = random.uniform(0.0, total)
    for key, name, weight in norm:
        r -= weight
        if r <= 0:
            return key, name
    return norm[-1][0], norm[-1][1]


def _roll_route_ball_by_absolute_rate() -> tuple[str, str]:
    """Roll route ball encounter using absolute percentage rates."""
    if not ROUTE_MOVE_BALL_ENCOUNTER_RATES:
        return ("__none__", "No Ball")
    r = random.uniform(0.0, 100.0)
    cumul = 0.0
    for ball_id, ball_name, pct in ROUTE_MOVE_BALL_ENCOUNTER_RATES:
        p = max(0.0, float(pct or 0.0))
        if p <= 0.0:
            continue
        cumul += p
        if r <= cumul:
            return str(ball_id), str(ball_name)
    return ("__none__", "No Ball")


def _route_pick_item_from_pool(pool_key: str) -> tuple[str, str]:
    pool = ROUTE_MOVE_ITEMS_BY_BALL.get(str(pool_key or "")) or ROUTE_MOVE_ITEMS_BY_BALL.get("poke_ball") or []
    item_id, item_name = _weighted_choice(pool)
    if item_id == "__bonus_berry__":
        try:
            return random.choice(ROUTE_MOVE_BONUS_BERRIES)
        except Exception:
            return ("oran_berry", "Oran Berry")
    return item_id, item_name


async def _roll_and_give_route_move_item_async(user_id: str) -> Optional[str]:
    """
    Roll route loot-ball encounter and grant rewards from the configured pool table.
    A ball encounter acts as a loot container, not an extra guaranteed item:
    - One reward is rolled from that ball's configured loot table.
    - If that table includes a Pok√© Ball (or any ball), that is the reward.
    Returns the message to show or None if no drop.
    """
    if not ROUTE_MOVE_BALL_ENCOUNTER_RATES or not ROUTE_MOVE_ITEMS_BY_BALL:
        return None
    ball_id, ball_name = _roll_route_ball_by_absolute_rate()
    if not ball_id or ball_id == "__none__":
        return None
    uid = str(user_id)

    async def _grant(item_id: str, item_name: str, qty: int = 1) -> None:
        q = max(0, int(qty or 0))
        if q <= 0:
            return
        await db.upsert_item_master(item_id, name=item_name)
        await db.give_item(uid, item_id, q)

    try:
        # Repeat Ball: duplicate previous standard roll rewards.
        if ball_id == "repeat_ball":
            prev = ROUTE_MOVE_LAST_STANDARD_ROLL.get(uid)
            if prev:
                _prev_ball_id, _prev_ball_name, prev_item_id, prev_item_name = prev
                await _grant(prev_item_id, prev_item_name, 2)
                return (
                    f"You found a **{ball_name}**! It repeated your last route ball reward: "
                    f"**2√ó {prev_item_name}**."
                )
            fallback_item_id, fallback_item_name = _route_pick_item_from_pool("poke_ball")
            await _grant(fallback_item_id, fallback_item_name, 1)
            return (
                f"You found a **{ball_name}**! No previous route reward to repeat, "
                f"so it gave a standard drop: **{fallback_item_name}**."
            )

        # Timer Ball: uses standard pool with no modifier.
        pool_key = ROUTE_MOVE_TIMER_POOL_KEY if ball_id == "timer_ball" else ball_id
        item_id, item_name = _route_pick_item_from_pool(pool_key)
        if not item_id:
            return None

        await _grant(item_id, item_name, 1)
        ROUTE_MOVE_LAST_STANDARD_ROLL[uid] = (ball_id, ball_name, item_id, item_name)

        if ball_id == "timer_ball":
            return f"You found a **{ball_name}**! Standard reward: **{item_name}**."
        return f"You found a **{ball_name}**! Inside was **{item_name}**."
    except Exception as e:
        print(f"[Adventure] Route move item drop give_item failed: {e}")
        import traceback
        traceback.print_exc()
        return None


def _is_pokemart(area_id: str) -> bool:
    city = ADVENTURE_CITIES.get(str(area_id or ""), {})
    return bool(city.get("is_pokemart"))


def _market_normalize_key(raw: str) -> str:
    # ::market
    return _catalog_normalize_market_key(str(raw or ""))


def _market_resolve_item_key(raw: str) -> Optional[str]:
    return _catalog_resolve_market_key(str(raw or ""))


def _market_item_variants(item_key: str) -> tuple[str, ...]:
    return _catalog_market_item_variants(str(item_key or ""))


def _market_display(item_key: str) -> str:
    return _catalog_market_display_name(str(item_key or ""))


MARKET_TREASURE_ITEM_KEYS: frozenset[str] = frozenset(
    str(item_id)
    for item_id, _disp, _price in MARKET_PRICE_CATALOG.get("Treasure Items", [])
)


def _market_is_treasure(item_key: str) -> bool:
    return _market_normalize_key(str(item_key or "")) in MARKET_TREASURE_ITEM_KEYS


def _market_price_embed() -> discord.Embed:
    emb = discord.Embed(
        title="Pok√© Mart Price List",
        description=(
            f"These prices are active for Pok√© Mart trading.\n"
            f"Currency: **{PKDollar_NAME}**\n"
            "Treasure Items are **sell-only**."
        ),
        color=0x4CAF50,
    )
    for category, rows in MARKET_PRICE_CATALOG.items():
        if category == "Treasure Items":
            lines = [f"‚Ä¢ **{disp}** ‚Äî Sell for {int(price):,}" for _item_id, disp, price in rows]
        else:
            lines = [f"‚Ä¢ **{disp}** ‚Äî {int(price):,}" for _item_id, disp, price in rows]
        value = "\n".join(lines)[:1024] if lines else "‚Äî"
        emb.add_field(name=category, value=value, inline=False)
    return emb


async def _market_total_qty(owner_id: str, item_key: str, conn: Any | None = None) -> int:
    variants = _market_item_variants(item_key)
    if not variants:
        return 0
    own_conn = conn is None
    if own_conn:
        try:
            conn = await db.connect()
        except Exception:
            return 0
    try:
        placeholders = ", ".join("?" for _ in variants)
        cur = await conn.execute(
            f"SELECT COALESCE(SUM(qty), 0) AS total_qty FROM user_items WHERE owner_id=? AND item_id IN ({placeholders})",
            (owner_id, *variants),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return 0
        return int((row.get("total_qty") if hasattr(row, "keys") else row[0]) or 0)
    except Exception:
        return 0
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _market_buy(owner_id: str, item_key: str, qty_requested: int) -> tuple[bool, str]:
    qty_requested = int(qty_requested)
    if qty_requested <= 0:
        return False, "Quantity must be a positive number."
    canonical_item_id = _market_normalize_key(item_key)
    display = _market_display(canonical_item_id)
    if _market_is_treasure(canonical_item_id):
        return False, f"**{display}** is a treasure item and cannot be bought. Treasure items can only be sold."
    price = int(MARKET_SELL_PRICES.get(canonical_item_id, 0))
    if price <= 0:
        return False, "That item is not sold in this Pok√© Mart."
    async with DB_WRITE_LOCK:
        async with db.session() as conn:
            await conn.execute(
                "INSERT INTO users(user_id, coins, currencies) VALUES(?, 0, '{\"coins\": 0}'::jsonb) ON CONFLICT(user_id) DO NOTHING",
                (owner_id,),
            )
            current_total = await _market_total_qty(owner_id, item_key, conn=conn)
            if current_total >= MAX_STACK:
                return False, f"You already have **{current_total}/{MAX_STACK}** {display}."
            qty_allowed = min(int(qty_requested), int(MAX_STACK - current_total))
            total_cost = int(price * qty_allowed)

            cur = await conn.execute("SELECT * FROM users WHERE user_id=? LIMIT 1", (owner_id,))
            row = await cur.fetchone()
            await cur.close()
            balance = int(db.get_currency_from_row(dict(row) if row else None, "coins"))
            if balance < total_cost:
                return False, (
                    f"Not enough {PKDollar_NAME}. Cost: **{total_cost:,}**, "
                    f"you have **{balance:,}**."
                )

            # Ensure item exists in master table before touching user_items (FK-safe).
            await conn.execute(
                "INSERT INTO items (id, name) VALUES (?, ?) ON CONFLICT (id) DO NOTHING",
                (canonical_item_id, display),
            )
            deducted = False
            try:
                await db.add_currency_conn(conn, owner_id, "coins", -total_cost)
                deducted = True
                await conn.execute(
                    "INSERT INTO user_items(owner_id, item_id, qty) VALUES(?,?,?) "
                    "ON CONFLICT(owner_id, item_id) DO UPDATE SET qty = LEAST(user_items.qty + excluded.qty, ?::int);",
                    (owner_id, canonical_item_id, qty_allowed, MAX_STACK),
                )
            except Exception:
                # Session wrapper may execute statements outside a single SQL transaction.
                # Best-effort refund to avoid players losing money on failed item grant.
                if deducted:
                    try:
                        await db.add_currency_conn(conn, owner_id, "coins", total_cost)
                    except Exception:
                        pass
                raise
            await conn.commit()
    try:
        db.invalidate_bag_cache(owner_id)
    except Exception:
        pass
    return True, (
        f"‚úÖ Bought **{qty_allowed}√ó {display}** for **{price * qty_allowed:,} {PKDollar_NAME}**."
        + (f" (capped at {MAX_STACK})" if qty_allowed < qty_requested else "")
    )


async def _market_sell(owner_id: str, item_key: str, qty_requested: int) -> tuple[bool, str]:
    qty_requested = int(qty_requested)
    if qty_requested <= 0:
        return False, "Quantity must be a positive number."
    canonical_item_id = _market_normalize_key(item_key)
    price = int(MARKET_SELL_PRICES.get(canonical_item_id, 0))
    if price <= 0:
        return False, "That item cannot be sold here."
    variants = _market_item_variants(canonical_item_id)
    display = _market_display(canonical_item_id)
    async with DB_WRITE_LOCK:
        async with db.session() as conn:
            placeholders = ", ".join("?" for _ in variants)
            cur = await conn.execute(
                f"SELECT item_id, qty FROM user_items WHERE owner_id=? AND item_id IN ({placeholders}) ORDER BY qty DESC, item_id",
                (owner_id, *variants),
            )
            rows = await cur.fetchall()
            await cur.close()
            total_owned = 0
            parsed_rows: list[tuple[str, int]] = []
            for row in rows or []:
                iid = str(row["item_id"] if hasattr(row, "keys") else row[0])
                have = int((row.get("qty") if hasattr(row, "keys") else row[1]) or 0)
                if have <= 0:
                    continue
                parsed_rows.append((iid, have))
                total_owned += have
            if total_owned <= 0:
                return False, f"You don't have any **{display}** to sell."
            qty_to_sell = min(qty_requested, total_owned)
            remain = qty_to_sell
            for iid, have in parsed_rows:
                if remain <= 0:
                    break
                take = min(remain, have)
                new_qty = max(0, have - take)
                await conn.execute(
                    "UPDATE user_items SET qty=? WHERE owner_id=? AND item_id=?",
                    (new_qty, owner_id, iid),
                )
                remain -= take
            await conn.execute(
                "INSERT INTO users(user_id, coins, currencies) VALUES(?, 0, '{\"coins\": 0}'::jsonb) ON CONFLICT(user_id) DO NOTHING",
                (owner_id,),
            )
            payout = int(price * qty_to_sell)
            await db.add_currency_conn(conn, owner_id, "coins", payout)
            await conn.commit()
    try:
        db.invalidate_bag_cache(owner_id)
    except Exception:
        pass
    return True, (
        f"‚úÖ Sold **{qty_to_sell}√ó {display}** for **{price * qty_to_sell:,} {PKDollar_NAME}**."
        + (f" (only had {total_owned})" if qty_to_sell < qty_requested else "")
    )


def _adv_default_state() -> dict:
    return {
        "area_id": "pallet-town",
        "last_city": "pallet-town",
        "area_history": [],
        "cleared_cities": [],
        "cleared_routes": [],
        "gym_badges": [],
        "defeated_trainers": {},
        "discovered": {},
        "rival_defeated": [],
        "repeat_seen": [],
        "dex_seen": 0,
        "daycare": {},
    }


def _adv_history_entry(state: dict, area_id: str | None) -> Any:
    # ::nav
    return _history_entry(state, area_id)


def _adv_history_push(state: dict, area_id: str | None) -> None:
    _history_push(state, area_id, max_len=15)


def _adv_history_pop(state: dict, default_area: str = "pallet-town") -> str:
    return _history_pop(state, default_area)


async def _get_adventure_state(user_id: str) -> dict:
    uid = str(user_id)
    default = _adv_default_state()
    if db_cache is not None:
        try:
            cached = db_cache.get_cached_adventure_state(uid)
            if cached is not None:
                merged = default | cached
                if not isinstance(merged.get("area_history"), list):
                    merged["area_history"] = []
                if not merged.get("last_city"):
                    merged["last_city"] = "pallet-town"
                return merged
        except Exception:
            pass
    state = None
    async with db.session() as conn:
        cur = await conn.execute("SELECT data FROM adventure_state WHERE owner_id = ? LIMIT 1", (uid,))
        row = await cur.fetchone()
        await cur.close()
        if row and row.get("data"):
            try:
                state = json.loads(row["data"])
            except Exception:
                state = None
    if state is None:
        merged = default.copy()
        if not isinstance(merged.get("area_history"), list):
            merged["area_history"] = []
        if not merged.get("last_city"):
            merged["last_city"] = "pallet-town"
        async with db.session() as conn:
            await conn.execute(
                "INSERT INTO adventure_state (owner_id, data) VALUES (?, ?) ON CONFLICT (owner_id) DO NOTHING",
                (uid, json.dumps(merged, ensure_ascii=False)),
            )
            await conn.commit()
        if db_cache is not None:
            try:
                db_cache.set_cached_adventure_state(uid, merged)
            except Exception:
                pass
        return merged
    merged = default | state
    if not isinstance(merged.get("area_history"), list):
        merged["area_history"] = []
    if not merged.get("last_city"):
        merged["last_city"] = "pallet-town"
    if db_cache is not None:
        try:
            db_cache.set_cached_adventure_state(uid, merged)
        except Exception:
            pass
    return merged

async def _save_adventure_state(user_id: str, state: dict) -> None:
    uid = str(user_id)
    async with db.session() as conn:
        await conn.execute(
            "UPDATE adventure_state SET data = ? WHERE owner_id = ?",
            (json.dumps(state, ensure_ascii=False), uid),
        )
        await conn.commit()
    if db_cache is not None:
        try:
            db_cache.set_cached_adventure_state(uid, state)
        except Exception:
            pass


def _daycare_default_record() -> dict:
    return {
        "parents": [None, None],   # Pok√©mon ids
        "eggs": [],                # eggs waiting at daycare (max DAYCARE_EGG_CAP)
        "incubating": [],          # eggs currently in team incubator
        "breed_progress": 0.0,     # legacy key (kept for backward compatibility)
        "last_egg_at": float(time.time()),
        "last_tick": float(time.time()),
    }


def _daycare_get_record(state: dict, city_id: str = DAYCARE_CITY_ID) -> dict:
    all_dc = state.setdefault("daycare", {})
    rec = all_dc.get(city_id)
    if not isinstance(rec, dict):
        rec = _daycare_default_record()
        all_dc[city_id] = rec
    parents = rec.get("parents")
    if not isinstance(parents, list):
        parents = [None, None]
    parents = (parents + [None, None])[:2]
    rec["parents"] = [int(p) if str(p).isdigit() else None for p in parents]
    if not isinstance(rec.get("eggs"), list):
        rec["eggs"] = []
    if not isinstance(rec.get("incubating"), list):
        rec["incubating"] = []
    try:
        rec["breed_progress"] = float(rec.get("breed_progress", 0.0) or 0.0)
    except Exception:
        rec["breed_progress"] = 0.0
    try:
        rec["last_egg_at"] = float(rec.get("last_egg_at", time.time()) or time.time())
    except Exception:
        rec["last_egg_at"] = float(time.time())
    try:
        rec["last_tick"] = float(rec.get("last_tick", time.time()) or time.time())
    except Exception:
        rec["last_tick"] = float(time.time())
    return rec


def _daycare_parent_ids_from_state_data(state: Any) -> set[int]:
    """
    Collect all daycare parent pokemon ids from adventure state payload.
    This is used to keep daycare parents out of PC box indexing/rendering.
    """
    out: set[int] = set()
    if not isinstance(state, dict):
        return out
    all_dc = state.get("daycare")
    if not isinstance(all_dc, dict):
        return out
    for rec in all_dc.values():
        if not isinstance(rec, dict):
            continue
        parents = rec.get("parents")
        if not isinstance(parents, (list, tuple)):
            continue
        for p in list(parents)[:2]:
            try:
                pid = int(p)
            except Exception:
                continue
            if pid > 0:
                out.add(pid)
    return out


async def _daycare_parent_ids_for_owner(owner_id: str) -> set[int]:
    """Load owner adventure state and return daycare parent ids across all daycare entries."""
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT data FROM adventure_state WHERE owner_id=? LIMIT 1",
                (owner_id,),
            )
            row = await cur.fetchone()
            await cur.close()
    except Exception:
        return set()
    if not row:
        return set()
    raw = row["data"] if hasattr(row, "keys") else row[0]
    if isinstance(raw, (bytes, bytearray)):
        try:
            raw = raw.decode("utf-8")
        except Exception:
            raw = ""
    state_obj: Any = raw
    if isinstance(raw, str):
        try:
            state_obj = json.loads(raw)
        except Exception:
            state_obj = {}
    return _daycare_parent_ids_from_state_data(state_obj)


def _daycare_norm_species(species: str) -> str:
    return str(species or "").strip().lower().replace("_", "-").replace(" ", "-")


def _daycare_parse_evolution_blob(raw: Any) -> Any:
    return breeding_mech.parse_evolution_blob(raw)


def _daycare_next_evo_entries(parent_species: str, raw_evolution: Any) -> list[tuple[str, str]]:
    return breeding_mech.next_evo_edges(parent_species, raw_evolution)


async def _daycare_pokedex_rows_for_breeding() -> list[tuple[Any, Any]]:
    rows_out: list[tuple[Any, Any]] = []
    try:
        async with db.session() as conn:
            cur = await conn.execute("SELECT name, evolution FROM pokedex")
            rows = await cur.fetchall()
            await cur.close()
    except Exception:
        return rows_out
    for row in rows:
        name_val = row["name"] if hasattr(row, "keys") else row[0]
        evolution_val = row["evolution"] if hasattr(row, "keys") else row[1]
        rows_out.append((name_val, evolution_val))
    return rows_out


async def _daycare_pre_evo_map() -> dict[str, str]:
    return await breeding_mech.pre_evo_map(_daycare_pokedex_rows_for_breeding)


async def _daycare_resolve_egg_species(species: str) -> str:
    return await breeding_mech.resolve_egg_species(
        species,
        fetch_pokedex_rows=_daycare_pokedex_rows_for_breeding,
        allow_pokeapi_fallback=True,
    )


def _daycare_breeding_source_parent(parent_a: dict, parent_b: dict) -> dict:
    return breeding_mech.breeding_source_parent(parent_a, parent_b)


def _daycare_apply_incense_baby_rules(base_child: str, parent_a: dict, parent_b: dict) -> str:
    return breeding_mech.apply_incense_baby_rules(base_child, parent_a, parent_b, DAYCARE_INCENSE_BABIES)


def _daycare_parse_moves(raw_moves: Any) -> list[str]:
    return breeding_mech.parse_moves(raw_moves)


async def _daycare_egg_move_pool(species: str, generation: int = 1) -> set[str]:
    sp = _daycare_norm_species(species)
    if not sp:
        return set()
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT id FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1",
                (sp,),
            )
            row = await cur.fetchone()
            await cur.close()
            if not row:
                return set()
            species_id = int(row["id"] if hasattr(row, "keys") else row[0])
            cur = await conn.execute(
                """
                SELECT m.name
                FROM learnsets l
                JOIN moves m ON m.id = l.move_id
                WHERE l.species_id=? AND l.generation=? AND LOWER(TRIM(l.method))='egg'
                """,
                (species_id, int(generation)),
            )
            rows = await cur.fetchall()
            await cur.close()
    except Exception:
        return set()
    out: set[str] = set()
    for row in rows:
        name = row["name"] if hasattr(row, "keys") else row[0]
        norm = _daycare_norm_species(name)
        if norm:
            out.add(norm)
    return out


async def _daycare_inherited_egg_moves(parent_a: dict, parent_b: dict, child_species: str) -> list[str]:
    inherited = await breeding_mech.inherited_egg_moves(
        parent_a,
        parent_b,
        child_species,
        egg_move_pool_fetch=(lambda species: _daycare_egg_move_pool(species, generation=1)),
        mirror_herb_items=DAYCARE_MIRROR_HERB_ITEMS,
    )
    return inherited[:2]


def _daycare_showdown_keys(species: str) -> list[str]:
    """
    Build robust Pokemon Showdown sprite keys for daycare rendering.
    Prefers form-specific keys first, then progressively falls back to base species.
    """
    sp = _daycare_norm_species(species)
    if not sp:
        return []

    # Prefer exact species/form first, then trim trailing form tokens.
    seeds: list[str] = [sp]
    toks = [t for t in sp.split("-") if t]
    for i in range(len(toks) - 1, 0, -1):
        base = "-".join(toks[:i])
        if base and base not in seeds:
            seeds.append(base)

    out: list[str] = []
    variant_fn = globals().get("_team_showdown_key_variants")
    for seed in seeds:
        variants: list[str]
        if callable(variant_fn):
            try:
                variants = list(variant_fn(seed))  # type: ignore[misc]
            except Exception:
                variants = [seed]
        else:
            variants = [seed]
        for k in variants:
            k2 = str(k or "").strip().lower()
            if k2 and k2 not in out:
                out.append(k2)
    return out


def _daycare_sprite_folder_candidates(species: str) -> list[str]:
    """Folder candidates for local on-disk fallback, form-first then base."""
    sp = _daycare_norm_species(species)
    if not sp:
        return []
    out: list[str] = [sp]
    toks = [t for t in sp.split("-") if t]
    for i in range(len(toks) - 1, 0, -1):
        base = "-".join(toks[:i])
        if base and base not in out:
            out.append(base)
    return out


_DAYCARE_POKESPRITE_ZIP_ARCS: Optional[set[str]] = None
_DAYCARE_POKESPRITE_EGG_ICON: Optional[Path] = None


def _daycare_pokesprite_zip_arcs() -> set[str]:
    """Cached list of usable regular sprite paths from pokesprite-master.zip."""
    global _DAYCARE_POKESPRITE_ZIP_ARCS
    if _DAYCARE_POKESPRITE_ZIP_ARCS is not None:
        return _DAYCARE_POKESPRITE_ZIP_ARCS
    arcs: set[str] = set()
    if not POKESPRITE_MASTER_ZIP.exists():
        _DAYCARE_POKESPRITE_ZIP_ARCS = arcs
        return arcs
    try:
        with zipfile.ZipFile(str(POKESPRITE_MASTER_ZIP), "r") as zf:
            for raw in zf.namelist():
                arc = str(raw or "").strip().replace("\\", "/")
                low = arc.lower()
                if "/pokemon-gen8/regular/" in low and low.endswith(".png"):
                    arcs.add(arc)
    except Exception:
        arcs = set()
    _DAYCARE_POKESPRITE_ZIP_ARCS = arcs
    return arcs


def _daycare_extract_pokesprite_box(species: str) -> Optional[Path]:
    """
    Extract a species icon from pokesprite-master.zip into daycare cache and return path.
    Uses form-first, then base-form fallback candidates.
    """
    sp = _daycare_norm_species(species)
    if not sp or not POKESPRITE_MASTER_ZIP.exists():
        return None
    arcs = _daycare_pokesprite_zip_arcs()
    if not arcs:
        return None
    candidates = _daycare_sprite_folder_candidates(sp)
    prefixes = ("pokesprite-master/pokemon-gen8/regular", "pokemon-gen8/regular")
    for folder in candidates:
        try:
            out_dir = DAYCARE_ZIP_CACHE_DIR / folder
            out_path = out_dir / "box.png"
            if out_path.exists() and out_path.stat().st_size > 0:
                return out_path
        except Exception:
            out_path = None  # type: ignore[assignment]

        arc_match: Optional[str] = None
        for pref in prefixes:
            arc = f"{pref}/{folder}.png"
            if arc in arcs:
                arc_match = arc
                break
        if not arc_match:
            continue
        try:
            with zipfile.ZipFile(str(POKESPRITE_MASTER_ZIP), "r") as zf:
                data = zf.read(arc_match)
            out_dir = DAYCARE_ZIP_CACHE_DIR / folder
            out_dir.mkdir(parents=True, exist_ok=True)
            out_path = out_dir / "box.png"
            out_path.write_bytes(data)
            if out_path.exists() and out_path.stat().st_size > 0:
                return out_path
        except Exception:
            continue
    return None


def _daycare_extract_pokesprite_egg_icon() -> Optional[Path]:
    """
    Extract the daycare egg icon from pokesprite zip (menu/box sprite style).
    Cached on disk and in-memory after first successful extraction.
    """
    global _DAYCARE_POKESPRITE_EGG_ICON
    if _DAYCARE_POKESPRITE_EGG_ICON is not None:
        try:
            if _DAYCARE_POKESPRITE_EGG_ICON.exists() and _DAYCARE_POKESPRITE_EGG_ICON.stat().st_size > 0:
                return _DAYCARE_POKESPRITE_EGG_ICON
        except Exception:
            _DAYCARE_POKESPRITE_EGG_ICON = None
    if not POKESPRITE_MASTER_ZIP.exists():
        return None
    out_path = DAYCARE_ZIP_CACHE_DIR / "_egg" / "egg.png"
    try:
        if out_path.exists() and out_path.stat().st_size > 0:
            _DAYCARE_POKESPRITE_EGG_ICON = out_path
            return out_path
    except Exception:
        pass
    candidates = (
        "pokesprite-master/icons/pokemon/egg.png",
        "icons/pokemon/egg.png",
        "pokesprite-master/pokemon-gen8/egg.png",
        "pokemon-gen8/egg.png",
    )
    try:
        with zipfile.ZipFile(str(POKESPRITE_MASTER_ZIP), "r") as zf:
            names = set(str(n or "").replace("\\", "/") for n in zf.namelist())
            picked = next((arc for arc in candidates if arc in names), None)
            if not picked:
                return None
            data = zf.read(picked)
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_bytes(data)
        if out_path.exists() and out_path.stat().st_size > 0:
            _DAYCARE_POKESPRITE_EGG_ICON = out_path
            return out_path
    except Exception:
        return None
    return None


def _daycare_norm_item(item_id: str | None) -> str:
    return str(item_id or "").strip().lower().replace("_", "-").replace(" ", "-")


def _daycare_ability_key(name: str | None) -> str:
    return str(name or "").strip().lower().replace("_", "-").replace(" ", "-")


def _daycare_short_to_long_stats(short: dict) -> dict:
    return {
        "hp": int(short.get("hp", 0)),
        "attack": int(short.get("atk", 0)),
        "defense": int(short.get("defn", 0)),
        "special_attack": int(short.get("spa", 0)),
        "special_defense": int(short.get("spd", 0)),
        "speed": int(short.get("spe", 0)),
    }


def _daycare_parse_egg_groups(entry: dict | None) -> set[str]:
    return breeding_mech.parse_egg_groups(entry)


async def _daycare_species_entry(species: str) -> Optional[dict]:
    key = _daycare_norm_species(species)
    if not key:
        return None
    try:
        if db_cache is not None:
            cached = db_cache.get_cached_pokedex(key) or db_cache.get_cached_pokedex(key.replace("-", " "))
            if cached is not None:
                return cached
    except Exception:
        pass
    try:
        row = await db.get_pokedex_by_name(key)
        if row:
            return row
    except Exception:
        pass
    try:
        return await ensure_species_and_learnsets(key)
    except Exception:
        return None


def _daycare_pair_info(
    parent_a: dict,
    parent_b: dict,
    entry_a: dict | None,
    entry_b: dict | None,
) -> dict:
    return breeding_mech.pair_info(parent_a, parent_b, entry_a, entry_b)


def _daycare_pick_nature(parent_a: dict, parent_b: dict) -> str:
    return breeding_mech.pick_nature(parent_a, parent_b)


def _daycare_pick_ivs(parent_a: dict, parent_b: dict) -> dict:
    return breeding_mech.pick_ivs(parent_a, parent_b, normalize_ivs_evs=_normalize_ivs_evs)


def _daycare_pick_ball(parent_a: dict, parent_b: dict, pair_info: dict) -> str:
    return breeding_mech.pick_ball(parent_a, parent_b, pair_info)


def _daycare_pick_ability(parent_a: dict, parent_b: dict, child_entry: dict, pair_info: dict) -> tuple[str, bool]:
    return breeding_mech.pick_ability(
        parent_a,
        parent_b,
        child_entry,
        pair_info,
        parse_abilities_fn=parse_abilities,
        roll_hidden_ability_fn=(lambda abilities: roll_hidden_ability(abilities, ha_denominator=20)),
    )


async def _daycare_create_egg(parent_a: dict, parent_b: dict, pair_info: dict) -> Optional[dict]:
    return await breeding_mech.create_egg(
        parent_a,
        parent_b,
        pair_info,
        resolve_egg_species_fn=_daycare_resolve_egg_species,
        species_entry_fetch=_daycare_species_entry,
        pick_ivs_fn=_daycare_pick_ivs,
        pick_nature_fn=_daycare_pick_nature,
        pick_ability_fn=_daycare_pick_ability,
        pick_ball_fn=_daycare_pick_ball,
        inherited_egg_moves_fn=_daycare_inherited_egg_moves,
        incense_babies=DAYCARE_INCENSE_BABIES,
        hatch_min=DAYCARE_HATCH_MIN,
        hatch_max=DAYCARE_HATCH_MAX,
        pre_evo_map_fetch=_daycare_pre_evo_map,
    )


async def _daycare_team_count(owner_id: str) -> int:
    return await _team_non_egg_count(owner_id)


async def _team_non_egg_count(owner_id: str, conn: Any | None = None) -> int:
    own_conn = conn is None
    if own_conn:
        try:
            conn = await db.connect()
        except Exception:
            return 0
    try:
        cur = await conn.execute(
            """
            SELECT COUNT(*) AS c
            FROM pokemons
            WHERE owner_id=?
              AND team_slot BETWEEN 1 AND 6
              AND LOWER(REPLACE(REPLACE(species,' ','-'),'_','-')) <> 'egg'
            """,
            (owner_id,),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return 0
        return int((row.get("c") if hasattr(row, "keys") else row[0]) or 0)
    except Exception:
        return 0
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _team_has_species(
    owner_id: str,
    species: str,
    *,
    exclude_mon_id: Optional[int] = None,
    conn: Any | None = None,
) -> bool:
    sp = _daycare_norm_species(species)
    if not sp or sp == "egg":
        return False
    own_conn = conn is None
    if own_conn:
        try:
            conn = await db.connect()
        except Exception:
            return False
    try:
        if exclude_mon_id is not None:
            cur = await conn.execute(
                """
                SELECT 1
                FROM pokemons
                WHERE owner_id=?
                  AND team_slot BETWEEN 1 AND 6
                  AND id<>?
                  AND LOWER(REPLACE(REPLACE(species,' ','-'),'_','-'))=?
                LIMIT 1
                """,
                (owner_id, int(exclude_mon_id), sp),
            )
        else:
            cur = await conn.execute(
                """
                SELECT 1
                FROM pokemons
                WHERE owner_id=?
                  AND team_slot BETWEEN 1 AND 6
                  AND LOWER(REPLACE(REPLACE(species,' ','-'),'_','-'))=?
                LIMIT 1
                """,
                (owner_id, sp),
            )
        row = await cur.fetchone()
        await cur.close()
        return bool(row)
    except Exception:
        return False
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _compact_team_slots(owner_id: str, *, max_slots: int = 6) -> int:
    """
    Repack team slots to fill from slot 1 upward while preserving order.
    Returns number of Pok√©mon rows that were moved.
    """
    moved = 0
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                """
                SELECT id, team_slot
                FROM pokemons
                WHERE owner_id=? AND team_slot BETWEEN 1 AND ?
                ORDER BY team_slot, id
                """,
                (owner_id, int(max_slots)),
            )
            rows = await cur.fetchall()
            await cur.close()
            target_slot = 1
            for row in rows:
                mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
                current_slot = int(row["team_slot"] if hasattr(row, "keys") else row[1])
                if current_slot != target_slot:
                    await conn.execute(
                        "UPDATE pokemons SET team_slot=? WHERE owner_id=? AND id=?",
                        (int(target_slot), owner_id, mon_id),
                    )
                    moved += 1
                target_slot += 1
            if moved > 0:
                await conn.commit()
    except Exception:
        return 0
    if moved > 0:
        try:
            db.invalidate_pokemons_cache(owner_id)
        except Exception:
            pass
    return moved


async def _daycare_has_hatch_boost(owner_id: str) -> bool:
    oid = str(owner_id)
    cached = _DAYCARE_HATCH_BOOST_CACHE.get(oid)
    if cached is not None:
        val, ts = cached
        if (time.time() - float(ts)) <= DAYCARE_HATCH_BOOST_CACHE_TTL_SECONDS:
            return bool(val)
        _DAYCARE_HATCH_BOOST_CACHE.pop(oid, None)
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT ability FROM pokemons WHERE owner_id=? AND team_slot BETWEEN 1 AND 6",
                (oid,),
            )
            rows = await cur.fetchall()
            await cur.close()
        for row in rows:
            raw = row.get("ability") if hasattr(row, "keys") else row[0]
            if _daycare_ability_key(raw) in DAYCARE_HATCH_BOOST_ABILITIES:
                _DAYCARE_HATCH_BOOST_CACHE[oid] = (True, float(time.time()))
                return True
    except Exception:
        pass
    _DAYCARE_HATCH_BOOST_CACHE[oid] = (False, float(time.time()))
    return False


async def _daycare_has_oval_charm(owner_id: str) -> bool:
    oid = str(owner_id)
    cached = _DAYCARE_OVAL_CHARM_CACHE.get(oid)
    if cached is not None:
        val, ts = cached
        if (time.time() - float(ts)) <= DAYCARE_OVAL_CHARM_CACHE_TTL_SECONDS:
            return bool(val)
        _DAYCARE_OVAL_CHARM_CACHE.pop(oid, None)
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                """
                SELECT qty
                FROM user_items
                WHERE owner_id=? AND item_id IN ('oval-charm', 'oval_charm')
                ORDER BY qty DESC
                LIMIT 1
                """,
                (oid,),
            )
            row = await cur.fetchone()
            await cur.close()
        if not row:
            _DAYCARE_OVAL_CHARM_CACHE[oid] = (False, float(time.time()))
            return False
        qty = row["qty"] if hasattr(row, "keys") else row[0]
        has_charm = int(qty or 0) > 0
        _DAYCARE_OVAL_CHARM_CACHE[oid] = (bool(has_charm), float(time.time()))
        return bool(has_charm)
    except Exception:
        return False


async def _daycare_hatch_to_team(owner_id: str, egg: dict) -> Optional[dict]:
    species = await _daycare_resolve_egg_species(str(egg.get("species") or ""))
    if not species:
        return None
    entry = await _daycare_species_entry(species)
    if not entry:
        return None

    raw_stats = entry.get("stats")
    if isinstance(raw_stats, str):
        try:
            raw_stats = json.loads(raw_stats)
        except Exception:
            raw_stats = {}
    base_long = _normalize_stats_for_generator(raw_stats or {})
    ivs_short = _normalize_ivs_evs(egg.get("ivs"), 0)
    ivs_long = _daycare_short_to_long_stats(ivs_short)
    evs_long = _daycare_short_to_long_stats({"hp": 0, "atk": 0, "defn": 0, "spa": 0, "spd": 0, "spe": 0})
    nature = str(egg.get("nature") or "hardy").strip().lower() or "hardy"
    level = 1
    try:
        final_stats = calc_all_stats(base_long, ivs_long, evs_long, level, nature)
    except Exception:
        return None

    abilities_raw = entry.get("abilities") or []
    regs, hides = parse_abilities(abilities_raw)
    regs_norm = [_daycare_ability_key(a) for a in regs if a]
    hides_norm = [_daycare_ability_key(a) for a in hides if a]

    ability = _daycare_ability_key(egg.get("ability"))
    is_hidden = bool(egg.get("is_hidden_ability"))
    if is_hidden and ability not in hides_norm:
        is_hidden = False
    if not ability or (is_hidden and ability not in hides_norm) or (not is_hidden and ability not in regs_norm):
        if regs_norm:
            ability = random.choice(regs_norm)
            is_hidden = False
        elif hides_norm:
            ability = random.choice(hides_norm)
            is_hidden = True
        else:
            ability = "run-away"
            is_hidden = False

    gender = _roll_gender_from_ratio(_gender_ratio_from_entry(entry))
    tera_type = _roll_default_tera_type(_extract_species_types(entry))
    shiny = await shiny_roll(_wild_shiny_denominator())

    try:
        mon_id = await db.add_pokemon_with_stats(
            owner_id=owner_id,
            species=species,
            level=level,
            final_stats=final_stats,
            ivs=ivs_long,
            evs=evs_long,
            nature=nature,
            ability=ability,
            gender=gender,
            form=None,
            can_gigantamax=False,
            tera_type=tera_type,
        )
    except Exception:
        return None

    try:
        async with db.session() as conn:
            exp_group = await _get_exp_group_for_species(conn, species)
            initial_exp = await _get_exp_total_for_level(conn, exp_group, level)
            await conn.execute(
                "UPDATE pokemons SET exp=?, exp_group=?, hp_now=? WHERE owner_id=? AND id=?",
                (initial_exp, exp_group, int(final_stats.get("hp", 1)), owner_id, mon_id),
            )
            if shiny:
                await conn.execute("UPDATE pokemons SET shiny=1 WHERE owner_id=? AND id=?", (owner_id, mon_id))
            if is_hidden:
                try:
                    await conn.execute("UPDATE pokemons SET is_hidden_ability=1 WHERE owner_id=? AND id=?", (owner_id, mon_id))
                except Exception:
                    pass
            await conn.commit()
    except Exception:
        pass

    try:
        species_id = int(entry.get("id")) if entry.get("id") is not None else None
    except Exception:
        species_id = None
    try:
        moves = await _default_levelup_moves(species_id, level, 1) if species_id else ["Tackle"]
    except Exception:
        moves = ["Tackle"]
    egg_moves = _daycare_parse_moves(egg.get("egg_moves"))
    if egg_moves:
        # Mirror Herb support: inherited egg moves are injected first, then defaults.
        merged: list[str] = []
        for mv in egg_moves + _daycare_parse_moves(moves):
            pretty = mv.replace("-", " ").title()
            if pretty and pretty not in merged:
                merged.append(pretty)
        moves = merged[:4] if merged else (moves[:4] if isinstance(moves, list) else ["Tackle"])
    try:
        await db.set_pokemon_moves(owner_id, mon_id, moves[:4] if moves else ["Tackle"])
    except Exception:
        pass

    try:
        ball = str(egg.get("pokeball") or "poke-ball").strip().lower()
        await _set_pokeball(owner_id, mon_id, ball)
    except Exception:
        pass

    placed: dict[str, Any] = {"id": int(mon_id), "species": species, "level": level, "destination": "box"}
    try:
        dup = await _team_has_species(owner_id, species, exclude_mon_id=int(mon_id))
    except Exception:
        dup = False
    slot = await db.next_free_team_slot(owner_id)
    placed_team = False
    if slot is not None and not dup:
        try:
            await db.set_team_slot(owner_id, mon_id, slot)
            placed = {
                "id": int(mon_id),
                "species": species,
                "level": level,
                "destination": "team",
                "team_slot": int(slot),
            }
            placed_team = True
        except Exception:
            pass
    if not placed_team:
        try:
            await _box_prepare_storage(owner_id)
            async with db.session() as conn:
                cur = await conn.execute(
                    "SELECT box_no, box_pos FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                    (owner_id, int(mon_id)),
                )
                row = await cur.fetchone()
                await cur.close()
            if row:
                bno = int((row["box_no"] if hasattr(row, "keys") else row[0]) or 0)
                bpos = int((row["box_pos"] if hasattr(row, "keys") else row[1]) or 0)
                if bno > 0 and bpos > 0:
                    placed["box_no"] = bno
                    placed["box_pos"] = bpos
            if dup:
                placed["reason"] = "duplicate_team_species"
            elif slot is None:
                placed["reason"] = "team_full"
            else:
                placed["reason"] = "team_place_failed"
        except Exception:
            pass

    db.invalidate_pokemons_cache(owner_id)
    return placed


async def _daycare_parent_rows(owner_id: str, parent_ids: list[Optional[int]]) -> tuple[list[Optional[dict]], bool]:
    id_map: dict[int, dict] = {}
    ids = [int(i) for i in parent_ids if i is not None]
    if ids:
        placeholders = ",".join("?" for _ in ids)
        try:
            async with db.session() as conn:
                cur = await conn.execute(
                    f"SELECT id, species, level, gender, nature, ability, held_item, ivs, is_hidden_ability, pokeball, moves "
                    f"FROM pokemons WHERE owner_id=? AND id IN ({placeholders})",
                    (owner_id, *ids),
                )
                rows = await cur.fetchall()
                await cur.close()
            for row in rows:
                d = dict(row) if hasattr(row, "keys") else {
                    "id": row[0], "species": row[1], "level": row[2], "gender": row[3],
                    "nature": row[4], "ability": row[5], "held_item": row[6], "ivs": row[7],
                    "is_hidden_ability": row[8], "pokeball": row[9], "moves": row[10],
                }
                id_map[int(d["id"])] = d
        except Exception:
            pass
    out: list[Optional[dict]] = []
    changed = False
    for pid in parent_ids:
        if pid is None:
            out.append(None)
            continue
        row = id_map.get(int(pid))
        if row is None:
            out.append(None)
            changed = True
        else:
            out.append(row)
    return out, changed


async def _daycare_pair_context(owner_id: str, state: dict) -> tuple[dict, list[Optional[dict]], dict, bool]:
    rec = _daycare_get_record(state, DAYCARE_CITY_ID)
    parent_ids = rec.get("parents", [None, None])
    if not isinstance(parent_ids, list):
        parent_ids = [None, None]
    parent_ids = (parent_ids + [None, None])[:2]
    parent_ids = [int(p) if str(p).isdigit() else None for p in parent_ids]
    rows, changed = await _daycare_parent_rows(owner_id, parent_ids)
    if changed:
        rec["parents"] = [r.get("id") if r else None for r in rows]

    pair_info = {
        "can_breed": False,
        "reason": "Place two compatible Pok√©mon in daycare.",
        "child_species": None,
        "rate": 0.0,
    }
    if rows[0] and rows[1]:
        e1 = await _daycare_species_entry(str(rows[0].get("species") or ""))
        e2 = await _daycare_species_entry(str(rows[1].get("species") or ""))
        pair_info = _daycare_pair_info(rows[0], rows[1], e1, e2)
    return rec, rows, pair_info, changed


async def _daycare_tick(owner_id: str, state: dict, *, command_credit: float = 0.0) -> tuple[bool, list[str]]:
    rec, parents, pair_info, changed = await _daycare_pair_context(owner_id, state)
    now = float(time.time())
    try:
        last_tick = float(rec.get("last_tick", now) or now)
    except Exception:
        last_tick = now
    elapsed = max(0.0, now - last_tick)
    rec["last_tick"] = now

    try:
        eggs = rec.get("eggs")
        if not isinstance(eggs, list):
            eggs = []
            rec["eggs"] = eggs
            changed = True
        incubating = rec.get("incubating")
        if not isinstance(incubating, list):
            incubating = []
            rec["incubating"] = incubating
            changed = True
    except Exception:
        rec["eggs"] = []
        rec["incubating"] = []
        eggs = rec["eggs"]
        incubating = rec["incubating"]
        changed = True

    # Egg production at daycare (strict cadence: at most 1 egg per hour, up to cap)
    if pair_info.get("can_breed"):
        interval = max(60.0, float(DAYCARE_EGG_INTERVAL_SECONDS))
        try:
            pair_rate = float(pair_info.get("rate", 1.0) or 1.0)
        except Exception:
            pair_rate = 1.0
        pair_rate = max(0.35, pair_rate)
        interval = max(60.0, interval / pair_rate)
        if await _daycare_has_oval_charm(owner_id):
            interval = max(60.0, interval * float(DAYCARE_OVAL_CHARM_INTERVAL_MULT))
            oval_charm_active = True
        else:
            oval_charm_active = False
        try:
            last_egg_at = float(rec.get("last_egg_at", now) or now)
        except Exception:
            last_egg_at = now
            rec["last_egg_at"] = now
            changed = True
        if last_egg_at > now:
            last_egg_at = now
            rec["last_egg_at"] = now
            changed = True

        if len(eggs) >= DAYCARE_EGG_CAP:
            # Pause timer while egg storage is full so no backlog forms.
            if abs(last_egg_at - now) > 1.0:
                rec["last_egg_at"] = now
                changed = True
        else:
            produced = False
            produced_count = 0
            while (now - last_egg_at) >= interval and len(eggs) < DAYCARE_EGG_CAP:
                if parents[0] is None or parents[1] is None:
                    break
                egg = await _daycare_create_egg(parents[0], parents[1], pair_info)
                if not egg:
                    break
                eggs.append(egg)
                produced_count += 1
                last_egg_at += interval
                produced = True
                changed = True
                if (
                    oval_charm_active
                    and len(eggs) < DAYCARE_EGG_CAP
                    and random.random() < float(DAYCARE_OVAL_CHARM_BONUS_EGG_CHANCE)
                ):
                    bonus = await _daycare_create_egg(parents[0], parents[1], pair_info)
                    if bonus:
                        eggs.append(bonus)
                        produced_count += 1
                        changed = True
            if produced:
                rec["last_egg_at"] = last_egg_at
                try:
                    parent_ids = [
                        int(parents[0].get("id") or 0) if parents and parents[0] else 0,
                        int(parents[1].get("id") or 0) if parents and parents[1] else 0,
                    ]
                    await register_stats.increment_eggs_bred(owner_id, parent_ids, count=max(1, int(produced_count or 1)))
                except Exception:
                    pass

        # Keep legacy field clean after migrating to real-time cadence.
        try:
            if float(rec.get("breed_progress", 0.0) or 0.0) != 0.0:
                rec["breed_progress"] = 0.0
                changed = True
        except Exception:
            rec["breed_progress"] = 0.0
            changed = True
    else:
        try:
            if float(rec.get("breed_progress", 0.0) or 0.0) != 0.0:
                rec["breed_progress"] = 0.0
                changed = True
        except Exception:
            rec["breed_progress"] = 0.0
            changed = True
        if rec.get("last_egg_at") is None:
            rec["last_egg_at"] = now
            changed = True

    # Egg hatching while in team incubator
    hatch_messages: list[str] = []
    if incubating:
        has_boost = await _daycare_has_hatch_boost(owner_id)
        # Commands slightly accelerate hatch progress for the owner only.
        cmd_bonus = min(max(0.0, float(command_credit)), float(DAYCARE_HATCH_COMMAND_BONUS_CAP))
        hatch_gain = cmd_bonus + (elapsed / 55.0)
        if has_boost:
            hatch_gain *= 2.0
        survivors: list[dict] = []
        for egg in incubating:
            if not isinstance(egg, dict):
                changed = True
                continue
            try:
                egg["progress"] = float(egg.get("progress", 0.0) or 0.0) + hatch_gain
                hatch_steps = max(1.0, float(egg.get("hatch_steps", DAYCARE_HATCH_MIN) or DAYCARE_HATCH_MIN))
            except Exception:
                egg["progress"] = 0.0
                hatch_steps = DAYCARE_HATCH_MIN
            if egg["progress"] >= hatch_steps:
                hatched = await _daycare_hatch_to_team(owner_id, egg)
                if hatched:
                    display = str(hatched.get("species") or "Pok√©mon").replace("-", " ").title()
                    if str(hatched.get("destination")) == "team":
                        hatch_messages.append(f"ü•ö‚û°Ô∏è **{display}** hatched and joined your team!")
                    else:
                        bno = hatched.get("box_no")
                        bpos = hatched.get("box_pos")
                        if bno and bpos:
                            hatch_messages.append(f"ü•ö‚û°Ô∏è **{display}** hatched and was sent to **Box {bno}, Slot {bpos}**.")
                        else:
                            hatch_messages.append(f"ü•ö‚û°Ô∏è **{display}** hatched and was sent to your **PC Box**.")
                    changed = True
                    continue
                # Hatch failed; keep the egg and try again next tick.
                egg["progress"] = hatch_steps - 0.25
            survivors.append(egg)
        if len(survivors) != len(incubating):
            changed = True
        rec["incubating"] = survivors

    # Keep incubation cap sane.
    if len(rec.get("incubating", [])) > DAYCARE_INCUBATE_MAX:
        rec["incubating"] = list(rec.get("incubating", []))[:DAYCARE_INCUBATE_MAX]
        changed = True

    return changed, hatch_messages


def _daycare_icon_path_for_species(species: str) -> Optional[Path]:
    sp = _daycare_norm_species(species)
    if not sp:
        return None

    # Primary source for daycare: uploaded box/menu sprite zip.
    # 1) Uploaded pokesprite zip, extracted on-demand to a local cache.
    zip_icon = _daycare_extract_pokesprite_box(sp)
    if zip_icon is not None:
        try:
            if zip_icon.exists() and zip_icon.stat().st_size > 0:
                return zip_icon
        except Exception:
            pass

    # 2) Existing extracted box sprite folders.
    folder_candidates = _daycare_sprite_folder_candidates(sp)
    for folder in folder_candidates:
        p = BOX_SPRITES_DIR / folder / "box.png"
        try:
            if p.exists() and p.stat().st_size > 0:
                return p
        except Exception:
            pass

    # 3) Fallback to animated Showdown cache if no box/menu sprite exists.
    download_fn = globals().get("_team_download_showdown_gif")
    if callable(download_fn):
        for key in _daycare_showdown_keys(sp):
            try:
                p = download_fn(key, shiny=False)  # type: ignore[misc]
            except Exception:
                p = None
            if p is None:
                continue
            try:
                pp = Path(p)
                if pp.exists() and pp.stat().st_size > 0:
                    return pp
            except Exception:
                continue

    # 4) Last-resort local fallback.
    for root in (LEGACY_SPRITES_DIR, Path(__file__).resolve().parent / "sprites", BOX_SPRITES_DIR):
        for folder in folder_candidates:
            for fname in ("box.png", "icon.png", "animated-front.gif", "front.png"):
                p = root / folder / fname
                try:
                    if p.exists() and p.stat().st_size > 0:
                        return p
                except Exception:
                    pass
    return None


def _daycare_random_positions(count: int) -> list[tuple[int, int]]:
    # Random movement zones constrained to the inside grass only.
    # Coordinates are top-left anchors for daycare sprites.
    zones = [
        (56, 128, 122, 186),   # left grass patch
        (248, 132, 314, 190),  # right grass patch
        (170, 112, 218, 150),  # center-top grass near house
    ]
    out: list[tuple[int, int]] = []
    min_dist = 44
    tries = 0
    while len(out) < max(0, int(count)) and tries < 240:
        tries += 1
        x0, y0, x1, y1 = random.choice(zones)
        x = random.randint(x0, x1)
        y = random.randint(y0, y1)
        if all(((x - ox) ** 2 + (y - oy) ** 2) >= (min_dist ** 2) for ox, oy in out):
            out.append((x, y))
    while len(out) < count:
        zx0, zy0, zx1, zy1 = zones[len(out) % len(zones)]
        out.append(((zx0 + zx1) // 2, (zy0 + zy1) // 2))
    return out


def _embed_with_daycare_panel(
    title: str,
    description: str,
    parent_species: list[str],
    egg_count: int,
) -> tuple[discord.Embed, list[discord.File]]:
    if Image is None:
        return _embed_with_image(title, description, ASSETS_DAYCARE)
    try:
        if not ASSETS_DAYCARE.exists():
            return _embed_with_image(title, description, ASSETS_DAYCARE)
        base = Image.open(str(ASSETS_DAYCARE)).convert("RGBA")
        positions = _daycare_random_positions(len(parent_species))
        try:
            resample_smooth = Image.Resampling.LANCZOS
            resample_pixel = Image.Resampling.NEAREST
        except Exception:
            resample_smooth = Image.BICUBIC
            resample_pixel = Image.NEAREST
        try:
            from PIL import ImageSequence  # type: ignore
        except Exception:
            ImageSequence = None  # type: ignore

        def _fit_daycare_sprite(src_img: Any, max_size: tuple[int, int], resample_mode: Any) -> Any:
            """Scale sprite to target bounds; upscale small menu icons for visibility."""
            img = src_img.convert("RGBA")
            w, h = img.size
            if w <= 0 or h <= 0:
                return img
            max_w = max(1, int(max_size[0]))
            max_h = max(1, int(max_size[1]))
            scale = min(max_w / float(w), max_h / float(h))
            # Keep tiny icons readable in daycare by upscaling toward target bounds.
            if scale >= 1.0:
                new_w = max(1, int(round(w * scale)))
                new_h = max(1, int(round(h * scale)))
                if new_w != w or new_h != h:
                    return img.resize((new_w, new_h), resample=resample_mode)
                return img
            new_w = max(1, int(round(w * scale)))
            new_h = max(1, int(round(h * scale)))
            return img.resize((new_w, new_h), resample=resample_mode)

        sprite_layers: list[dict[str, Any]] = []
        for species, (x, y) in zip(parent_species, positions):
            icon_path = _daycare_icon_path_for_species(species)
            if not icon_path:
                continue
            try:
                is_box_icon = str(getattr(icon_path, "name", "")).lower() == "box.png"
                is_gif = str(getattr(icon_path, "suffix", "")).lower() == ".gif"
                if is_gif:
                    max_size = DAYCARE_GIF_MAX_SIZE
                    sprite_resample = resample_pixel
                elif is_box_icon:
                    max_size = DAYCARE_BOX_MAX_SIZE
                    sprite_resample = resample_pixel
                else:
                    max_size = DAYCARE_STATIC_MAX_SIZE
                    sprite_resample = resample_smooth

                src = Image.open(str(icon_path))
                frames: list[Any] = []
                n_frames = int(getattr(src, "n_frames", 1) or 1)
                if is_gif and ImageSequence is not None and n_frames > 1:
                    try:
                        for i, fr in enumerate(ImageSequence.Iterator(src)):
                            if i >= DAYCARE_MAX_ANIM_FRAMES:
                                break
                            sprite = _fit_daycare_sprite(fr, max_size, sprite_resample)
                            frames.append(sprite)
                    except Exception:
                        frames = []
                if not frames:
                    sprite = _fit_daycare_sprite(src, max_size, sprite_resample)
                    frames = [sprite]
                if not frames:
                    continue

                dx = max(0, min(int(x), max(0, base.width - frames[0].width)))
                dy = max(0, min(int(y), max(0, base.height - frames[0].height)))
                sprite_layers.append({"frames": frames, "dest": (dx, dy)})
            except Exception:
                continue

        egg_layer = Image.new("RGBA", base.size, (0, 0, 0, 0))
        egg_count = max(0, min(int(egg_count or 0), DAYCARE_EGG_CAP))
        egg_icon_path = _daycare_extract_pokesprite_egg_icon()
        if egg_icon_path is None and ASSETS_DAYCARE_EGG.exists():
            egg_icon_path = ASSETS_DAYCARE_EGG
        if egg_count > 0 and egg_icon_path is not None:
            try:
                egg_icon = Image.open(str(egg_icon_path)).convert("RGBA")
                egg_icon.thumbnail((34, 34), resample=resample_pixel)
                egg_spots = [(255, 194), (284, 184), (313, 194)]
                for i in range(egg_count):
                    ex, ey = egg_spots[i]
                    egg_layer.alpha_composite(egg_icon, dest=(ex, ey))
            except Exception:
                pass

        frame_count = 1
        for layer in sprite_layers:
            try:
                frame_count = max(frame_count, len(layer.get("frames") or []))
            except Exception:
                continue
        frame_count = max(1, min(DAYCARE_MAX_ANIM_FRAMES, int(frame_count)))

        buf = BytesIO()
        if frame_count > 1:
            out_frames: list[Any] = []
            for fi in range(frame_count):
                frame = base.copy()
                for layer in sprite_layers:
                    frames = layer.get("frames") or []
                    if not frames:
                        continue
                    if len(frames) > 1:
                        src_i = int((fi * len(frames)) / frame_count) % len(frames)
                    else:
                        src_i = 0
                    try:
                        frame.alpha_composite(frames[src_i], dest=layer["dest"])
                    except Exception:
                        continue
                frame.alpha_composite(egg_layer)
                out_frames.append(frame)
            out_frames[0].save(
                buf,
                format="GIF",
                save_all=True,
                append_images=out_frames[1:],
                duration=int(TEAM_BATTLE_SYNC_DURATION_MS),
                loop=0,
                disposal=2,
            )
            filename = "daycare_panel.gif"
        else:
            frame = base.copy()
            for layer in sprite_layers:
                frames = layer.get("frames") or []
                if not frames:
                    continue
                try:
                    frame.alpha_composite(frames[0], dest=layer["dest"])
                except Exception:
                    continue
            frame.alpha_composite(egg_layer)
            frame.save(buf, format="PNG")
            filename = "daycare_panel.png"

        buf.seek(0)
        f = discord.File(fp=buf, filename=filename)
        emb = discord.Embed(title=title, description=description)
        emb.set_image(url=f"attachment://{filename}")
        return emb, [f]
    except Exception:
        return _embed_with_image(title, description, ASSETS_DAYCARE)

# ---------------- POKEDEX (per-user) ----------------
async def _ensure_pokedex_tables() -> None:
    """Create per-user Pok√©dex tracking tables if they don't exist."""
    async with db.session() as conn:
        await conn.execute(
            """
            CREATE TABLE IF NOT EXISTS user_pokedex (
                owner_id    TEXT NOT NULL,
                species     TEXT NOT NULL,
                seen_count  INTEGER DEFAULT 0,
                caught_count INTEGER DEFAULT 0,
                last_seen   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (owner_id, species)
            )
            """
        )
        await conn.commit()


async def pokedex_mark_seen(user_id: str, species: str, caught: bool = False) -> None:
    """Increment seen (and optionally caught) for a species for this user."""
    await _ensure_pokedex_tables()
    species = species.lower()
    async with db.session() as conn:
        await conn.execute(
            """
            INSERT INTO user_pokedex(owner_id, species, seen_count, caught_count, last_seen)
            VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
            ON CONFLICT(owner_id, species) DO UPDATE SET
                seen_count = user_pokedex.seen_count + 1,
                caught_count = user_pokedex.caught_count + (excluded.caught_count),
                last_seen = CURRENT_TIMESTAMP
            """,
            (user_id, species, 1, 1 if caught else 0),
        )
        await conn.commit()


async def pokedex_get_entry(user_id: str, species: str) -> dict:
    """Return pokedex entry for user/species, defaults to zeros."""
    await _ensure_pokedex_tables()
    species = species.lower()
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT seen_count, caught_count, last_seen FROM user_pokedex WHERE owner_id=? AND species=?",
            (user_id, species),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return {"seen": 0, "caught": 0, "last_seen": None}
        return {
            "seen": row["seen_count"] if hasattr(row, "keys") else row[0],
            "caught": row["caught_count"] if hasattr(row, "keys") else row[1],
            "last_seen": row["last_seen"] if hasattr(row, "keys") else row[2],
        }


async def pokedex_summary(user_id: str) -> dict:
    """Return total seen/caught counts for a user."""
    await _ensure_pokedex_tables()
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT SUM(seen_count) as seen, SUM(caught_count) as caught FROM user_pokedex WHERE owner_id=?",
            (user_id,),
        )
        row = await cur.fetchone()
        await cur.close()
        return {
            "seen": int(row["seen"] or 0) if hasattr(row, "keys") else int(row[0] or 0),
            "caught": int(row["caught"] or 0) if hasattr(row, "keys") else int(row[1] or 0),
        }


async def pokedex_seen_species(user_id: str) -> list[str]:
    """Return list of species seen by user."""
    await _ensure_pokedex_tables()
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT species FROM user_pokedex WHERE owner_id=? AND seen_count>0",
            (user_id,),
        )
        rows = await cur.fetchall()
        await cur.close()
        return [r["species"] if hasattr(r, "keys") else r[0] for r in rows]


async def pokedex_caught_species(user_id: str) -> list[str]:
    """Return list of species caught by user."""
    await _ensure_pokedex_tables()
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT species FROM user_pokedex WHERE owner_id=? AND caught_count>0",
            (user_id,),
        )
        rows = await cur.fetchall()
        await cur.close()
        return [r["species"] if hasattr(r, "keys") else r[0] for r in rows]


def _is_city(area_id: str) -> bool:
    return area_id in ADVENTURE_CITIES

def _city_is_cleared(state: dict, area_id: str) -> bool:
    """Cities with a gym are cleared when the player has the gym badge; others when in cleared_cities."""
    city = ADVENTURE_CITIES.get(area_id, {})
    badge = city.get("gym_badge")
    if badge:
        return badge in (state.get("gym_badges") or [])
    return area_id in (state.get("cleared_cities") or [])

async def _team_has_surf(user_id: str) -> bool:
    """True if the user has at least one Pok√©mon on their team that knows Surf."""
    uid = str(user_id)
    if db_cache is not None:
        try:
            cached = db_cache.get_cached_pokemons(uid)
            if cached is not None:
                for p in cached:
                    if not p.get("team_slot") or not (1 <= int(p.get("team_slot") or 0) <= 6):
                        continue
                    moves_raw = p.get("moves")
                    if not moves_raw:
                        continue
                    if isinstance(moves_raw, str):
                        try:
                            moves_raw = json.loads(moves_raw)
                        except Exception:
                            continue
                    if not isinstance(moves_raw, (list, tuple)):
                        continue
                    for m in moves_raw:
                        name = (m if isinstance(m, str) else (m.get("name") if isinstance(m, dict) else "") or "").strip().lower().replace(" ", "-")
                        if name == "surf":
                            return True
                return False
        except Exception:
            pass
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT moves FROM pokemons WHERE owner_id=? AND team_slot IS NOT NULL",
                (uid,),
            )
            rows = await cur.fetchall()
            await cur.close()
        for row in rows or []:
            moves_raw = row.get("moves")
            if not moves_raw:
                continue
            if isinstance(moves_raw, str):
                try:
                    moves_raw = json.loads(moves_raw)
                except Exception:
                    continue
            if not isinstance(moves_raw, (list, tuple)):
                continue
            for m in moves_raw:
                name = (m if isinstance(m, str) else (m.get("name") if isinstance(m, dict) else "") or "").strip().lower().replace(" ", "-")
                if name == "surf":
                    return True
        return False
    except Exception:
        return False

def _route_required_trainers(route_id: str) -> list[str]:
    """Return trainer IDs that block paths (and next_blocker if any) ‚Äî only these must be defeated to clear the route."""
    route = ADVENTURE_ROUTES.get(route_id) or {}
    grass_paths = route.get("grass_paths") or {}
    required = []
    seen = set()
    for path in grass_paths.values():
        blocker = path.get("blocker") if isinstance(path, dict) else None
        if blocker and blocker not in seen:
            seen.add(blocker)
            required.append(blocker)
    next_blocker = route.get("next_blocker")
    if next_blocker and next_blocker not in seen:
        required.append(next_blocker)
    return required

def _route_is_cleared(state: dict, route_id: str) -> bool:
    required = set(_route_required_trainers(route_id))
    defeated = set(state.get("defeated_trainers", {}).keys())
    return required.issubset(defeated)

def _route_path_blockers_cleared(state: dict, route_id: str) -> bool:
    """True when all path blockers (grass_paths only, not next_blocker) are defeated."""
    route = ADVENTURE_ROUTES.get(route_id) or {}
    grass_paths = route.get("grass_paths") or {}
    required = []
    seen = set()
    for path in grass_paths.values():
        blocker = path.get("blocker") if isinstance(path, dict) else None
        if blocker and blocker not in seen:
            seen.add(blocker)
            required.append(blocker)
    defeated = set(state.get("defeated_trainers", {}).keys())
    return set(required).issubset(defeated)

def _add_discovered(state: dict, route_id: str, species: str) -> None:
    discovered = state.setdefault("discovered", {})
    seen = discovered.setdefault(route_id, [])
    s = str(species).lower().strip()
    if s and s not in seen:
        seen.append(s)

def _pick_rival_starter(player_starter: str) -> str:
    s = str(player_starter or "").lower().replace(" ", "-")
    mapping = {
        "bulbasaur": "charmander",
        "charmander": "squirtle",
        "squirtle": "bulbasaur",
        "pikachu": "eevee",
    }
    return mapping.get(s, "charmander")

def _asset_file(path: Path) -> Optional[discord.File]:
    try:
        if path.exists():
            return discord.File(path, filename=path.name)
    except Exception:
        pass
    return None

def _embed_with_image(title: str, description: str, image_path: Path) -> tuple[discord.Embed, list[discord.File]]:
    emb = discord.Embed(title=title, description=description)
    files: list[discord.File] = []
    f = _asset_file(image_path)
    if f:
        emb.set_image(url=f"attachment://{f.filename}")
        files.append(f)
    return emb, files

def _embed_with_route_panel(title: str, description: str, image_path: Path, panel_index: int, panels_total: int = 3) -> tuple[discord.Embed, list[discord.File]]:
    """
    Like _embed_with_image, but crops the given route image into N vertical panels (top‚Üíbottom) and returns the selected panel.
    Requires Pillow. If Pillow is unavailable or cropping fails, falls back to the full image.
    panel_index: 1..panels_total
    """
    panel_index = max(1, min(int(panel_index or 1), int(panels_total or 3)))
    if Image is None:
        return _embed_with_image(title, description, image_path)
    try:
        p = Path(image_path)
        if not p.exists():
            return _embed_with_image(title, description, image_path)
        img = Image.open(str(p)).convert("RGBA")
        w, h = img.size
        slice_h = h // panels_total
        y0 = (panel_index - 1) * slice_h
        y1 = h if panel_index == panels_total else (panel_index * slice_h)
        cropped = img.crop((0, y0, w, y1))
        buf = BytesIO()
        cropped.save(buf, format="PNG")
        buf.seek(0)
        filename = f"route_panel_{p.stem}_{panel_index}.png"
        f = discord.File(fp=buf, filename=filename)
        emb = discord.Embed(title=title, description=description)
        emb.set_image(url=f"attachment://{filename}")
        return emb, [f]
    except Exception:
        return _embed_with_image(title, description, image_path)


def _embed_with_sprite_region(
    title: str, description: str, sprite_sheet_path: Path, region: tuple[int, int, int, int]
) -> tuple[discord.Embed, list[discord.File]]:
    """
    Crop a region (x, y, w, h) from a sprite sheet and use it as the embed image.
    region: (x, y, width, height) - top-left coords and size in pixels.
    """
    if Image is None:
        return _embed_with_image(title, description, sprite_sheet_path)
    try:
        p = Path(sprite_sheet_path)
        if not p.exists():
            return _embed_with_image(title, description, sprite_sheet_path)
        x, y, w, h = region
        if w <= 0 or h <= 0:
            return _embed_with_image(title, description, sprite_sheet_path)
        img = Image.open(str(p)).convert("RGBA")
        cropped = img.crop((x, y, x + w, y + h))
        buf = BytesIO()
        cropped.save(buf, format="PNG")
        buf.seek(0)
        filename = f"sprite_region_{p.stem}_{x}_{y}_{w}x{h}.png"
        f = discord.File(fp=buf, filename=filename)
        emb = discord.Embed(title=title, description=description)
        emb.set_image(url=f"attachment://{filename}")
        return emb, [f]
    except Exception:
        return _embed_with_image(title, description, sprite_sheet_path)


async def _player_lead_for_display(user_id: str) -> str:
    """Best-effort lead name from team_slot 1 (or any slotted mon)."""
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT species FROM pokemons WHERE owner_id=? AND team_slot IS NOT NULL ORDER BY team_slot LIMIT 1",
                (user_id,),
            )
            row = await cur.fetchone()
            await cur.close()
            if row and (row.get("species") or row[0]):
                return str(row.get("species") or row[0])
    except Exception:
        pass
    return "Your Pok√©mon"

def _encounter_preview_embed(lead_name: str, wild_name: str, level: int, image_path: Optional[Path]) -> tuple[discord.Embed, list[discord.File]]:
    title = f"{lead_name.title()} vs. {wild_name.title()}"
    desc = f"A wild **Lv{level} {wild_name.title()}** appeared in the grass!\nGo, {lead_name.title()}!"
    return _embed_with_image(title, desc, image_path) if image_path else (discord.Embed(title=title, description=desc), [])

def _wild_shiny_denominator() -> int:
    """Shiny odds for wild encounters: 1/N. Used when DB trigger is not available (e.g. Postgres)."""
    try:
        n = int(os.environ.get("SHINY_ODDS_DENOMINATOR", "4096"))
        return max(1, n)
    except Exception:
        return 4096

# Short stat keys used by build_mon (pvp/engine)
_STAT_KEYS_SHORT = ("hp", "atk", "defn", "spa", "spd", "spe")

def _normalize_ivs_evs(raw, default_val: int = 0) -> dict:
    """Normalize IVs/EVs from team entry to short-key dict (hp, atk, defn, spa, spd, spe). No rolls."""
    if not raw:
        return {k: default_val for k in _STAT_KEYS_SHORT}
    if isinstance(raw, str):
        try:
            parsed = json.loads(raw) if raw else {}
            raw = parsed
        except Exception:
            raw = {}
    if isinstance(raw, (list, tuple)) and len(raw) >= 6:
        out = {k: default_val for k in _STAT_KEYS_SHORT}
        for i, key in enumerate(_STAT_KEYS_SHORT):
            try:
                out[key] = int(float(raw[i]))
            except Exception:
                continue
        return out
    if isinstance(raw, dict):
        long_to_short = {
            "hp": "hp",
            "attack": "atk", "atk": "atk",
            "defense": "defn", "def": "defn", "defn": "defn",
            "special_attack": "spa", "special_atk": "spa", "specialattack": "spa", "spa": "spa", "spatk": "spa", "sp_atk": "spa",
            "special_defense": "spd", "special_def": "spd", "specialdefense": "spd", "spd": "spd", "spdef": "spd", "sp_def": "spd",
            "speed": "spe", "spe": "spe",
            "0": "hp", "1": "atk", "2": "defn", "3": "spa", "4": "spd", "5": "spe",
        }
        pref_aliases = {
            "hp": ("ev_hp", "hp_ev", "iv_hp", "hp_iv"),
            "atk": ("ev_atk", "atk_ev", "iv_atk", "atk_iv", "ev_attack", "attack_ev", "iv_attack", "attack_iv"),
            "defn": ("ev_def", "def_ev", "iv_def", "def_iv", "ev_defense", "defense_ev", "iv_defense", "defense_iv", "ev_defn", "defn_ev", "iv_defn", "defn_iv"),
            "spa": ("ev_spa", "spa_ev", "iv_spa", "spa_iv", "ev_sp_atk", "sp_atk_ev", "iv_sp_atk", "sp_atk_iv", "ev_special_attack", "special_attack_ev", "iv_special_attack", "special_attack_iv", "ev_special-attack", "special-attack_ev", "iv_special-attack", "special-attack_iv", "ev_spatk", "spatk_ev", "iv_spatk", "spatk_iv"),
            "spd": ("ev_spd", "spd_ev", "iv_spd", "spd_iv", "ev_sp_def", "sp_def_ev", "iv_sp_def", "sp_def_iv", "ev_special_defense", "special_defense_ev", "iv_special_defense", "special_defense_iv", "ev_special-defense", "special-defense_ev", "iv_special-defense", "special-defense_iv", "ev_spdef", "spdef_ev", "iv_spdef", "spdef_iv"),
            "spe": ("ev_spe", "spe_ev", "iv_spe", "spe_iv", "ev_speed", "speed_ev", "iv_speed", "speed_iv"),
        }
        out = {k: default_val for k in _STAT_KEYS_SHORT}
        norm_raw: dict[str, Any] = {}
        for key, val in raw.items():
            k = str(key or "").lower().replace("-", "_").replace(" ", "_")
            norm_raw[k] = val
            short = long_to_short.get(k) or (k if k in _STAT_KEYS_SHORT else None)
            if short is not None:
                try:
                    out[short] = int(float(val))
                except (TypeError, ValueError):
                    pass
        for dest, keys in pref_aliases.items():
            if out.get(dest, default_val) != default_val:
                continue
            for k in keys:
                kn = str(k).lower().replace("-", "_").replace(" ", "_")
                if kn in norm_raw and norm_raw.get(kn) not in (None, ""):
                    try:
                        out[dest] = int(float(norm_raw.get(kn)))
                        break
                    except Exception:
                        continue
        return out
    return {k: default_val for k in _STAT_KEYS_SHORT}

async def _build_mon_from_team_entry(team_entry: dict) -> Optional["Mon"]:
    """
    Build a trainer Mon from a fixed team entry. No rolls: uses species, level, moves, and
    optional ability, nature, ivs, evs, gender, shiny from the entry. Omitted fields use
    deterministic defaults (first ability, hardy nature, 0 IVs/EVs, male, not shiny).
    """
    if not isinstance(team_entry, dict) or not team_entry.get("species"):
        return None
    species = str(team_entry["species"]).strip()
    level = int(team_entry.get("level", 5))
    try:
        entry = await ensure_species_and_learnsets(species)
    except Exception:
        return None
    raw_stats = entry.get("stats")
    if isinstance(raw_stats, str):
        try:
            raw_stats = json.loads(raw_stats)
        except Exception:
            raw_stats = {}
    base_long = _normalize_stats_for_generator(raw_stats or {})
    base_short = {
        "hp": base_long.get("hp", 1),
        "atk": base_long.get("attack", 1),
        "defn": base_long.get("defense", 1),
        "spa": base_long.get("special_attack", 1),
        "spd": base_long.get("special_defense", 1),
        "spe": base_long.get("speed", 1),
    }
    types = _extract_species_types(entry)
    types_tuple = (types[0].title() if types else "Normal", types[1].title() if len(types) > 1 else None)

    move_list = team_entry.get("moves")
    if not move_list:
        conn = await db.connect()
        try:
            cur = await conn.execute("SELECT id FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1", (species.lower(),))
            row = await cur.fetchone()
            await cur.close()
            if row:
                move_list = await _default_levelup_moves(int(row["id"]), level, 1)
        except Exception:
            move_list = []
        finally:
            try:
                await conn.close()
            except Exception:
                pass
    if not move_list:
        move_list = ["Tackle"]
    move_list = [str(m).title().replace(" ", "-") if isinstance(m, str) else str(m) for m in (move_list or [])][:4]

    ability = team_entry.get("ability")
    if ability is None or (isinstance(ability, str) and not ability.strip()):
        regs, hides = parse_abilities(entry.get("abilities") or [])
        ability = (regs[0] if regs else (hides[0] if hides else None)) or "Unknown"
    else:
        ability = str(ability).strip().lower().replace(" ", "-")

    nature = (team_entry.get("nature") or "hardy").strip().lower()
    ivs = _normalize_ivs_evs(team_entry.get("ivs"), 0)
    evs = _normalize_ivs_evs(team_entry.get("evs"), 0)
    gender = (team_entry.get("gender") or "male").strip().lower()
    if gender not in ("male", "female", "genderless"):
        gender = "male"
    is_shiny = bool(team_entry.get("shiny", False))

    from lib.stats import calc_all_stats
    ivs_long = {"hp": ivs["hp"], "attack": ivs["atk"], "defense": ivs["defn"], "special_attack": ivs["spa"], "special_defense": ivs["spd"], "speed": ivs["spe"]}
    evs_long = {"hp": evs["hp"], "attack": evs["atk"], "defense": evs["defn"], "special_attack": evs["spa"], "special_defense": evs["spd"], "speed": evs["spe"]}
    final_stats = calc_all_stats(base_long, ivs_long, evs_long, level, nature)
    hp_max = final_stats.get("hp", 1)
    try:
        capture_rate = int(float(entry.get("capture_rate") or 45))
    except Exception:
        capture_rate = 45

    dto = {
        "species": entry.get("name") or species,
        "types": types_tuple,
        "base": base_short,
        "ivs": ivs,
        "evs": evs,
        "level": level,
        "moves": move_list,
        "ability": ability,
        "gender": gender,
        "is_shiny": is_shiny,
        "hp_now": hp_max,
        "weight_kg": float(entry.get("weight_kg") or 100.0),
        "friendship": int(entry.get("base_happiness") or 70),
        "capture_rate": capture_rate,
        "nature": nature,
    }
    # Optional fixed stats override (e.g. for scripted rival/trainer teams)
    raw_stats = team_entry.get("stats")
    if isinstance(raw_stats, dict) and raw_stats.get("hp") is not None:
        dto["override_max_hp"] = int(raw_stats["hp"])
        dto["override_stats"] = {
            "atk":  int(raw_stats.get("atk", 0)),
            "defn": int(raw_stats.get("defn", raw_stats.get("def", 0))),
            "spa":  int(raw_stats.get("spa", 0)),
            "spd":  int(raw_stats.get("spd", 0)),
            "spe":  int(raw_stats.get("spe", 0)),
        }
    return build_mon(dto, set_level=level, heal=True)

def _gender_ratio_from_entry(entry: dict) -> dict:
    """Get gender ratio from DB/cache entry (gender_ratio or gender_rate). Same logic as starter flow."""
    gender_ratio = _j(entry.get("gender_ratio"), None) if entry else None
    if not gender_ratio or not isinstance(gender_ratio, dict):
        gr = entry.get("gender_rate") if entry else None
        if isinstance(gr, str):
            try:
                gr = json.loads(gr)
            except Exception:
                gr = None
        if isinstance(gr, int):
            if gr == -1:
                gender_ratio = {"genderless": True}
            else:
                female = gr * 12.5
                gender_ratio = {"male": 100 - female, "female": female}
    if not gender_ratio or not isinstance(gender_ratio, dict):
        gender_ratio = {"male": 50, "female": 50}
    return gender_ratio


async def _build_mon_from_species(
    species: str,
    level: int,
    moves: Optional[list[str]] = None,
    *,
    sync_nature: Optional[str] = None,
) -> Optional["Mon"]:
    # Prefer cache (db_cache) then ensure_species_and_learnsets (DB / API)
    entry = None
    if db_cache is not None:
        key = species.strip().lower().replace(" ", "-")
        entry = db_cache.get_cached_pokedex(key) or db_cache.get_cached_pokedex(species.lower())
        if not entry and key != species.lower():
            entry = db_cache.get_cached_pokedex(species.lower())
    if entry is None:
        try:
            entry = await ensure_species_and_learnsets(species)
        except Exception:
            return None
    raw_stats = entry.get("stats")
    if isinstance(raw_stats, str):
        try:
            raw_stats = json.loads(raw_stats)
        except Exception:
            raw_stats = {}
    base_long = _normalize_stats_for_generator(raw_stats or {})
    # Normalize abilities so generate_mon/choose_ability get list[dict] with name + is_hidden (handles pokedex JSON/API formats)
    abilities_raw = entry.get("abilities") or []
    regs, hides = parse_abilities(abilities_raw)
    abilities_for_gen = [{"name": r, "is_hidden": False} for r in regs] + [{"name": h, "is_hidden": True} for h in hides]
    if not abilities_for_gen:
        abilities_for_gen = []
    # Gender ratio from database/cache (same as starter: gender_ratio or gender_rate)
    gender_ratio = _gender_ratio_from_entry(entry)
    rolled = generate_mon(base_stats=base_long, abilities=abilities_for_gen, gender_ratio=gender_ratio, level=level)
    base_short = {
        "hp": base_long.get("hp", 1),
        "atk": base_long.get("attack", 1),
        "defn": base_long.get("defense", 1),
        "spa": base_long.get("special_attack", 1),
        "spd": base_long.get("special_defense", 1),
        "spe": base_long.get("speed", 1),
    }
    types = _extract_species_types(entry)
    types_tuple = (types[0].title() if types else "Normal", types[1].title() if len(types) > 1 else None)
    move_list = moves or []
    species_id = None
    try:
        species_id = entry.get("id")
        species_id = int(species_id) if species_id is not None else None
    except (TypeError, ValueError):
        species_id = None
    if not move_list:
        move_list = await _default_levelup_moves(species_id, level, 1) if species_id else ["Tackle"]
    # Special move roll: 0.1% chance per slot to be a non-level-up move (egg/machine only; no tutor in Gen 1)
    if species_id:
        special_moves = await _get_egg_machine_learnset_moves(species_id, 1)
        if special_moves:
            move_list = list(move_list)[:4]
            for i in range(len(move_list)):
                if random.random() < 0.001:  # 0.1% per slot
                    move_list[i] = random.choice(special_moves)
    try:
        capture_rate = int(float(entry.get("capture_rate") or 45))
    except Exception:
        capture_rate = 45
    rolled_nature = str(rolled.get("nature") or "hardy").strip().lower() or "hardy"
    sync_nature_norm = str(sync_nature or "").strip().lower()
    if sync_nature_norm:
        rolled_nature = sync_nature_norm

    dto = {
        "species": entry.get("name") or species,
        "types": types_tuple,
        "base": base_short,
        "ivs": {
            "hp": int(rolled["ivs"]["hp"]),
            "atk": int(rolled["ivs"]["attack"]),
            "defn": int(rolled["ivs"]["defense"]),
            "spa": int(rolled["ivs"]["special_attack"]),
            "spd": int(rolled["ivs"]["special_defense"]),
            "spe": int(rolled["ivs"]["speed"]),
        },
        "evs": {
            "hp": int(rolled["evs"]["hp"]),
            "atk": int(rolled["evs"]["attack"]),
            "defn": int(rolled["evs"]["defense"]),
            "spa": int(rolled["evs"]["special_attack"]),
            "spd": int(rolled["evs"]["special_defense"]),
            "spe": int(rolled["evs"]["speed"]),
        },
        "level": level,
        "moves": [m.title() if isinstance(m, str) else str(m) for m in move_list][:4],
        "ability": rolled.get("ability"),
        "gender": rolled.get("gender"),
        "nature": rolled_nature,
        "is_shiny": await shiny_roll(_wild_shiny_denominator()),
        "hp_now": int(rolled["stats"]["hp"]),
        "weight_kg": float(entry.get("weight_kg") or 100.0),
        "friendship": int(entry.get("base_happiness") or 70),
        "capture_rate": capture_rate,
    }
    return build_mon(dto, set_level=level, heal=True)


async def _wild_synchronize_nature(owner_id: str) -> Optional[str]:
    """
    50% chance for wild encounters to copy the nature of the user's lead
    when that lead has Synchronize.
    """
    if not owner_id:
        return None
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                """
                SELECT team_slot, ability, nature, hp_now, hp
                FROM pokemons
                WHERE owner_id=? AND team_slot BETWEEN 1 AND 6
                ORDER BY team_slot ASC
                """,
                (str(owner_id),),
            )
            rows = [dict(r) for r in await cur.fetchall()]
            await cur.close()
    except Exception:
        return None
    if not rows:
        return None
    lead = None
    for r in rows:
        try:
            hp_max = int(r.get("hp") or 0)
            hp_now = int(r.get("hp_now") if r.get("hp_now") is not None else hp_max)
        except Exception:
            hp_now = 0
        if hp_now > 0:
            lead = r
            break
    if lead is None:
        lead = rows[0]
    ability = str(lead.get("ability") or "").strip().lower().replace("_", "-").replace(" ", "-")
    if ability != "synchronize":
        return None
    if random.random() >= 0.5:
        return None
    nature = str(lead.get("nature") or "").strip().lower()
    return nature or None

async def _load_pp_from_db(st: "BattleState", uid: int) -> None:
    team = st.team_for(uid)
    # Try twice in case the pool is momentarily exhausted.
    for attempt in range(2):
        try:
            async with db.session() as conn:
                for idx, mon in enumerate(team):
                    db_id = getattr(mon, "_db_id", None)
                    if not db_id:
                        continue
                    try:
                        cur = await conn.execute(
                            "SELECT moves, moves_pp, moves_pp_min, moves_pp_max FROM pokemons WHERE id=? LIMIT 1",
                            (int(db_id),),
                        )
                    except Exception:
                        cur = await conn.execute(
                            "SELECT moves, moves_pp FROM pokemons WHERE id=? LIMIT 1",
                            (int(db_id),),
                        )
                    row = await cur.fetchone(); await cur.close()
                    if not row:
                        continue
                    try:
                        moves = json.loads(row["moves"]) if row.get("moves") else []
                    except Exception:
                        moves = []
                    raw_pps = row.get("moves_pp")
                    raw_pp_min = row.get("moves_pp_min")
                    raw_pp_max = row.get("moves_pp_max")
                    st._ensure_pp_loaded(uid, mon)
                    if hasattr(st, "_get_mon_key"):
                        key = st._get_mon_key(uid, mon)
                    else:
                        key = (uid, idx)
                    if key not in st._pp:
                        st._pp[key] = {}
                    if moves:
                        move_ids = [str(m).strip().replace("_", "-").replace(" ", "-").lower() for m in moves]
                        base_caps = [_pp_move_base(mid, st.gen) for mid in move_ids]
                        global_caps = [_pp_move_global_max(mid, st.gen) for mid in move_ids]
                        max_caps = _pp_parse_int_list(raw_pp_max, count=len(move_ids), defaults=base_caps, lo=1, hi=999)
                        min_caps = _pp_parse_int_list(raw_pp_min, count=len(move_ids), defaults=[0] * len(move_ids), lo=0, hi=999)
                        pps = _pp_parse_int_list(raw_pps, count=len(move_ids), defaults=max_caps, lo=0, hi=999)
                        for i in range(len(move_ids)):
                            max_caps[i] = max(base_caps[i], min(max_caps[i], global_caps[i]))
                            min_caps[i] = max(0, min(min_caps[i], max_caps[i]))
                            pps[i] = max(min_caps[i], min(pps[i], max_caps[i]))
                        for m, left_i in zip(moves, pps):
                            st._pp[key][m] = int(left_i)
                            try:
                                st._pp[key][_norm_move_name(str(m))] = int(left_i)
                            except Exception:
                                pass
            break
        except (asyncio.TimeoutError, TimeoutError, asyncio.CancelledError):
            if attempt == 0:
                await asyncio.sleep(0.2)
                continue
        except Exception:
            break

async def _save_party_state_from_battle(st: "BattleState", uid: int) -> None:
    team = st.team_for(uid)
    async with db.session() as conn:
        for idx, mon in enumerate(team):
            db_id = getattr(mon, "_db_id", None)
            if not db_id:
                continue
            if hasattr(st, "_get_mon_key"):
                key = st._get_mon_key(uid, mon)
            else:
                key = (uid, idx)
            pp_store = st._pp.get(key, {})
            move_list = (mon.moves or [])[:4]
            norm_pp_store: dict[str, int] = {}
            for k, v in (pp_store or {}).items():
                try:
                    norm_pp_store[_norm_move_name(str(k))] = int(v)
                except Exception:
                    continue
            row_d: dict[str, Any] = {}
            try:
                cur = await conn.execute(
                    "SELECT moves_pp_min, moves_pp_max FROM pokemons WHERE id=? LIMIT 1",
                    (int(db_id),),
                )
                bounds_row = await cur.fetchone()
                await cur.close()
                if bounds_row:
                    row_d = dict(bounds_row) if hasattr(bounds_row, "keys") else {}
            except Exception:
                row_d = {}
            move_ids = [str(m).strip().replace("_", "-").replace(" ", "-").lower() for m in move_list]
            base_caps = [_pp_move_base(mid, st.gen) for mid in move_ids]
            global_caps = [_pp_move_global_max(mid, st.gen) for mid in move_ids]
            max_caps = _pp_parse_int_list(row_d.get("moves_pp_max"), count=len(move_ids), defaults=base_caps, lo=1, hi=999)
            min_caps = _pp_parse_int_list(row_d.get("moves_pp_min"), count=len(move_ids), defaults=[0] * len(move_ids), lo=0, hi=999)
            for i in range(len(move_ids)):
                max_caps[i] = max(base_caps[i], min(max_caps[i], global_caps[i]))
                min_caps[i] = max(0, min(min_caps[i], max_caps[i]))
            moves_pp: list[int] = []
            for i, m in enumerate(move_list):
                cap_i = max_caps[i] if i < len(max_caps) else _pp_move_global_max(str(m), st.gen)
                min_i = min_caps[i] if i < len(min_caps) else 0
                left = pp_store.get(m)
                if left is None:
                    left = norm_pp_store.get(_norm_move_name(str(m)))
                try:
                    left_i = int(left) if left is not None else int(cap_i)
                except Exception:
                    left_i = int(cap_i)
                moves_pp.append(max(int(min_i), min(int(left_i), int(cap_i))))
            try:
                await conn.execute(
                    "UPDATE pokemons SET hp_now=?, moves_pp=?, moves_pp_min=?, moves_pp_max=? WHERE id=?",
                    (
                        int(mon.hp),
                        json.dumps(moves_pp, ensure_ascii=False),
                        json.dumps(min_caps, ensure_ascii=False),
                        json.dumps(max_caps, ensure_ascii=False),
                        int(db_id),
                    ),
                )
            except Exception:
                await conn.execute(
                    "UPDATE pokemons SET hp_now=?, moves_pp=? WHERE id=?",
                    (int(mon.hp), json.dumps(moves_pp, ensure_ascii=False), int(db_id)),
                )
        await conn.commit()
        db.invalidate_pokemons_cache(str(uid))

# --- Experience helpers (Adventure/PvE) ---
# Valid exp_group codes (must match exp_groups / exp_requirements in DB)
_VALID_EXP_GROUPS = frozenset({"erratic", "fast", "medium_fast", "medium_slow", "slow", "fluctuating"})


def _normalize_growth_rate_to_exp_group(growth_rate: str | None) -> str:
    """Map pokedex.growth_rate (e.g. 'medium-fast', 'Medium Fast') to exp_group code (e.g. 'medium_fast')."""
    if not growth_rate or not str(growth_rate).strip():
        return "medium_fast"
    s = str(growth_rate).strip().lower().replace(" ", "_").replace("-", "_")
    return s if s in _VALID_EXP_GROUPS else "medium_fast"


async def _get_exp_group_for_species(conn, species: str) -> str:
    """Get exp_group for a species from pokedex.growth_rate; fallback 'medium_fast'."""
    if not species or not str(species).strip():
        return "medium_fast"
    try:
        cur = await conn.execute(
            "SELECT growth_rate FROM pokedex WHERE LOWER(name) = LOWER(?) OR LOWER(REPLACE(name,' ','-')) = LOWER(?) LIMIT 1",
            (str(species).strip(), str(species).strip().replace(" ", "-")),
        )
        row = await cur.fetchone()
        await cur.close()
        if row and row.get("growth_rate") is not None:
            return _normalize_growth_rate_to_exp_group(str(row["growth_rate"]))
    except Exception:
        pass
    return "medium_fast"


async def _get_exp_total_for_level(conn, exp_group: str, level: int) -> int:
    """Return exp_total from exp_requirements for (exp_group, level). Returns 0 if not found."""
    if db_cache is not None:
        try:
            rows = db_cache.get_cached_exp_requirements()
            if rows:
                key = exp_group.strip().lower().replace(" ", "_")
                for r in rows:
                    if str(r.get("group_code") or "").strip().lower().replace(" ", "_") == key and int(r.get("level") or 0) == level:
                        v = r.get("exp_total")
                        return int(v) if v is not None else 0
        except Exception:
            pass
    try:
        cur = await conn.execute(
            "SELECT exp_total FROM exp_requirements WHERE group_code = ? AND level = ? LIMIT 1",
            (exp_group.strip().lower().replace(" ", "_"), level),
        )
        row = await cur.fetchone()
        await cur.close()
        return int(row["exp_total"]) if row and row.get("exp_total") is not None else 0
    except Exception:
        return 0


async def _calc_level_from_exp(exp_group: str, exp_val: int) -> int:
    """Return highest level where exp_total <= exp_val for a given exp_group."""
    if db_cache is not None:
        try:
            rows = db_cache.get_cached_exp_requirements()
            if rows:
                key = (exp_group or "").strip().lower().replace(" ", "_")
                best = 1
                for r in rows:
                    if str(r.get("group_code") or "").strip().lower().replace(" ", "_") != key:
                        continue
                    lvl = int(r.get("level") or 0)
                    total = int(r.get("exp_total") or 0)
                    if total <= exp_val and lvl > best:
                        best = lvl
                return best
        except Exception:
            pass
    async with db.session() as conn:
        cur = await conn.execute(
            """
            SELECT level FROM exp_requirements
            WHERE group_code = ? AND exp_total <= ?
            ORDER BY level DESC
            LIMIT 1
            """,
            (exp_group, exp_val),
        )
        row = await cur.fetchone()
        await cur.close()
        return int(row["level"]) if row and row.get("level") is not None else 1


def _parse_evolution(evolution: Any) -> dict:
    """Parse pokedex.evolution (JSONB or string) into a dict with 'next' list."""
    if evolution is None:
        return {}
    if isinstance(evolution, dict):
        return evolution
    if isinstance(evolution, str):
        try:
            return json.loads(evolution)
        except Exception:
            return {}
    return {}


def _evo_norm_text(v: Any) -> str:
    return str(v or "").strip().lower().replace("_", "-").replace(" ", "-")


def _evo_unwrap_nameish(v: Any) -> Any:
    """
    Unwrap PokeAPI-like nested objects to a comparable scalar.
    Examples:
      {"name": "use-item"} -> "use-item"
      {"item": {"name": "water-stone"}} -> "water-stone"
    """
    if isinstance(v, dict):
        if "name" in v and not isinstance(v.get("name"), (dict, list, tuple)):
            return v.get("name")
        for key in ("item", "trigger", "species", "value", "id"):
            if key in v:
                return _evo_unwrap_nameish(v.get(key))
        return None
    return v


def _evo_details_candidates(raw_details: Any) -> list[dict]:
    details = raw_details
    if isinstance(details, str):
        try:
            details = json.loads(details)
        except Exception:
            details = {}
    if isinstance(details, dict):
        return [details]
    if isinstance(details, (list, tuple)):
        out: list[dict] = []
        for d in details:
            if isinstance(d, str):
                try:
                    d = json.loads(d)
                except Exception:
                    d = {}
            if isinstance(d, dict):
                out.append(d)
        return out
    return []


def _evo_move_name_set(raw_moves: Any) -> set[str]:
    moves = raw_moves
    if isinstance(moves, str):
        try:
            parsed = json.loads(moves)
            moves = parsed
        except Exception:
            moves = [moves]
    if not isinstance(moves, (list, tuple)):
        return set()
    out: set[str] = set()
    for m in moves[:4]:
        if isinstance(m, dict):
            name = m.get("name")
        else:
            name = m
        norm = _evo_norm_text(name)
        if norm:
            out.add(norm)
    return out


def _evo_day_phase_utc() -> str:
    hour = datetime.now(timezone.utc).hour
    return "day" if 6 <= hour < 18 else "night"


_ITEM_EVOLUTION_FALLBACK: dict[str, dict[str, str]] = {
    "eevee": {
        "water-stone": "vaporeon",
        "thunder-stone": "jolteon",
        "fire-stone": "flareon",
        "leaf-stone": "leafeon",
        "ice-stone": "glaceon",
    },
    "pikachu": {"thunder-stone": "raichu"},
    "nidorina": {"moon-stone": "nidoqueen"},
    "nidorino": {"moon-stone": "nidoking"},
    "clefairy": {"moon-stone": "clefable"},
    "jigglypuff": {"moon-stone": "wigglytuff"},
    "gloom": {"leaf-stone": "vileplume", "sun-stone": "bellossom"},
    "poliwhirl": {"water-stone": "poliwrath"},
    "weepinbell": {"leaf-stone": "victreebel"},
    "shellder": {"water-stone": "cloyster"},
    "staryu": {"water-stone": "starmie"},
    "exeggcute": {"leaf-stone": "exeggutor"},
    "vulpix": {"fire-stone": "ninetales"},
    "growlithe": {"fire-stone": "arcanine"},
    "togetic": {"shiny-stone": "togekiss"},
    "roselia": {"shiny-stone": "roserade"},
    "misdreavus": {"dusk-stone": "mismagius"},
    "murkrow": {"dusk-stone": "honchkrow"},
}


def _fallback_item_evolution_target(species_name: str, item_id: str) -> Optional[str]:
    sp = _daycare_norm_species(species_name)
    item = _daycare_norm_item(item_id)
    if not sp or not item:
        return None
    return _ITEM_EVOLUTION_FALLBACK.get(sp, {}).get(item)


async def _evo_move_type_match(conn, moves_norm: set[str], required_type: str) -> bool:
    if not moves_norm:
        return False
    move_list = [m for m in moves_norm if m]
    if not move_list:
        return False
    placeholders = ",".join("?" for _ in move_list)
    try:
        cur = await conn.execute(
            f"""
            SELECT type
            FROM moves
            WHERE LOWER(REPLACE(name, ' ', '-')) IN ({placeholders})
            """,
            tuple(move_list),
        )
        rows = await cur.fetchall()
        await cur.close()
    except Exception:
        return False
    req = _evo_norm_text(required_type)
    for row in rows:
        t = _evo_norm_text(row["type"] if hasattr(row, "keys") else row[0])
        if t == req:
            return True
    return False


async def _evo_details_match(
    conn,
    details: Any,
    *,
    expected_trigger: str,
    level: Optional[int],
    friendship: Optional[int],
    gender: Optional[str],
    moves: Any,
    held_item: Optional[str],
    item_used: Optional[str],
    area_id: Optional[str],
) -> bool:
    info = details or {}
    if isinstance(info, str):
        try:
            parsed = json.loads(info)
            info = parsed if isinstance(parsed, dict) else {}
        except Exception:
            info = {}
    if not isinstance(info, dict):
        info = {}

    expected = _evo_norm_text(expected_trigger)
    trigger = _evo_norm_text(_evo_unwrap_nameish(info.get("trigger")))

    if expected == "level-up":
        if trigger and trigger not in {"level-up"}:
            return False
    elif expected == "use-item":
        if trigger and trigger not in {"use-item", "item"}:
            return False
    else:
        if expected and trigger and trigger != expected:
            return False

    if expected == "level-up":
        min_level = info.get("min_level")
        if min_level is not None:
            try:
                need = int(min_level)
            except (TypeError, ValueError):
                return False
            if level is None or int(level) < need:
                return False
        required_held = _daycare_norm_item(_evo_unwrap_nameish(info.get("held_item")) or "")
        if required_held and _daycare_norm_item(held_item or "") != required_held:
            return False
    elif expected == "use-item":
        required_item = _daycare_norm_item(_evo_unwrap_nameish(info.get("item")) or "")
        used_item = _daycare_norm_item(item_used or "")
        if required_item and used_item != required_item:
            return False
        if not required_item and trigger not in {"use-item", "item"}:
            return False

    req_gender = _evo_norm_text(_evo_unwrap_nameish(info.get("gender")))
    if req_gender == "1":
        req_gender = "female"
    elif req_gender == "2":
        req_gender = "male"
    if req_gender in {"male", "female"} and _evo_norm_text(gender) != req_gender:
        return False

    req_time = _evo_norm_text(_evo_unwrap_nameish(info.get("time_of_day")))
    if req_time:
        phase = _evo_day_phase_utc()
        if req_time in {"day", "night"} and phase != req_time:
            return False

    for key in ("min_happiness", "min_friendship", "min_affection"):
        if info.get(key) is None:
            continue
        try:
            needed = int(info.get(key))
        except (TypeError, ValueError):
            return False
        if friendship is None or int(friendship) < needed:
            return False

    moves_norm = _evo_move_name_set(moves)
    req_move = _evo_norm_text(_evo_unwrap_nameish(info.get("known_move")))
    if req_move and req_move not in moves_norm:
        return False
    req_move_type = _evo_norm_text(_evo_unwrap_nameish(info.get("known_move_type")))
    if req_move_type:
        ok_type = await _evo_move_type_match(conn, moves_norm, req_move_type)
        if not ok_type:
            return False

    req_location = _evo_norm_text(_evo_unwrap_nameish(info.get("location")))
    if req_location and _evo_norm_text(area_id) != req_location:
        return False

    # Unsupported special conditions: avoid false positives.
    if bool(info.get("needs_overworld_rain")) or bool(info.get("turn_upside_down")):
        return False
    for unsupported in ("trade_species", "party_species", "party_type", "relative_physical_stats", "min_beauty"):
        val = info.get(unsupported)
        if val not in (None, "", 0, False):
            return False

    return True


async def _find_evolution_for_trigger(
    conn,
    species_name: str,
    *,
    expected_trigger: str,
    level: Optional[int] = None,
    friendship: Optional[int] = None,
    gender: Optional[str] = None,
    moves: Any = None,
    held_item: Optional[str] = None,
    item_used: Optional[str] = None,
    area_id: Optional[str] = None,
) -> Optional[str]:
    cur = await conn.execute(
        "SELECT evolution FROM pokedex WHERE LOWER(name)=LOWER(?) OR LOWER(REPLACE(name,' ','-'))=LOWER(?) LIMIT 1",
        (species_name.strip(), _evo_norm_text(species_name)),
    )
    row = await cur.fetchone()
    await cur.close()
    if not row or row.get("evolution") is None:
        return None
    evo = _parse_evolution(row["evolution"])
    if not isinstance(evo, dict):
        return None
    raw_next = evo.get("next")
    if isinstance(raw_next, list):
        next_list = raw_next
    elif raw_next is not None:
        next_list = [raw_next]
    else:
        next_list = []
    for n in next_list:
        if isinstance(n, str):
            s = (n or "").strip().lower().replace(" ", "-")
            if s and _evo_norm_text(expected_trigger) == "level-up":
                return s
            continue
        if not isinstance(n, dict):
            continue
        species = _daycare_norm_species(_evo_unwrap_nameish(n.get("species")))
        if not species:
            continue
        detail_blob = n.get("details")
        if detail_blob in (None, "", []):
            detail_blob = n.get("evolution_details")
        candidates = _evo_details_candidates(detail_blob)
        if not candidates:
            # Some datasets flatten details directly on the node.
            candidates = [n]
        for details in candidates:
            ok = await _evo_details_match(
                conn,
                details,
                expected_trigger=_evo_norm_text(expected_trigger),
                level=level,
                friendship=friendship,
                gender=gender,
                moves=moves,
                held_item=held_item,
                item_used=item_used,
                area_id=area_id,
            )
            if ok:
                return species
    return None


async def _get_level_up_evolution(
    conn,
    species_name: str,
    level: int,
    *,
    friendship: Optional[int] = None,
    gender: Optional[str] = None,
    moves: Any = None,
    held_item: Optional[str] = None,
    area_id: Optional[str] = None,
) -> Optional[str]:
    return await evo_mech.resolve_level_up_evolution(
        conn,
        species_name,
        level=level,
        friendship=friendship,
        gender=gender,
        moves=moves,
        held_item=held_item,
        area_id=area_id,
    )


async def _get_item_use_evolution(
    conn,
    species_name: str,
    item_id: str,
    *,
    friendship: Optional[int] = None,
    gender: Optional[str] = None,
    moves: Any = None,
    held_item: Optional[str] = None,
    area_id: Optional[str] = None,
) -> Optional[str]:
    return await evo_mech.resolve_item_evolution(
        conn,
        species_name,
        item_id,
        friendship=friendship,
        gender=gender,
        moves=moves,
        held_item=held_item,
        area_id=area_id,
    )


async def _get_any_item_evolution_target(conn, species_name: str) -> Optional[str]:
    return await evo_mech.suggest_item_evolution_item(conn, species_name)


async def _apply_evolution(owner_id: str, mon_db_id: int, evolved_species_name: str, level: int) -> bool:
    """
    Evolve a Pok√©mon in the DB: update species, base stats, types, ability, moves.
    Preserve Nature, Shininess, IVs, EVs, gender, friendship, held_item, pokeball.
    Uses db.session() for all DB work. Returns True if updated, False if not found or error.
    """
    evolved_species_name = (evolved_species_name or "").strip().lower().replace(" ", "-")
    if not evolved_species_name:
        return False
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT id, species, level, hp, hp_now, atk, def, spa, spd, spe, ivs, evs, nature, ability, gender, friendship, held_item, pokeball, shiny, is_hidden_ability, moves, form FROM pokemons WHERE owner_id = ? AND id = ? LIMIT 1",
            (owner_id, mon_db_id),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return False
        cur_dex = await conn.execute(
            "SELECT id, name, stats, abilities, types FROM pokedex WHERE LOWER(name) = LOWER(?) LIMIT 1",
            (evolved_species_name,),
        )
        evo_row = await cur_dex.fetchone()
        await cur_dex.close()
        if not evo_row:
            return False
        evolved_species_id = int(evo_row["id"])
        evolved_display_name = (evo_row.get("name") or evolved_species_name).replace("-", " ").title()
        raw_stats = evo_row.get("stats")
        if isinstance(raw_stats, str):
            try:
                raw_stats = json.loads(raw_stats)
            except Exception:
                raw_stats = {}
        base_long = _normalize_stats_for_generator(raw_stats or {})
        ivs_raw = row.get("ivs")
        if isinstance(ivs_raw, str):
            try:
                ivs_raw = json.loads(ivs_raw)
            except Exception:
                ivs_raw = {}
        evs_raw = row.get("evs")
        if isinstance(evs_raw, str):
            try:
                evs_raw = json.loads(evs_raw)
            except Exception:
                evs_raw = {}
        ivs_long = {"hp": ivs_raw.get("hp", 31), "attack": ivs_raw.get("atk", ivs_raw.get("attack", 31)), "defense": ivs_raw.get("defn", ivs_raw.get("def", ivs_raw.get("defense", 31))), "special_attack": ivs_raw.get("spa", ivs_raw.get("special_attack", 31)), "special_defense": ivs_raw.get("spd", ivs_raw.get("special_defense", 31)), "speed": ivs_raw.get("spe", ivs_raw.get("speed", 31))}
        evs_long = {"hp": evs_raw.get("hp", 0), "attack": evs_raw.get("atk", evs_raw.get("attack", 0)), "defense": evs_raw.get("defn", evs_raw.get("def", evs_raw.get("defense", 0))), "special_attack": evs_raw.get("spa", evs_raw.get("special_attack", 0)), "special_defense": evs_raw.get("spd", evs_raw.get("special_defense", 0)), "speed": evs_raw.get("spe", evs_raw.get("speed", 0))}
        nature = (row.get("nature") or "hardy").strip().lower()
        final_stats = calc_all_stats(base_long, ivs_long, evs_long, level, nature)
        abilities_raw = evo_row.get("abilities") or []
        regs, hides = parse_abilities(abilities_raw)
        is_hidden = bool(row.get("is_hidden_ability"))
        if is_hidden and hides:
            new_ability = hides[0].lower().replace(" ", "-")
        else:
            new_ability = (regs[0].lower().replace(" ", "-") if regs else "") or (hides[0].lower().replace(" ", "-") if hides else "")
        user_gen = await _user_selected_gen(owner_id)
        move_list = await _default_levelup_moves(evolved_species_id, level, user_gen)
        if not move_list:
            move_list = ["Tackle", "Growl", "Scratch", "Ember"][:4]
        move_list = move_list[:4]
        base_pps = []
        for m in move_list:
            pp_val = 20
            try:
                if db_cache:
                    cached = db_cache.get_cached_move(m) or db_cache.get_cached_move(m.lower()) or db_cache.get_cached_move(m.lower().replace(" ", "-"))
                    if cached and cached.get("pp") is not None:
                        pp_val = int(cached["pp"])
            except Exception:
                pass
            base_pps.append(pp_val)
        hp_val = int(final_stats.get("hp", 1))
        try:
            await conn.execute(
                """UPDATE pokemons
                   SET species = ?, level = ?, hp = ?, hp_now = ?, atk = ?, def = ?, spa = ?, spd = ?, spe = ?,
                       ability = ?, moves = ?, moves_pp = ?, moves_pp_min = ?, moves_pp_max = ?, form = ?
                   WHERE owner_id = ? AND id = ?""",
                (
                    evolved_display_name,
                    level,
                    hp_val,
                    hp_val,
                    int(final_stats.get("attack", 0)),
                    int(final_stats.get("defense", 0)),
                    int(final_stats.get("special_attack", 0)),
                    int(final_stats.get("special_defense", 0)),
                    int(final_stats.get("speed", 0)),
                    new_ability or None,
                    json.dumps(move_list, ensure_ascii=False),
                    json.dumps(base_pps, ensure_ascii=False),
                    json.dumps([0] * len(base_pps), ensure_ascii=False),
                    json.dumps(base_pps, ensure_ascii=False),
                    None,
                    owner_id,
                    mon_db_id,
                ),
            )
        except Exception:
            await conn.execute(
                """UPDATE pokemons SET species = ?, level = ?, hp = ?, hp_now = ?, atk = ?, def = ?, spa = ?, spd = ?, spe = ?, ability = ?, moves = ?, moves_pp = ?, form = ? WHERE owner_id = ? AND id = ?""",
                (
                    evolved_display_name,
                    level,
                    hp_val,
                    hp_val,
                    int(final_stats.get("attack", 0)),
                    int(final_stats.get("defense", 0)),
                    int(final_stats.get("special_attack", 0)),
                    int(final_stats.get("special_defense", 0)),
                    int(final_stats.get("speed", 0)),
                    new_ability or None,
                    json.dumps(move_list, ensure_ascii=False),
                    json.dumps(base_pps, ensure_ascii=False),
                    None,
                    owner_id,
                    mon_db_id,
                ),
            )
        await conn.commit()
        db.invalidate_pokemons_cache(owner_id)
        return True


def _mon_to_long_stats(short: dict) -> dict:
    """Convert pvp Mon short stat keys (hp, atk, def, spa, spd, spe) to long keys for calc_all_stats."""
    return {
        "hp": int(short.get("hp", 0)),
        "attack": int(short.get("atk", short.get("attack", 0))),
        "defense": int(short.get("def", short.get("defense", 0))),
        "special_attack": int(short.get("spa", short.get("special_attack", 0))),
        "special_defense": int(short.get("spd", short.get("special_defense", 0))),
        "speed": int(short.get("spe", short.get("speed", 0))),
    }


async def _add_caught_wild_to_team(
    owner_id: str,
    mon: "Mon",
    *,
    caught_ball: Optional[str] = None,
) -> Optional[dict[str, Any]]:
    """
    Create a Pokemon row from a caught wild Mon.
    If team has room it is placed in team; otherwise it is routed to PC box storage.
    Returns a placement payload or None on failure.
    """
    try:
        base_long = _mon_to_long_stats(getattr(mon, "base", {}) or {})
        ivs_long = _mon_to_long_stats(getattr(mon, "ivs", {}) or {})
        evs_long = _mon_to_long_stats(getattr(mon, "evs", {}) or {})
        level = int(getattr(mon, "level", 5))
        nature = (
            getattr(mon, "nature", None)
            or getattr(mon, "nature_name", None)
            or "hardy"
        )
        nature = str(nature or "hardy").strip().lower() or "hardy"
        ability = _norm_ability_id(
            getattr(mon, "_original_ability", None)
            or getattr(mon, "ability", None)
        )
        gender = (getattr(mon, "gender", None) or "").strip() or None
        species = (getattr(mon, "species", None) or "").strip()
        if not species:
            return None
        # Guard against stale/invalid carried abilities (e.g. species mismatch).
        try:
            entry = None
            species_key = _daycare_norm_species(species)
            if db_cache is not None:
                entry = (
                    db_cache.get_cached_pokedex(species_key)
                    or db_cache.get_cached_pokedex(species.replace("-", " "))
                    or db_cache.get_cached_pokedex(species.lower())
                )
            if entry is None:
                entry = await ensure_species_and_learnsets(species)
            regs, hides, valid = _ability_set_from_entry(entry)
            if not ability and regs:
                ability = regs[0]
            elif not ability and hides:
                ability = hides[0]
            elif ability and valid and ability not in valid:
                ability = regs[0] if regs else hides[0]
        except Exception:
            pass
        final_stats = calc_all_stats(base_long, ivs_long, evs_long, level, nature)
        hp_max = int(max(1, final_stats.get("hp", 1)))
        ball_item_id = _normalize_ball_item_id(
            caught_ball
            or getattr(mon, "_caught_ball_name", None)
            or getattr(mon, "pokeball", None)
            or "poke_ball"
        )
        try:
            base_friendship = int(getattr(mon, "friendship", 0) or 0)
        except Exception:
            base_friendship = 0
        if base_friendship <= 0:
            base_friendship = await _get_base_friendship(species)
        starting_friendship = _caught_friendship_for_ball(base_friendship, ball_item_id)
        caught_hp_now = _caught_hp_for_ball(mon, hp_max, ball_item_id)
        mon_id = await db.add_pokemon_with_stats(
            owner_id=owner_id,
            species=species,
            level=level,
            final_stats=final_stats,
            ivs=ivs_long,
            evs=evs_long,
            nature=nature,
            ability=ability or "Unknown",
            gender=gender or "genderless",
            form=getattr(mon, "form", None),
            can_gigantamax=bool(getattr(mon, "can_gigantamax", False)),
            tera_type=getattr(mon, "tera_type", None),
        )
        async with db.session() as conn:
            exp_group = await _get_exp_group_for_species(conn, species)
            initial_exp = await _get_exp_total_for_level(conn, exp_group, level)
            try:
                await conn.execute(
                    "UPDATE pokemons SET exp=?, exp_group=?, hp_now=?, friendship=?, pokeball=? WHERE owner_id=? AND id=?",
                    (initial_exp, exp_group, int(caught_hp_now), int(starting_friendship), ball_item_id, owner_id, mon_id),
                )
            except Exception as update_err:
                msg = str(update_err or "").lower()
                # Backward-compatible fallback for databases that still lack pokeball column.
                if "pokeball" in msg and ("no such column" in msg or "does not exist" in msg):
                    await conn.execute(
                        "UPDATE pokemons SET exp=?, exp_group=?, hp_now=?, friendship=? WHERE owner_id=? AND id=?",
                        (initial_exp, exp_group, int(caught_hp_now), int(starting_friendship), owner_id, mon_id),
                    )
                else:
                    raise
            if getattr(mon, "shiny", False):
                await conn.execute("UPDATE pokemons SET shiny=1 WHERE owner_id=? AND id=?", (owner_id, mon_id))
            await conn.commit()
            db.invalidate_pokemons_cache(owner_id)
        try:
            setattr(mon, "friendship", int(starting_friendship))
        except Exception:
            pass
        moves = list(getattr(mon, "moves", []) or [])[:4]
        if moves:
            await db.set_pokemon_moves(owner_id, mon_id, moves)
        duplicate_in_team = await _team_has_species(owner_id, species, exclude_mon_id=int(mon_id))
        slot = await db.next_free_team_slot(owner_id)
        if slot is not None and not duplicate_in_team:
            await db.set_team_slot(owner_id, mon_id, slot)
            return {
                "mon_id": int(mon_id),
                "destination": "team",
                "team_slot": int(slot),
            }
        # Team is full OR same species already exists on team: send to PC box.
        try:
            await _box_prepare_storage(owner_id)
            async with db.session() as conn:
                cur = await conn.execute(
                    "SELECT box_no, box_pos FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                    (owner_id, int(mon_id)),
                )
                row = await cur.fetchone()
                await cur.close()
            if row:
                box_no = int((row["box_no"] if hasattr(row, "keys") else row[0]) or 0)
                box_pos = int((row["box_pos"] if hasattr(row, "keys") else row[1]) or 0)
                if box_no > 0 and box_pos > 0:
                    return {
                        "mon_id": int(mon_id),
                        "destination": "box",
                        "reason": "duplicate_team_species" if duplicate_in_team else "team_full",
                        "box_no": box_no,
                        "box_pos": box_pos,
                    }
        except Exception:
            pass
        return {
            "mon_id": int(mon_id),
            "destination": "box",
            "reason": "duplicate_team_species" if duplicate_in_team else "team_full",
        }
    except Exception as e:
        print(f"[PvP] Error adding caught wild to team: {e}")
        return None


async def _award_exp_to_party(st: "BattleState", winner_id: int, defeated: list["Mon"], *, force_per_faint: bool = False) -> Tuple[List[Tuple[int, "Mon", int]], List[Tuple["Mon", int, int, int]], List[Tuple["Mon", dict]]]:
    """Distribute XP and EVs to the winner's party. Returns (level_ups, exp_summary, ev_summary). When force_per_faint is True, award for a single fainted foe even if battle not yet over (per-faint EXP)."""
    empty: Tuple[List[Tuple[int, "Mon", int]], List[Tuple["Mon", int, int, int]], List[Tuple["Mon", dict]]] = ([], [], [])
    if not defeated:
        return empty
    if not force_per_faint and st.winner != winner_id:
        return empty

    party = st.team_for(winner_id)
    participants = st.p1_participants if winner_id == st.p1_id else st.p2_participants
    participant_raw = set(participants or set())
    participant_text = {str(p) for p in participant_raw}

    def _mon_participated(mon: "Mon") -> bool:
        key = getattr(mon, "_db_id", None) or mon.species
        return (key in participant_raw) or (str(key) in participant_text)

    def _has_exp_share_item(mon: "Mon") -> bool:
        item_norm = str(getattr(mon, "item", "") or "").strip().lower().replace("_", "-").replace(" ", "-").replace(".", "")
        return item_norm in {"exp-share", "expshare"}

    exp_share_on = bool(EXP_SHARE_ALWAYS_ON) or any(_has_exp_share_item(m) for m in party if m)

    async with db.session() as conn:
        # Teamwide Exp Share from bag purchase (/expshare).
        if not exp_share_on:
            try:
                owner_id = str(winner_id)
                if int(owner_id) > 0 and await _has_exp_share_bag_item(owner_id, conn=conn):
                    exp_share_on = True
            except Exception:
                pass

        party_recipients = []
        for m in party:
            if not m or m.hp <= 0:
                continue
            if exp_share_on or _mon_participated(m):
                party_recipients.append(m)
        db_ids = [getattr(m, "_db_id", None) for m in party_recipients if getattr(m, "_db_id", None) is not None]
        if not db_ids:
            return empty

        # Total EV yield from all defeated foes (wild/trainer) with DB fallback when cache misses.
        ev_yield_cache: dict[str, dict[str, int]] = {}

        def _to_ev_map(raw: Any) -> dict[str, int]:
            if isinstance(raw, str):
                try:
                    raw = json.loads(raw) if raw else {}
                except Exception:
                    raw = {}
            if not isinstance(raw, Mapping):
                raw = {}
            normalized = _normalize_stats_keys(dict(raw))
            return {
                "hp": max(0, int(normalized.get("hp", 0) or 0)),
                "atk": max(0, int(normalized.get("atk", normalized.get("attack", 0)) or 0)),
                "defn": max(0, int(normalized.get("defn", normalized.get("def", normalized.get("defense", 0))) or 0)),
                "spa": max(0, int(normalized.get("spa", normalized.get("special_attack", 0)) or 0)),
                "spd": max(0, int(normalized.get("spd", normalized.get("special_defense", 0)) or 0)),
                "spe": max(0, int(normalized.get("spe", normalized.get("speed", 0)) or 0)),
            }

        async def _species_ev_yield(species_name: str) -> dict[str, int]:
            key = _daycare_norm_species(species_name)
            if key in ev_yield_cache:
                return ev_yield_cache[key]
            out = _get_ev_yield_for_species(species_name)
            if any(out.get(k, 0) > 0 for k in _STAT_KEYS_SHORT):
                ev_yield_cache[key] = out
                return out
            fetched: dict[str, int] = {k: 0 for k in _STAT_KEYS_SHORT}
            try:
                cur_ev = await conn.execute(
                    "SELECT ev_yield FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1",
                    (species_name,),
                )
                row_ev = await cur_ev.fetchone()
                await cur_ev.close()
                if row_ev:
                    fetched = _to_ev_map(row_ev.get("ev_yield") if hasattr(row_ev, "keys") else row_ev[0])
            except Exception:
                fetched = {k: 0 for k in _STAT_KEYS_SHORT}
            ev_yield_cache[key] = fetched
            return fetched

        total_ev_yield = {k: 0 for k in _STAT_KEYS_SHORT}
        for foe in defeated:
            yield_one = await _species_ev_yield(getattr(foe, "species", "") or "")
            for k in _STAT_KEYS_SHORT:
                total_ev_yield[k] = total_ev_yield.get(k, 0) + yield_one.get(k, 0)
        has_ev_yield = any(total_ev_yield.get(k, 0) > 0 for k in _STAT_KEYS_SHORT)

        placeholders = ",".join("?" for _ in db_ids)
        cur = await conn.execute(
            f"SELECT id, exp, exp_group, evs FROM pokemons WHERE id IN ({placeholders})",
            tuple(db_ids),
        )
        rows = await cur.fetchall()
        await cur.close()
        # Use int(id) as key so lookup matches mid regardless of DB driver type (int/str/bigint)
        exp_map = {int(r["id"]): (int(r["exp"] or 0), r["exp_group"] or "medium_fast", r.get("evs")) for r in rows}

        level_ups: List[Tuple[int, "Mon", int]] = []
        exp_summary: List[Tuple["Mon", int, int, int]] = []
        ev_summary: List[Tuple["Mon", dict]] = []

        def gain_for(mon_level: int, foe_level: int, base_exp: int, gen: int, trainer_bonus: bool, outsider: bool, lucky_egg: bool, affection_boost: bool, split: int) -> int:
            if gen <= 4:
                base = (base_exp * foe_level) // 7
            else:
                ratio = ((2 * foe_level + 10) ** 2) / ((foe_level + mon_level + 10) ** 2)
                base = (base_exp * foe_level / 5) * ((ratio ** 1.5) + 1)
            mult = 1.0
            mult *= 1.15 if trainer_bonus else 1.0  # 15% more than wild
            mult *= 1.5 if outsider else 1.0
            mult *= 1.5 if lucky_egg else 1.0
            mult *= 1.2 if affection_boost else 1.0
            base = base / max(1, split)
            return max(1, int(base * mult))

        trainer_foe = not (str(st.p2_name).lower().startswith("wild "))
        split = 1 if exp_share_on else max(
            1,
            len([m for m in party if m and m.hp > 0 and _mon_participated(m)]),
        )
        for mon in party_recipients:
            mid = getattr(mon, "_db_id", None)
            if mid is None:
                continue
            cur_exp, eg, evs_raw = exp_map.get(int(mid), (0, "medium_fast", None))
            total_gain = 0
            outsider = str(getattr(mon, "_owner_id", winner_id)) != str(winner_id)
            lucky_egg = (mon.item or "").lower().replace(" ", "-") == "lucky-egg"
            affection_boost = getattr(mon, "friendship", 0) >= 220
            for foe in defeated:
                cur_dex = await conn.execute(
                    "SELECT base_experience FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1",
                    (foe.species,),
                )
                base_row = await cur_dex.fetchone()
                await cur_dex.close()
                base_exp = base_row["base_experience"] if base_row and base_row.get("base_experience") is not None else 50
                total_gain += gain_for(mon.level, foe.level, base_exp, st.gen, trainer_foe, outsider, lucky_egg, affection_boost, split)

            new_exp = cur_exp + total_gain
            cur_old = await conn.execute(
                "SELECT level FROM exp_requirements WHERE group_code = ? AND exp_total <= ? ORDER BY level DESC LIMIT 1",
                (eg, cur_exp),
            )
            row_old = await cur_old.fetchone()
            await cur_old.close()
            old_level = int(row_old["level"]) if row_old and row_old.get("level") is not None else 1
            cur_new = await conn.execute(
                "SELECT level FROM exp_requirements WHERE group_code = ? AND exp_total <= ? ORDER BY level DESC LIMIT 1",
                (eg, new_exp),
            )
            row_new = await cur_new.fetchone()
            await cur_new.close()
            raw_new_lvl = int(row_new["level"]) if row_new and row_new.get("level") is not None else 1
            # Never decrease level (e.g. if cur_exp was wrong/missing) or exceed 100
            new_lvl = min(100, max(mon.level, raw_new_lvl))
            # If we clamped level up, ensure exp is at least the exp for that level (keep DB consistent)
            if new_lvl > raw_new_lvl:
                min_exp = await _get_exp_total_for_level(conn, eg, new_lvl)
                if min_exp is not None and new_exp < min_exp:
                    new_exp = min_exp
            await conn.execute("UPDATE pokemons SET exp=?, level=? WHERE id=?", (new_exp, new_lvl, mid))
            exp_summary.append((mon, total_gain, old_level, new_lvl))
            if new_lvl > old_level:
                level_ups.append((mid, mon, new_lvl))
            # Award EVs from defeated foes (wild EV farming)
            if has_ev_yield:
                current_evs = _normalize_ivs_evs(evs_raw, default_val=0)
                new_evs = _cap_evs({k: current_evs[k] + total_ev_yield.get(k, 0) for k in _STAT_KEYS_SHORT})
                ev_gains = {k: new_evs[k] - current_evs[k] for k in _STAT_KEYS_SHORT if new_evs[k] - current_evs[k] > 0}
                if ev_gains:
                    await conn.execute("UPDATE pokemons SET evs=? WHERE id=?", (json.dumps(new_evs, ensure_ascii=False), mid))
                    ev_summary.append((mon, ev_gains))
        await conn.commit()
        db.invalidate_pokemons_cache(str(winner_id))
        try:
            register_stats.buffer_exp_from_summary(st, str(winner_id), exp_summary)
        except Exception:
            pass
        return (level_ups, exp_summary, ev_summary)


async def _get_level_up_moves_at_level(conn, species_name: str, level: int, gen: int) -> List[str]:
    """Return move names (display format) learned at exactly this level for the species (level-up, generation)."""
    try:
        cur = await conn.execute("SELECT id FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1", (species_name,))
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return []
        species_id = row["id"]
        cur = await conn.execute(
            """
            SELECT m.name FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE l.species_id=? AND l.generation=? AND l.method='level-up'
              AND COALESCE(l.level_learned,0)=?
            ORDER BY m.name
            """,
            (species_id, gen, level),
        )
        rows = await cur.fetchall()
        await cur.close()
        return [(r["name"] or "").replace("-", " ").title() for r in rows if r.get("name")]
    except Exception:
        return []


async def _award_money_after_battle(st: "BattleState", winner_id: int, defeated: list["Mon"]) -> int:
    """Award prize money + move-based cash; participants only; win only."""
    if st.winner != winner_id:
        return 0

    # Build participant set and team
    participants = st.p1_participants if winner_id == st.p1_id else st.p2_participants
    team = st.team_for(winner_id)
    part_mons = [m for m in team if m and (getattr(m, "_db_id", None) or m.species) in participants]
    if not part_mons:
        return 0

    # Base prize: trainer battles only
    is_wild = str(st.p2_name).lower().startswith("wild ")
    avg_foe_lvl = int(sum(getattr(f, "level", 1) for f in defeated) / max(1, len(defeated)))
    base_prize = 0 if is_wild else max(100, avg_foe_lvl * 100)

    # Move-based pool (Pay Day, Make It Rain, G-Max Gold Rush)
    pool = 0
    if hasattr(st, "money_pool"):
        pool = st.money_pool.get(winner_id, 0)

    # Multipliers
    mult = 1.0
    if hasattr(st, "happy_hour_used") and st.happy_hour_used.get(winner_id):
        mult *= 2.0
    # Amulet Coin / Luck Incense if any participant held it
    has_money_item = any(
        (getattr(m, "item", "") or "").lower().replace(" ", "-") in {"amulet-coin", "luck-incense"}
        for m in part_mons
    )
    if has_money_item:
        mult *= 2.0

    total = int((base_prize + pool) * mult)
    if total <= 0:
        return 0

    # Upsert coins (currencies JSON)
    await db.add_currency(str(winner_id), "coins", total)
    return total

async def _heal_party(user_id: str) -> int:
    healed = 0
    user_gen = await _user_selected_gen(user_id)
    async with db.session() as conn:
        try:
            cur = await conn.execute(
                "SELECT id, species, level, nature, ivs, evs, hp, moves, moves_pp_min, moves_pp_max FROM pokemons WHERE owner_id=? AND team_slot IS NOT NULL ORDER BY team_slot",
                (user_id,),
            )
        except Exception:
            cur = await conn.execute(
                "SELECT id, species, level, nature, ivs, evs, hp, moves "
                "FROM pokemons WHERE owner_id=? AND team_slot IS NOT NULL ORDER BY team_slot",
                (user_id,),
            )
        rows = await cur.fetchall()
        await cur.close()
        cached_base_stats: Dict[str, dict] = {}
        species_keys: set[str] = {
            str(r.get("species") or "").strip().lower().replace(" ", "-")
            for r in rows
            if str(r.get("species") or "").strip()
        }
        missing_species: list[str] = []

        for species_key in species_keys:
            raw_stats: Any = None
            if db_cache is not None:
                try:
                    entry = (
                        db_cache.get_cached_pokedex(species_key)
                        or db_cache.get_cached_pokedex(species_key.replace("-", " "))
                        or db_cache.get_cached_pokedex(species_key.replace("-", "_"))
                    )
                    if entry:
                        raw_stats = entry.get("stats")
                except Exception:
                    raw_stats = None

            if raw_stats is None:
                missing_species.append(species_key)
                continue

            if isinstance(raw_stats, str):
                try:
                    raw_stats = json.loads(raw_stats)
                except Exception:
                    raw_stats = {}
            cached_base_stats[species_key] = raw_stats if isinstance(raw_stats, dict) else {}

        if missing_species:
            placeholders = ", ".join(["?"] * len(missing_species))
            try:
                cur_stats = await conn.execute(
                    f"SELECT LOWER(REPLACE(name,' ','-')) AS species_key, stats FROM pokedex WHERE LOWER(REPLACE(name,' ','-')) IN ({placeholders})",
                    tuple(missing_species),
                )
                stat_rows = await cur_stats.fetchall()
                await cur_stats.close()
                for srow in stat_rows:
                    s_key = str(srow.get("species_key") or "").strip().lower()
                    raw_stats = srow.get("stats")
                    if isinstance(raw_stats, str):
                        try:
                            raw_stats = json.loads(raw_stats)
                        except Exception:
                            raw_stats = {}
                    cached_base_stats[s_key] = raw_stats if isinstance(raw_stats, dict) else {}
            except Exception:
                pass

            for species_key in missing_species:
                cached_base_stats.setdefault(species_key, {})

        for row in rows:
            hp_max = max(1, int(row.get("hp") or 1))
            try:
                species_key = str(row.get("species") or "").strip().lower().replace(" ", "-")
                level = max(1, int(row.get("level") or 1))
                nature = str(row.get("nature") or "hardy").strip().lower() or "hardy"

                ivs_raw = row.get("ivs")
                if isinstance(ivs_raw, str):
                    try:
                        ivs_raw = json.loads(ivs_raw)
                    except Exception:
                        ivs_raw = {}
                evs_raw = row.get("evs")
                if isinstance(evs_raw, str):
                    try:
                        evs_raw = json.loads(evs_raw)
                    except Exception:
                        evs_raw = {}
                ivs = _normalize_ivs_evs(ivs_raw, default_val=0)
                evs = _normalize_ivs_evs(evs_raw, default_val=0)

                if species_key:
                    raw_stats = cached_base_stats.get(species_key, {})
                    base_long = _normalize_stats_for_generator(raw_stats or {})
                    ivs_long = {
                        "hp": ivs["hp"], "attack": ivs["atk"], "defense": ivs["defn"],
                        "special_attack": ivs["spa"], "special_defense": ivs["spd"], "speed": ivs["spe"],
                    }
                    evs_long = {
                        "hp": evs["hp"], "attack": evs["atk"], "defense": evs["defn"],
                        "special_attack": evs["spa"], "special_defense": evs["spd"], "speed": evs["spe"],
                    }
                    final_stats = calc_all_stats(base_long, ivs_long, evs_long, level, nature)
                    hp_max = max(hp_max, int(final_stats.get("hp") or hp_max or 1))
            except Exception:
                pass

            moves = []
            try:
                moves = json.loads(row["moves"]) if row.get("moves") else []
            except Exception:
                moves = []
            base_caps = [_pp_move_base(str(m), user_gen) for m in moves[:4]] if moves else []
            global_caps = [_pp_move_global_max(str(m), user_gen) for m in moves[:4]] if moves else []
            stored_max = _pp_parse_int_list(
                row.get("moves_pp_max"),
                count=len(base_caps),
                defaults=base_caps,
                lo=1,
                hi=999,
            ) if base_caps else []
            for i in range(len(stored_max)):
                stored_max[i] = max(base_caps[i], min(stored_max[i], global_caps[i]))
            try:
                await conn.execute(
                    "UPDATE pokemons SET hp=?, hp_now=?, moves_pp=?, moves_pp_min=?, moves_pp_max=? WHERE id=?",
                    (
                        hp_max,
                        hp_max,
                        json.dumps(stored_max, ensure_ascii=False),
                        json.dumps([0] * len(stored_max), ensure_ascii=False),
                        json.dumps(stored_max, ensure_ascii=False),
                        int(row["id"]),
                    ),
                )
            except Exception:
                await conn.execute(
                    "UPDATE pokemons SET hp=?, hp_now=?, moves_pp=? WHERE id=?",
                    (hp_max, hp_max, json.dumps(stored_max, ensure_ascii=False), int(row["id"])),
                )
            healed += 1
        await conn.commit()
        db.invalidate_pokemons_cache(user_id)
    return healed

# Sentinel: _start_pve_battle returns this when user is already in a battle (message already sent). Callers must not send "Couldn't start...".
_PVE_ALREADY_IN_BATTLE = object()

async def _start_pve_battle(
    itx: discord.Interaction,
    opponent_team: list["Mon"],
    opponent_name: str,
    *,
    fmt_label: str = "Adventure",
    trainer_challenge: Optional[str] = None,
    trainer_quote: Optional[str] = None,
    area_id: Optional[str] = None,
    route_display_name: Optional[str] = None,
    resend_adventure_panel: bool = True,
) -> Optional[bool]:
    from pvp.manager import get_manager
    from pvp.panel import BattleState, _turn_loop
    from pvp.engine import build_party_from_db

    bm = get_manager()
    # Older pvp manager versions don't have this helper
    if hasattr(bm, 'clear_stale_for_user'):
        bm.clear_stale_for_user(itx.user.id)  # auto-clear glitched "in battle" if room is old
    if bm.for_user(itx.user.id):
        await itx.followup.send("You're already in a battle.", ephemeral=False)
        return _PVE_ALREADY_IN_BATTLE  # type: ignore[return-value]

    # Create dummy opponent ID
    dummy_opponent_id = -itx.user.id - 1
    room = bm.add(
        guild_id=itx.guild_id,
        channel_id=itx.channel_id,
        challenger_id=itx.user.id,
        opponent_id=dummy_opponent_id,
        ranked=False,
        fmt_key="adventure",
    )

    p1_party = await build_party_from_db(itx.user.id, set_level=None, heal=False)
    if not p1_party:
        await itx.followup.send("Could not load your team.", ephemeral=False)
        bm.remove(room)
        return None

    p1_name = itx.user.display_name if hasattr(itx.user, "display_name") else itx.user.name
    p2_name = opponent_name
    generation = await _user_selected_gen(str(itx.user.id))
    st = BattleState(fmt_label, generation, itx.user.id, dummy_opponent_id, p1_party, opponent_team, p1_name, p2_name, p1_is_bot=False, p2_is_bot=True, is_dummy_battle=False)
    if trainer_challenge is not None:
        st.trainer_challenge = trainer_challenge
    if trainer_quote is not None:
        st.trainer_quote = trainer_quote
    if fmt_label.lower().startswith("adventure") or fmt_label.lower() == "rival":
        st._hide_opponent_moves = True
    if area_id is not None:
        st.adventure_area_id = area_id
    if route_display_name is not None:
        st.adventure_route_display_name = route_display_name
    st._bag_embed_builder = lambda p=1: _build_bag_embed_for_battle(itx.user.id, p)
    # Per-faint EXP: award EXP after each opponent Pok√©mon that faints (not only at battle end)
    st._exp_award_pending = []
    st._exp_level_ups = []
    st._exp_summary = []
    st._exp_ev_summary = []

    async def _on_opponent_faint(_st: "BattleState", fainted_mon: "Mon") -> None:
        try:
            fainted_owner = str(getattr(fainted_mon, "_owner_id", "") or "")
        except Exception:
            fainted_owner = ""
        # Ignore ally faint callbacks; only award when the opponent faints.
        if fainted_owner and fainted_owner == str(itx.user.id):
            return
        lu, es, evs = await _award_exp_to_party(_st, itx.user.id, [fainted_mon], force_per_faint=True)
        _st._exp_level_ups.extend(lu)
        _st._exp_summary.extend(es)
        _st._exp_ev_summary.extend(evs)
        # Update in-memory level so subsequent EXP calculations use correct level
        for mid, mon, new_lvl in lu:
            for m in _st.p1_team or []:
                if getattr(m, "_db_id", None) == mid:
                    m.level = new_lvl
                    break

    st._award_exp_on_faint_callback = _on_opponent_faint
    # Seed battle-state with dex/repeat info for capture logic
    try:
        seen_list = await pokedex_seen_species(str(itx.user.id))
        caught_list = await pokedex_caught_species(str(itx.user.id))
        summary = await pokedex_summary(str(itx.user.id))
        st.repeat_seen = seen_list
        st.repeat_caught = caught_list
        st.dex_seen = summary.get("seen", 0)
    except Exception:
        st.repeat_seen = []
        st.repeat_caught = []
        st.dex_seen = 0

    await _load_pp_from_db(st, itx.user.id)

    class DummyInteraction:
        def __init__(self, user_id):
            self.user = type("User", (), {"id": user_id, "display_name": p2_name, "name": p2_name})()
            self.channel = itx.channel
            self.guild_id = itx.guild_id
            class MockFollowup:
                async def send(self, *args, **kwargs):
                    return None
            self._followup = MockFollowup()

        @property
        def followup(self):
            return self._followup

    p2_itx = DummyInteraction(dummy_opponent_id)

    # For Adventure trainer/rival battles: award (or deduct) money before end embed so it shows in the same message
    TRAINER_LOSS_PKC = 300

    async def _award_and_set_money(st):
        if st.winner != st.p1_id and st.winner != st.p2_id:
            return
        winner_id = st.p1_id if st.winner == st.p1_id else st.p2_id
        defeated = st.p2_team if st.winner == st.p1_id else st.p1_team
        gained = await _award_money_after_battle(st, winner_id, defeated)
        st._money_earned = gained if winner_id == st.p1_id else 0
        if st.winner == st.p2_id:
            # Only deduct coins when losing to a trainer, not to wild Pok√©mon
            is_trainer_battle = not (str(st.p2_name or "").lower().startswith("wild "))
            if is_trainer_battle:
                st._money_lost = TRAINER_LOSS_PKC
                async with db.session() as conn:
                    await conn.execute(
                        "UPDATE users SET currencies = jsonb_set(COALESCE(NULLIF(currencies::text, 'null')::jsonb, '{}'::jsonb), '{coins}', to_jsonb(GREATEST(0, COALESCE((currencies->>'coins')::int, 0) - ?))) WHERE user_id = ?",
                        (TRAINER_LOSS_PKC, str(itx.user.id)),
                    )
                    await conn.commit()
            else:
                st._money_lost = 0
        else:
            st._money_lost = 0

    turn_loop_error: Optional[Exception] = None
    try:
        # Store battle state on room so /refresh can re-send battle panel
        room.battle_state = st
        # Callback so panel can set last-panel when it sends battle UI (for /refresh = re-send latest panel)
        def _set_last_panel(uid: str, panel_type: str, data: dict) -> None:
            LAST_PANEL_BY_USER[uid] = {"type": panel_type, "data": data}
        st._set_last_panel = _set_last_panel
        # Only pass award_money_callback if this panel version supports it (avoids TypeError on older panel)
        kwargs = {"room_id": room.id}
        if "award_money_callback" in inspect.signature(_turn_loop).parameters:
            kwargs["award_money_callback"] = _award_and_set_money if fmt_label.lower().startswith("adventure") or fmt_label.lower() == "rival" else None
        if "cancel_previous_panel" in inspect.signature(_turn_loop).parameters:
            kwargs["cancel_previous_panel"] = lambda uid: _cancel_previous_panel_for_user(itx.client, uid)
        await _turn_loop(st, itx, p2_itx, **kwargs)
    except Exception as e:
        turn_loop_error = e
        try:
            import traceback as _tb
            print(f"[PvP] _turn_loop error in adventure battle: {type(e).__name__}: {e}")
            _tb.print_exc()
        except Exception:
            pass
    finally:
        await _save_party_state_from_battle(st, itx.user.id)
        level_ups: List[Tuple[int, "Mon", int]] = []
        exp_summary: List[Tuple["Mon", int, int, int]] = []
        ev_summary: List[Tuple["Mon", dict]] = []
        try:
            # Use per-faint EXP results if we awarded after each opponent KO; otherwise award once at end
            if getattr(st, "_exp_summary", None):
                level_ups = getattr(st, "_exp_level_ups", []) or []
                exp_summary = getattr(st, "_exp_summary", []) or []
                ev_summary = getattr(st, "_exp_ev_summary", []) or []
            else:
                level_ups, exp_summary, ev_summary = await _award_exp_to_party(st, itx.user.id, opponent_team)
                # End-of-battle fallback: if per-faint callback did not run, persist register EXP now.
                try:
                    if exp_summary:
                        await register_stats.add_exp_from_summary(str(itx.user.id), exp_summary)
                except Exception:
                    pass
        except Exception:
            pass
        # Adventure (wild or trainer/rival): send one combined embed (battle ended + outcome + last turn + EXP/level-ups + money)
        # Skip when player ran away ‚Äî they already got "You got away safely!" from the panel
        is_adventure = fmt_label.lower().startswith("adventure") or fmt_label.lower() == "rival"
        is_adventure_wild = is_adventure and (st.p2_name or "").lower().startswith("wild ")
        p1_ran_away = getattr(st, "_p1_ran_away", False)
        # Fallback: if turn loop failed after a throw was chosen, retry one capture roll
        # so wild catches do not silently collapse into a draw due an internal exception.
        if turn_loop_error is not None and is_adventure_wild and st.winner is None and not p1_ran_away:
            fallback_ball = getattr(st, "_last_throw_ball", None)
            if fallback_ball:
                try:
                    from pvp.panel import _attempt_capture as _panel_attempt_capture
                    wild_active = st._active(st.p2_id)
                    if wild_active is not None and int(getattr(wild_active, "hp", 0) or 0) > 0:
                        caught_fb, shakes_fb = _panel_attempt_capture(wild_active, str(fallback_ball), st)
                        try:
                            shakes_i = int(shakes_fb or 0)
                            if shakes_i > 0:
                                st._throw_shakes = max(int(getattr(st, "_throw_shakes", 0) or 0), shakes_i)
                        except Exception:
                            pass
                        if caught_fb:
                            st.winner = st.p1_id
                            st._caught_wild_mon = wild_active
                            st._caught_ball_name = str(fallback_ball or "")
                            try:
                                setattr(wild_active, "_caught_ball_name", str(fallback_ball or ""))
                            except Exception:
                                pass
                            display = str(getattr(wild_active, "species", "Pok√©mon") or "Pok√©mon").replace("-", " ").title()
                            msg = f"**{st.p1_name}** threw a {str(fallback_ball).replace('_', ' ').title()}! It shook {int(shakes_fb or 1)} time(s) and **caught {display}!**"
                            fb_log = list(getattr(st, "_last_turn_log", []) or [])
                            if not any("caught" in str(line).lower() for line in fb_log):
                                fb_log.append(msg)
                                st._last_turn_log = fb_log
                except Exception:
                    pass
        if is_adventure and not p1_ran_away:
            opp_name = (st.p2_name or "").replace("Wild ", "").strip() or ("Wild Pok√©mon" if is_adventure_wild else "Trainer")
            opp_level = 0
            try:
                if st.p2_team and len(st.p2_team) > 0:
                    opp_mon = st.p2_team[getattr(st, "p2_active", 0)] if getattr(st, "p2_active", 0) < len(st.p2_team) else st.p2_team[0]
                    opp_level = getattr(opp_mon, "level", 0) or 0
            except Exception:
                pass
            route_name = getattr(st, "adventure_route_display_name", None) or getattr(st, "fmt_label", None) or "Adventure"
            user_tag = f"{itx.user.name}#{getattr(itx.user, 'discriminator', '0')}"
            ts = datetime.utcnow().strftime("%d %B %Y - %I:%M:%S %p UTC")
            last_log = list(getattr(st, "_last_turn_log", []) or [])
            # Shake-by-shake embeds when a ball was thrown (wild only)
            if is_adventure_wild:
                throw_shakes = getattr(st, "_throw_shakes", 0) or 0
                if throw_shakes > 0 and last_log and any("threw a" in line and "shook" in line for line in last_log):
                    shake_msg = None
                    for i in range(1, throw_shakes + 1):
                        shake_emb = discord.Embed(description=f"Shake {i}!", color=0x5865F2)
                        try:
                            if shake_msg is None:
                                # Use one ephemeral message and update it each shake.
                                shake_msg = await itx.followup.send(embed=shake_emb, ephemeral=True, wait=True)
                            else:
                                await shake_msg.edit(embed=shake_emb)
                        except Exception:
                            # Fallback: still keep it private even if editable message fetch fails.
                            if shake_msg is None:
                                try:
                                    await itx.followup.send(embed=shake_emb, ephemeral=True)
                                except Exception:
                                    pass
                        if i < throw_shakes:
                            await asyncio.sleep(1.5)
            # Outcome
            caught_this_turn = any("and **caught" in line for line in last_log) if is_adventure_wild else False
            pending_evos: List[Tuple[int, "Mon", str, int]] = []
            if st.winner == itx.user.id:
                outcome_desc = "" if (is_adventure_wild and caught_this_turn) else (
                    f"**{st.p1_name}** won the battle! You've won the wild battle against a Lv. {opp_level} {opp_name} :)" if is_adventure_wild
                    else f"You've won the battle against {st.p2_name}."
                )
            elif st.winner == st.p2_id:
                outcome_desc = f"You've lost the wild battle against a Lv. {opp_level} {opp_name} :)" if is_adventure_wild else f"You've lost the battle against {st.p2_name}."
            else:
                if turn_loop_error is not None:
                    outcome_desc = "The battle ended unexpectedly."
                else:
                    outcome_desc = "The battle ended in a draw."
            title = "Wild battle has ended!" if is_adventure_wild else f"{st.p2_name} battle ended!"
            emb = discord.Embed(title=title, description="", color=0x5865F2)
            emb.set_footer(text=f"{user_tag} | {route_name} | {ts}")
            # Order: 1) last turn (no title), 2) victory/loss message (if any), 3) EXP etc
            if last_log:
                emb.add_field(name="", value="\n".join(last_log), inline=False)
            if outcome_desc:
                emb.add_field(name="", value=outcome_desc, inline=False)
            # Money earned/lost
            money_earned = getattr(st, "_money_earned", None)
            money_lost = getattr(st, "_money_lost", None)
            if money_earned is not None and money_earned > 0:
                emb.add_field(name="", value=f"You earned {money_earned:,} Pok√©Dollars.", inline=False)
            if money_lost is not None and money_lost > 0:
                emb.add_field(name="", value=f"You lost {money_lost:,} Pok√©Dollars.", inline=False)
            # EXP & level-ups (only when player won)
            if st.winner == itx.user.id and exp_summary:
                lines: List[str] = []
                new_moves_all: List[str] = []
                async with db.session() as conn:
                    for mon, exp_gain, old_lvl, new_lvl in exp_summary:
                        name = (mon.species or "Pok√©mon").replace("-", " ").title()
                        if new_lvl > old_lvl:
                            lines.append(f"**{name}** gained **{exp_gain}** EXP and grew to level **{new_lvl}**.")
                        else:
                            lines.append(f"**{name}** gained **{exp_gain}** EXP!")
                    for mid, mon, new_lvl in level_ups:
                        moves_at_lvl = await _get_level_up_moves_at_level(conn, mon.species or "", new_lvl, st.gen)
                        if moves_at_lvl:
                            name = (mon.species or "Pok√©mon").replace("-", " ").title()
                            new_moves_all.append(f"**{name}** can now learn {', '.join(moves_at_lvl)}.")
                if lines:
                    emb.add_field(name="", value="\n".join(lines), inline=False)
                    if new_moves_all:
                        emb.add_field(name="", value="\n".join(new_moves_all), inline=False)
            # EV gains (wild and trainer battles)
            if st.winner == itx.user.id and ev_summary:
                _EV_STAT_DISPLAY = {"hp": "HP", "atk": "Atk", "defn": "Def", "spa": "SpA", "spd": "SpD", "spe": "Spe"}
                ev_lines: List[str] = []
                for mon, ev_gains in ev_summary:
                    name = (mon.species or "Pok√©mon").replace("-", " ").title()
                    parts = [f"{_EV_STAT_DISPLAY.get(k, k)} +{v}" for k, v in ev_gains.items()]
                    ev_lines.append(f"**{name}** gained EVs: {', '.join(parts)}.")
                if ev_lines:
                    emb.add_field(name="", value="\n".join(ev_lines), inline=False)
            # Evolution readiness (level-up trigger): include a summary line in battle result,
            # then send one Yes/No prompt per eligible mon immediately after.
            if st.winner == itx.user.id and level_ups:
                async with db.session() as conn:
                    for mid, mon, new_lvl in level_ups:
                        held = (mon.item or "").strip().lower().replace(" ", "-")
                        if held == "everstone":
                            continue
                        evo_name = await _get_level_up_evolution(
                            conn,
                            mon.species,
                            new_lvl,
                            friendship=getattr(mon, "friendship", None),
                            gender=getattr(mon, "gender", None),
                            moves=getattr(mon, "moves", None),
                            held_item=getattr(mon, "item", None),
                            area_id=getattr(st, "adventure_area_id", None),
                        )
                        if evo_name:
                            pending_evos.append((mid, mon, evo_name, new_lvl))
            if pending_evos:
                ready_lines = [
                    f"‚¨ÜÔ∏è **{(mon.species or 'Pok√©mon').replace('-', ' ').title()}** is ready to evolve into **{evo.replace('-', ' ').title()}**."
                    for _mid, mon, evo, _lvl in pending_evos
                ]
                emb.add_field(name="", value="\n".join(ready_lines), inline=False)
            # Add caught wild Pok√©mon to team/box (wild only), and show where it went if team was full.
            if is_adventure_wild and st.winner == itx.user.id:
                caught_mon = getattr(st, "_caught_wild_mon", None)
                if caught_mon is not None:
                    try:
                        caught_ball = (
                            getattr(st, "_caught_ball_name", None)
                            or getattr(caught_mon, "_caught_ball_name", None)
                            or getattr(st, "_last_throw_ball", None)
                        )
                        placement = await _add_caught_wild_to_team(
                            str(itx.user.id),
                            caught_mon,
                            caught_ball=caught_ball,
                        )
                        if placement and str(placement.get("destination")) == "box":
                            display = str(getattr(caught_mon, "species", "Pok√©mon") or "Pok√©mon").replace("-", " ").title()
                            bno = placement.get("box_no")
                            bpos = placement.get("box_pos")
                            reason = str(placement.get("reason") or "")
                            if bno and bpos and reason == "duplicate_team_species":
                                msg = f"**{display}** was sent to **Box {bno}, Slot {bpos}** because that species is already on your team."
                            elif bno and bpos:
                                msg = f"**{display}** was sent to **Box {bno}, Slot {bpos}** because your team is full."
                            elif reason == "duplicate_team_species":
                                msg = f"**{display}** was sent to your **PC Box** because that species is already on your team."
                            else:
                                msg = f"**{display}** was sent to your **PC Box** because your team is full."
                            emb.add_field(name="", value=msg, inline=False)
                    except Exception as e:
                        print(f"[PvP] Error adding caught wild to storage: {e}")
            # Rare drop: TM Fragment (rolled for every adventure wild win: grass path + /route)
            if is_adventure_wild and st.winner == itx.user.id and random.random() < TM_FRAGMENT_DROP_CHANCE:
                try:
                    await db.upsert_item_master(TM_FRAGMENT_ITEM_ID, name="TM Fragment")
                    await db.give_item(str(itx.user.id), TM_FRAGMENT_ITEM_ID, 1)
                    emb.add_field(name="", value="You found a **TM Fragment** on the ground!", inline=False)
                except Exception:
                    pass
            try:
                await itx.followup.send(embed=emb, ephemeral=False)
            except Exception:
                pass
        # Evolution prompts: one Yes/No prompt per eligible Pok√©mon.
        if pending_evos:
            for mid, mon, evo_name, new_lvl in pending_evos:
                cur_name = (mon.species or "").replace("-", " ").title()
                evo_display = evo_name.replace("-", " ").title()
                emb = discord.Embed(
                    title="A Pok√©mon is evolving!",
                    description=f"What? **{cur_name}** is evolving into ... **{evo_display}**!\n\nDo you want to evolve it?",
                    color=0x9B59B6,
                )
                emb.set_footer(text="Please click Yes or No first.")
                view = EvolutionConfirmView(itx.user.id, str(itx.user.id), mid, mon.species, evo_name, new_lvl)
                try:
                    await itx.followup.send(embed=emb, view=view)
                except Exception:
                    pass
        # For non-Adventure/Rival, award money here and send followup; Adventure/Rival already did it in callback (shown in end embed)
        if not (fmt_label.lower().startswith("adventure") or fmt_label.lower() == "rival"):
            try:
                gained = await _award_money_after_battle(st, itx.user.id, opponent_team)
                if gained > 0:
                    await itx.followup.send(f"üí∞ You earned {gained:,} {PKDollar_NAME}.", ephemeral=False)
            except Exception:
                pass
        # If player blacked out (all team fainted), send them back to last city and heal (or on route-22 rival loss, rival heals and stay)
        if fmt_label == "Adventure" or fmt_label == "Rival":
            try:
                player_fainted = all(mon.hp <= 0 for mon in st.p1_team if mon)
            except Exception:
                player_fainted = False
            if player_fainted:
                state = await _get_adventure_state(str(itx.user.id))
                adv_area = getattr(st, "adventure_area_id", None)
                if adv_area == "route-22" and fmt_label == "Rival":
                    # Rival heals the user; stay on route-22. Panel is sent by _run_rival_battle with "Rival Wins!" and updated state.
                    await _heal_party(str(itx.user.id))
                else:
                    fallback_city = state.get("last_city") or "pallet-town"
                    state["area_id"] = fallback_city
                    await _save_adventure_state(str(itx.user.id), state)
                    await _heal_party(str(itx.user.id))
                    try:
                        await _send_adventure_panel(
                            itx,
                            state,
                            edit_original=False,
                            force_new_message=True,
                        )
                    except Exception:
                        pass
        # After any adventure/rival battle, send the adventure panel so the user always returns to the map
        if resend_adventure_panel and (fmt_label == "Adventure" or fmt_label == "Rival"):
            try:
                state = await _get_adventure_state(str(itx.user.id))
                await _send_adventure_panel(
                    itx,
                    state,
                    edit_original=False,
                    force_new_message=True,
                )
            except Exception:
                pass

    return st.winner == st.p1_id

async def _run_rival_battle(itx: discord.Interaction, area_id: str, state: dict) -> bool:
    rival_id = ADVENTURE_CITIES.get(area_id, {}).get("rival_battle") or ADVENTURE_ROUTES.get(area_id, {}).get("rival_battle")
    if not rival_id or rival_id not in RIVAL_BATTLES:
        return None
    if rival_id in state.get("rival_defeated", []):
        return False
    rival_def = RIVAL_BATTLES[rival_id]
    rival_name = rival_def.get("name", "Rival")
    team = []
    # When teams_by_starter is defined, rival always uses starter-dependent team
    team_entries = None
    if rival_def.get("teams_by_starter"):
        user = await db.get_user(str(itx.user.id))
        starter = (user.get("starter") if isinstance(user, dict) else user["starter"]) if user else ""
        starter_key = (starter or "").strip().lower().replace(" ", "-")
        teams_by = rival_def["teams_by_starter"]
        team_entries = teams_by.get(starter_key) or teams_by.get("pikachu") or teams_by.get("charmander") or teams_by.get("squirtle") or teams_by.get("bulbasaur") or (list(teams_by.values())[0] if teams_by else None)
    if not team_entries:
        team_entries = rival_def.get("team")
    if team_entries:
        for m in team_entries:
            mon = await _build_mon_from_team_entry(m)
            if mon:
                team.append(mon)
    if not team:
        user = await db.get_user(str(itx.user.id))
        starter = (user.get("starter") if isinstance(user, dict) else user["starter"]) if user else ""
        rival_starter = _pick_rival_starter(starter)
        rival_mon = await _build_mon_from_species(rival_starter, rival_def.get("level", 5))
        if rival_mon:
            team = [rival_mon]
    if not team:
        await itx.followup.send("Rival team failed to load.", ephemeral=False)
        return False

    route_def = ADVENTURE_ROUTES.get(area_id, {}) if area_id in ADVENTURE_ROUTES else {}
    route_display_name = route_def.get("name", area_id.replace("-", " ").title()) if route_def else "Route"
    won = await _start_pve_battle(
        itx, team, rival_name,
        fmt_label="Rival",
        area_id=area_id,
        route_display_name=route_display_name,
        resend_adventure_panel=False,
    )
    if won is None:
        return False
    state.setdefault("rival_defeated", []).append(rival_id)
    if _is_city(area_id) and area_id not in state.get("cleared_cities", []):
        state.setdefault("cleared_cities", []).append(area_id)
    elif area_id in ADVENTURE_ROUTES and area_id != "route-22" and area_id not in state.get("cleared_routes", []):
        # route-22 is only "cleared" when the path-1 trainer is defeated, not when rival is defeated
        state.setdefault("cleared_routes", []).append(area_id)
    await _save_adventure_state(str(itx.user.id), state)

    if won:
        lines = [
            "**Blue:** WHAT? Unbelievable! I picked the wrong Pok√©mon!",
            f"**Blue:** Okay! I'll make my Pok√©mon fight to toughen it up! {itx.user.display_name if hasattr(itx.user, 'display_name') else itx.user.name}! Gramps! Smell you later!",
        ]
        title = "Rival Defeated!"
        result_emb = _adventure_help_embed(title, "\n".join(lines))
        await itx.followup.send(embed=result_emb, ephemeral=False)
    else:
        # Only show "Rival Wins!" / Blue taunt for the first ever rival battle (rival-1)
        if rival_id == "rival-1":
            lines = ["**Blue:** Yeah! Am I great or what?"]
            title = "Rival Wins!"
            result_emb = _adventure_help_embed(title, "\n".join(lines))
            await itx.followup.send(embed=result_emb, ephemeral=False)
    await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
    return won


def _itx_select_values(itx: discord.Interaction) -> list[str]:
    """Return selected values from component interactions across discord.py/forks."""
    values: Any = None
    data = getattr(itx, "data", None)
    if isinstance(data, dict):
        values = data.get("values")
    if values is None:
        try:
            values = getattr(data, "values", None)
            # dict.values method guard
            if callable(values):
                values = None
        except Exception:
            values = None
    if values is None:
        try:
            values = getattr(itx, "values", None)
        except Exception:
            values = None
    if not isinstance(values, (list, tuple)):
        return []
    out: list[str] = []
    for v in values:
        s = str(v).strip()
        if s:
            out.append(s)
    return out


class TMSellerView(discord.ui.View):
    """TM Seller (Surf easter egg): sell Gen 1 TMs for coins. TMs are consumable."""
    def __init__(self, author_id: int, user_id: str):
        super().__init__(timeout=120)
        self.author_id = author_id
        self.user_id = user_id
        self._handled = False
        options = []
        for item_id, move_name in TM_SELLER_ITEMS:
            num = item_id.replace("tm-", "").zfill(2)
            options.append(discord.SelectOption(label=f"TM{num} {move_name}", value=item_id, description=f"{TM_SELLER_PRICE} coins"))
        sel = discord.ui.Select(placeholder="Choose a TM to buy (single-use)", options=options, custom_id="tmseller:buy")
        sel.callback = self._on_select
        self.add_item(sel)

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    async def _on_select(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if self._handled:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        values = _itx_select_values(itx)
        if not values:
            return await itx.response.send_message("Pick a TM.", ephemeral=True)
        item_id = values[0]
        entry = next((e for e in TM_SELLER_ITEMS if e[0] == item_id), None)
        if not entry:
            return await itx.response.send_message("Invalid TM.", ephemeral=True)
        await itx.response.defer(ephemeral=True, thinking=False)
        coins = await db.get_currency(self.user_id, "coins")
        if coins < TM_SELLER_PRICE:
            await itx.followup.send(f"Not enough coins. You need **{TM_SELLER_PRICE}** coins; you have **{coins}**.", ephemeral=False)
            return
        await db.add_currency(self.user_id, "coins", -TM_SELLER_PRICE)
        await db.upsert_item_master(item_id, name=f"TM{item_id.replace('tm-', '').zfill(2)} {entry[1]}")
        await db.give_item(self.user_id, item_id, 1)
        self._handled = True
        await itx.followup.send(
            f"You bought **TM{item_id.replace('tm-', '').zfill(2)} {entry[1]}**! It was added to your TM Machine.\n\n"
            "*\"Your Pok√©mon is now as strong as ever! Sadly I lost a few TMs during my journey. Hopefully you can find them in the wild!\"* ‚Äî TM Seller",
            ephemeral=True,
        )


def _market_mode_rows(mode: str) -> list[tuple[str, str, int, str]]:
    want_buy = str(mode).lower() == "buy"
    out: list[tuple[str, str, int, str]] = []
    for category, rows in MARKET_PRICE_CATALOG.items():
        if want_buy and category == "Treasure Items":
            continue
        for item_id, disp, price in rows:
            out.append((str(item_id), str(disp), int(price), str(category)))
    return out


async def _market_sell_rows_for_owner(owner_id: str) -> tuple[list[tuple[str, str, int, str]], dict[str, int]]:
    qty_by_item: dict[str, int] = {}
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT item_id, qty FROM user_items WHERE owner_id=? AND qty>0",
                (str(owner_id),),
            )
            rows = await cur.fetchall()
            await cur.close()
        for row in rows or []:
            item_id = str(row["item_id"] if hasattr(row, "keys") else row[0])
            qty = int((row.get("qty") if hasattr(row, "keys") else row[1]) or 0)
            if qty <= 0:
                continue
            canonical = _market_normalize_key(item_id)
            if canonical not in MARKET_SELL_PRICES:
                continue
            qty_by_item[canonical] = int(qty_by_item.get(canonical, 0)) + int(qty)
    except Exception:
        return [], {}

    out: list[tuple[str, str, int, str]] = []
    for item_id, disp, price, category in _market_mode_rows("sell"):
        if int(qty_by_item.get(item_id, 0)) > 0:
            out.append((item_id, disp, price, category))
    return out, qty_by_item


class MarketQuantityModal(discord.ui.Modal):
    def __init__(self, author_id: int, area_id: str, mode: str, item_key: str):
        mode_name = "Buy" if str(mode).lower() == "buy" else "Sell"
        display = _market_display(item_key)
        super().__init__(title=f"Pok√© Mart ‚Ä¢ {mode_name} {display}")
        self.author_id = int(author_id)
        self.area_id = str(area_id)
        self.mode = "buy" if str(mode).lower() == "buy" else "sell"
        self.item_key = _market_normalize_key(item_key)
        self.qty_input = discord.ui.TextInput(
            label="Quantity",
            placeholder="1",
            max_length=7,
            required=True,
            default="1",
        )
        self.add_item(self.qty_input)

    async def on_submit(self, itx: discord.Interaction):
        deferred = False

        async def _reply(msg: str) -> None:
            try:
                if deferred or itx.response.is_done():
                    await itx.followup.send(msg, ephemeral=True)
                else:
                    await itx.response.send_message(msg, ephemeral=True)
            except Exception:
                pass

        if int(itx.user.id) != self.author_id:
            return await _reply("This isn't for you.")
        try:
            await itx.response.defer(ephemeral=True, thinking=True)
            deferred = True
        except Exception:
            deferred = False
        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        if str(state.get("area_id") or "") != self.area_id or not _is_pokemart(self.area_id):
            return await _reply("Market access is only available while you're inside a Pok√© Mart.")
        try:
            qty = int(str(self.qty_input.value or "").strip())
        except Exception:
            return await _reply("Quantity must be a valid integer.")
        if qty <= 0:
            return await _reply("Quantity must be positive.")
        if qty > MAX_STACK:
            return await _reply(f"Quantity too large (max {MAX_STACK}).")
        try:
            if self.mode == "buy":
                ok, msg = await _market_buy(uid, self.item_key, qty)
            else:
                ok, msg = await _market_sell(uid, self.item_key, qty)
            _ = ok
            return await _reply(str(msg))
        except Exception as e:
            print(f"[market] quantity modal trade failed: mode={self.mode} item={self.item_key} qty={qty} err={e}")
            import traceback
            traceback.print_exc()
            return await _reply(f"‚ùå Market trade failed: {e}")


class MarketDropdownSearchModal(discord.ui.Modal):
    def __init__(self, parent_view: "MarketDropdownView"):
        mode_name = "Buy" if parent_view.mode == "buy" else "Sell"
        super().__init__(title=f"Pok√© Mart ‚Ä¢ {mode_name} Search")
        self.parent_view = parent_view
        self.query_input = discord.ui.TextInput(
            label="Search items",
            placeholder="Name or item id (e.g. ultra, potion, nugget)",
            required=False,
            max_length=64,
            default=str(parent_view.search_query or ""),
        )
        self.add_item(self.query_input)

    async def on_submit(self, itx: discord.Interaction):
        if not self.parent_view._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        self.parent_view.search_query = str(self.query_input.value or "").strip()
        self.parent_view.page = 0
        await self.parent_view._refresh_message(itx)


class MarketDropdownView(discord.ui.View):
    ITEMS_PER_PAGE = 25

    def __init__(self, author_id: int, area_id: str, mode: str):
        super().__init__(timeout=180)
        self.author_id = int(author_id)
        self.area_id = str(area_id)
        self.mode = "buy" if str(mode).lower() == "buy" else "sell"
        self.search_query: str = ""
        self.page: int = 0
        self._owned_qty: dict[str, int] = {}
        self._rows_cache: list[tuple[str, str, int, str]] = (
            _market_mode_rows(self.mode) if self.mode == "buy" else []
        )
        self._rebuild_items()

    def _guard(self, itx: discord.Interaction) -> bool:
        return int(itx.user.id) == self.author_id

    def _all_rows(self) -> list[tuple[str, str, int, str]]:
        return list(self._rows_cache)

    async def _refresh_rows(self, uid: str) -> None:
        if self.mode == "sell":
            rows, qty_map = await _market_sell_rows_for_owner(uid)
            self._rows_cache = rows
            self._owned_qty = qty_map
        else:
            self._rows_cache = _market_mode_rows("buy")
            self._owned_qty = {}

    def _filtered_rows(self) -> list[tuple[str, str, int, str]]:
        rows = self._all_rows()
        q = item_id_from_user(self.search_query)
        if not q:
            return rows
        out: list[tuple[str, str, int, str]] = []
        for item_id, disp, price, category in rows:
            if (
                q in item_id_from_user(item_id)
                or q in item_id_from_user(disp)
                or q in item_id_from_user(category)
            ):
                out.append((item_id, disp, price, category))
        return out

    def _paged_rows(self) -> tuple[list[tuple[str, str, int, str]], int, int]:
        rows = self._filtered_rows()
        total = len(rows)
        pages = max(1, math.ceil(total / self.ITEMS_PER_PAGE))
        self.page = max(0, min(int(self.page), pages - 1))
        start = self.page * self.ITEMS_PER_PAGE
        end = start + self.ITEMS_PER_PAGE
        return rows[start:end], total, pages

    async def _build_embed(self, uid: str, *, refresh_rows: bool = True) -> discord.Embed:
        if refresh_rows:
            await self._refresh_rows(uid)
            self._rebuild_items()
        mode_name = "Buy" if self.mode == "buy" else "Sell"
        page_rows, total, pages = self._paged_rows()
        desc = "Choose an item from the dropdown, then enter quantity."
        if self.mode == "buy":
            desc += "\nTreasure items are sell-only and do not appear here."
        else:
            desc += "\nOnly items currently in your bag are shown."
        if self.search_query:
            desc += f"\nSearch: **{self.search_query}**"
        emb = discord.Embed(
            title=f"Pok√© Mart ‚Ä¢ {mode_name} Menu",
            description=desc,
            color=0x4CAF50 if self.mode == "buy" else 0x2196F3,
        )
        if page_rows:
            lines = []
            for _item_id, disp, price, category in page_rows[:12]:
                if self.mode == "buy":
                    lines.append(f"‚Ä¢ **{disp}** ‚Äî {price:,} ({category})")
                else:
                    owned_q = int(self._owned_qty.get(_item_id, 0))
                    lines.append(f"‚Ä¢ **{disp}** √ó{owned_q:,} ‚Äî Sell for {price:,} ({category})")
            emb.add_field(name="Items (current page preview)", value="\n".join(lines)[:1024], inline=False)
        else:
            if self.mode == "sell":
                emb.add_field(name="Items", value="No sellable market items found in your bag.", inline=False)
            else:
                emb.add_field(name="Items", value="No items matched your search.", inline=False)
        coins = await db.get_currency(uid, "coins")
        emb.set_footer(text=f"Results: {total} ‚Ä¢ Page {self.page + 1}/{pages} ‚Ä¢ Balance: {coins:,} {PKDollar_NAME}")
        return emb

    def _rebuild_items(self) -> None:
        self.clear_items()
        page_rows, total, pages = self._paged_rows()
        options: list[discord.SelectOption] = []
        for item_id, disp, price, category in page_rows:
            if self.mode == "buy":
                desc = f"{category} ‚Ä¢ Buy {price:,}"
            else:
                owned_q = int(self._owned_qty.get(item_id, 0))
                desc = f"{category} ‚Ä¢ Own {owned_q:,} ‚Ä¢ Sell {price:,}"
            options.append(discord.SelectOption(label=disp[:100], value=item_id, description=desc[:100]))
        if not options:
            no_items_desc = "Try a different search." if self.mode == "buy" else "Catch/find items first, then sell."
            options = [discord.SelectOption(label="No matching items", value="__none__", description=no_items_desc[:100])]
        sel = discord.ui.Select(
            placeholder=("Select an item to buy‚Ä¶" if self.mode == "buy" else "Select an item to sell‚Ä¶"),
            min_values=1,
            max_values=1,
            options=options,
            disabled=(total <= 0),
            custom_id=f"mart:dropdown:{self.mode}",
        )
        sel.callback = self._on_pick_item
        self.add_item(sel)

        prev_btn = discord.ui.Button(
            label="Prev",
            style=discord.ButtonStyle.secondary,
            disabled=(self.page <= 0),
            custom_id=f"mart:page_prev:{self.mode}",
        )
        prev_btn.callback = self._on_prev
        self.add_item(prev_btn)

        next_btn = discord.ui.Button(
            label="Next",
            style=discord.ButtonStyle.secondary,
            disabled=(self.page >= (pages - 1)),
            custom_id=f"mart:page_next:{self.mode}",
        )
        next_btn.callback = self._on_next
        self.add_item(next_btn)

        search_btn = discord.ui.Button(
            label="Search",
            style=discord.ButtonStyle.primary,
            custom_id=f"mart:search:{self.mode}",
        )
        search_btn.callback = self._on_search
        self.add_item(search_btn)

        clear_btn = discord.ui.Button(
            label="Clear Search",
            style=discord.ButtonStyle.secondary,
            disabled=(not bool(self.search_query)),
            custom_id=f"mart:search_clear:{self.mode}",
        )
        clear_btn.callback = self._on_clear_search
        self.add_item(clear_btn)

    async def _refresh_message(self, itx: discord.Interaction) -> None:
        if not _is_pokemart(self.area_id):
            if itx.response.is_done():
                return await itx.followup.send("Market access is only available in a Pok√© Mart.", ephemeral=True)
            return await itx.response.send_message("Market access is only available in a Pok√© Mart.", ephemeral=True)
        uid = str(itx.user.id)
        await self._refresh_rows(uid)
        self._rebuild_items()
        emb = await self._build_embed(uid, refresh_rows=False)
        try:
            await itx.response.edit_message(embed=emb, view=self)
        except Exception:
            try:
                if not itx.response.is_done():
                    await itx.response.send_message(embed=emb, view=self, ephemeral=True)
                else:
                    await itx.followup.send(embed=emb, view=self, ephemeral=True)
            except Exception:
                pass

    async def _on_pick_item(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not _is_pokemart(self.area_id):
            return await itx.response.send_message("Market access is only available in a Pok√© Mart.", ephemeral=True)
        values = _itx_select_values(itx)
        item_key = str(values[0] if values else "").strip()
        if not item_key or item_key == "__none__":
            return await itx.response.send_message("No item selected.", ephemeral=True)
        await itx.response.send_modal(MarketQuantityModal(self.author_id, self.area_id, self.mode, item_key))

    async def _on_prev(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        self.page = max(0, int(self.page) - 1)
        await self._refresh_message(itx)

    async def _on_next(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        self.page = int(self.page) + 1
        await self._refresh_message(itx)

    async def _on_search(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        await itx.response.send_modal(MarketDropdownSearchModal(self))

    async def _on_clear_search(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        self.search_query = ""
        self.page = 0
        await self._refresh_message(itx)


class AdventurePokeMartView(discord.ui.View):
    def __init__(self, author_id: int, area_id: str, state: dict):
        super().__init__(timeout=180)
        self.author_id = int(author_id)
        self.area_id = str(area_id)
        self.state = state
        self._handled = False
        self._last_handled_id: str | None = None
        self._last_handled_ts: float = 0.0
        self._build_buttons()

    def _guard(self, itx: discord.Interaction) -> bool:
        return int(itx.user.id) == self.author_id

    def _build_buttons(self):
        buy_btn = discord.ui.Button(label="Buy Menu", style=discord.ButtonStyle.success, custom_id="mart:buy")
        buy_btn.callback = self._on_buy
        self.add_item(buy_btn)

        sell_btn = discord.ui.Button(label="Sell Menu", style=discord.ButtonStyle.primary, custom_id="mart:sell")
        sell_btn.callback = self._on_sell
        self.add_item(sell_btn)

        list_btn = discord.ui.Button(label="Price List", style=discord.ButtonStyle.secondary, custom_id="mart:list")
        list_btn.callback = self._on_price_list
        self.add_item(list_btn)

        if self.state.get("area_history"):
            back_btn = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="mart:back")
            back_btn.callback = self._on_back
            self.add_item(back_btn)

    async def _on_buy(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not _is_pokemart(self.area_id):
            return await itx.response.send_message("Market access is only available in a Pok√© Mart.", ephemeral=True)
        view = MarketDropdownView(self.author_id, self.area_id, "buy")
        emb = await view._build_embed(str(itx.user.id))
        await itx.response.send_message(embed=emb, view=view, ephemeral=True)

    async def _on_sell(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not _is_pokemart(self.area_id):
            return await itx.response.send_message("Market access is only available in a Pok√© Mart.", ephemeral=True)
        view = MarketDropdownView(self.author_id, self.area_id, "sell")
        emb = await view._build_embed(str(itx.user.id))
        await itx.response.send_message(embed=emb, view=view, ephemeral=True)

    async def _on_price_list(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not _is_pokemart(self.area_id):
            return await itx.response.send_message("Market access is only available in a Pok√© Mart.", ephemeral=True)
        uid = str(itx.user.id)
        coins = await db.get_currency(uid, "coins")
        emb = _market_price_embed()
        emb.set_footer(text=f"Your balance: {coins:,} {PKDollar_NAME}")
        await itx.response.send_message(embed=emb, ephemeral=True)

    async def _on_back(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.0:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            if not isinstance(state.get("area_history"), list) or not state.get("area_history"):
                return await itx.followup.send("No previous area.", ephemeral=False)
            state["area_id"] = _adv_history_pop(state, "pallet-town")
            await _save_adventure_state(str(itx.user.id), state)
            await _send_adventure_panel(itx, state, edit_original=True)
        finally:
            self._handled = False


class AdventureCityView(discord.ui.View):
    def __init__(self, author_id: int, area_id: str, state: dict, *, has_surf: bool = False):
        super().__init__(timeout=180)
        self.author_id = author_id
        self.area_id = area_id
        self.state = state
        self.has_surf = has_surf
        self._handled = False
        self._last_handled_id: str | None = None
        self._last_handled_ts: float = 0.0
        self._build_buttons()

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    def _build_buttons(self):
        city = ADVENTURE_CITIES.get(self.area_id, {})
        if city.get("heal"):
            heal_btn = discord.ui.Button(label="Heal", style=discord.ButtonStyle.success, custom_id="adv:heal")
            heal_btn.callback = self._on_heal
            self.add_item(heal_btn)
        daycare_area = city.get("daycare_area")
        if daycare_area:
            daycare_btn = discord.ui.Button(
                label=city.get("daycare_label", "Daycare"),
                style=discord.ButtonStyle.secondary,
                custom_id=f"adv:daycare:{daycare_area}",
            )
            daycare_btn.callback = self._on_daycare
            self.add_item(daycare_btn)
        sub_areas = city.get("sub_areas")
        if sub_areas and isinstance(sub_areas, (list, tuple)):
            for sub_id, sub_label in sub_areas:
                sub_btn = discord.ui.Button(
                    label=sub_label,
                    style=discord.ButtonStyle.secondary,
                    custom_id=f"adv:area:{sub_id}",
                )
                sub_btn.callback = self._on_sub_area
                self.add_item(sub_btn)
        cleared = _city_is_cleared(self.state, self.area_id)
        routes = city.get("routes")
        if routes and isinstance(routes, (list, tuple)):
            for route_id in routes:
                if route_id == "route-22" and not ROUTE_22_ENABLED:
                    continue
                route_def = ADVENTURE_ROUTES.get(route_id, {})
                label = route_def.get("name", route_id.replace("-", " ").title())
                next_btn = discord.ui.Button(label=label, style=discord.ButtonStyle.primary, custom_id=f"adv:next:{route_id}")
                next_btn.callback = self._on_next
                self.add_item(next_btn)
        else:
            next_id = city.get("next")
            if next_id and cleared:
                next_btn = discord.ui.Button(label="Next", style=discord.ButtonStyle.primary, custom_id=f"adv:next:{next_id}")
                next_btn.callback = self._on_next
                self.add_item(next_btn)
        if city.get("gym_leader") and not city.get("gym_closed"):
            gym_btn = discord.ui.Button(label="Gym Challenge", style=discord.ButtonStyle.danger, custom_id=f"adv:gym:{self.area_id}")
            gym_btn.callback = self._on_gym
            self.add_item(gym_btn)
        rival_id = city.get("rival_battle")
        if rival_id and rival_id not in self.state.get("rival_defeated", []):
            rival_btn = discord.ui.Button(label="Rival Battle", style=discord.ButtonStyle.danger, custom_id=f"adv:rival:{rival_id}")
            rival_btn.callback = self._on_rival
            self.add_item(rival_btn)
        if self.has_surf:
            surf_btn = discord.ui.Button(label="Surf", style=discord.ButtonStyle.secondary, custom_id="adv:surf")
            surf_btn.callback = self._on_surf
            self.add_item(surf_btn)
        if self.state.get("area_history"):
            back_btn = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="adv:back")
            back_btn.callback = self._on_back
            self.add_item(back_btn)

    async def _on_heal(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)
        healed = await _heal_party(str(itx.user.id))
        await itx.followup.send(f"‚úÖ Healed your team ({healed} Pok√©mon).", ephemeral=True)

    async def _on_daycare(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        _, next_id = itx.data["custom_id"].split("adv:daycare:", 1)
        _adv_history_push(state, state.get("area_id"))
        state["area_id"] = next_id
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=True)

    async def _on_sub_area(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        _, next_id = itx.data["custom_id"].split("adv:area:", 1)
        _adv_history_push(state, state.get("area_id"))
        state["area_id"] = next_id
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=True)

    async def _on_next(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        _, next_id = itx.data["custom_id"].split("adv:next:", 1)
        _adv_history_push(state, state.get("area_id"))
        # Reset panel route navigation when entering so it always starts at Panel 1.
        if next_id in _get_panel_routes():
            rp = state.get("route_panels") or {}
            rp[next_id] = {"panel": 1, "pos": "start"}
            state["route_panels"] = rp
        state["area_id"] = next_id
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=True)

    async def _on_rival(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if self._handled:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        await itx.response.defer(ephemeral=True, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        await _run_rival_battle(itx, self.area_id, state)

    async def _on_gym(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        city = ADVENTURE_CITIES.get(self.area_id, {})
        gym_team = city.get("gym_team")
        if not gym_team or not isinstance(gym_team, (list, tuple)):
            return await itx.response.send_message("The gym is closed.", ephemeral=True)
        if self._handled:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        await itx.response.defer(ephemeral=True, thinking=False)
        team = []
        for m in gym_team:
            mon = await _build_mon_from_team_entry(m)
            if mon:
                team.append(mon)
        if not team:
            return await itx.followup.send("Gym leader team failed to load.", ephemeral=False)
        gym_name = city.get("gym_leader", "Gym Leader").replace("-", " ").title()
        won = await _start_pve_battle(itx, team, gym_name)
        if won is None:
            return await itx.followup.send("Couldn't start the battle.", ephemeral=False)
        if won:
            state = await _get_adventure_state(str(itx.user.id))
            badge = city.get("gym_badge")
            if badge:
                badges = state.get("gym_badges") or []
                if badge not in badges:
                    badges = list(badges) + [badge]
                    state["gym_badges"] = badges
            if self.area_id not in (state.get("cleared_cities") or []):
                state.setdefault("cleared_cities", []).append(self.area_id)
            await _save_adventure_state(str(itx.user.id), state)
            await itx.followup.send(f"‚úÖ You won the {gym_name} Gym and earned the badge!", ephemeral=False)
        else:
            await itx.followup.send("You lost. Try again when you're stronger!", ephemeral=False)

    async def _on_surf(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if self._handled:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        await itx.response.defer(ephemeral=True, thinking=False)
        uid = str(itx.user.id)
        emb = discord.Embed(
            title="TM Seller of Kanto",
            description=(
                "Hello young trainer! I am the TM Seller of Kanto. "
                "Some techniques were entrusted to me by a certain yellow legend. "
                "I sell Technical Machines ‚Äî each TM is **single-use** (consumable). "
                f"Each costs **{TM_SELLER_PRICE}** coins. Would you like to buy one?\n\n"
                "Choose a TM below to purchase. You can check your TMs anytime with `/tm machine`."
            ),
            color=0x5865F2,
        )
        view = TMSellerView(itx.user.id, uid)
        await itx.followup.send(embed=emb, view=view, ephemeral=False)
        self._handled = True

    async def _on_back(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.0:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            if not isinstance(state.get("area_history"), list) or not state.get("area_history"):
                return await itx.followup.send("No previous area.", ephemeral=False)
            state["area_id"] = _adv_history_pop(state, "pallet-town")
            await _save_adventure_state(str(itx.user.id), state)
            await _send_adventure_panel(itx, state, edit_original=True)
        finally:
            self._handled = False


async def _daycare_candidate_mons(owner_id: str, *, exclude_ids: set[int], limit: int = 250) -> list[dict]:
    rows: list[dict] = []
    try:
        async with db.session() as conn:
            cur = await conn.execute(
                "SELECT id, species, level, team_slot, shiny FROM pokemons WHERE owner_id=? ORDER BY CASE WHEN team_slot BETWEEN 1 AND 6 THEN 0 ELSE 1 END, team_slot, id DESC LIMIT ?",
                (owner_id, int(limit)),
            )
            fetched = await cur.fetchall()
            await cur.close()
        for row in fetched:
            d = dict(row) if hasattr(row, "keys") else {
                "id": row[0], "species": row[1], "level": row[2], "team_slot": row[3], "shiny": row[4],
            }
            mid = int(d.get("id") or 0)
            if mid <= 0 or mid in exclude_ids:
                continue
            if _daycare_norm_species(d.get("species")) == "egg":
                continue
            rows.append(d)
    except Exception:
        return []
    return rows


class DaycareParentSelectView(discord.ui.View):
    def __init__(self, author_id: int, area_id: str, slot_index: int, candidates: list[dict]):
        super().__init__(timeout=180)
        self.author_id = author_id
        self.area_id = area_id
        self.slot_index = int(slot_index)
        self.candidates = candidates[:25]
        self._build()

    def _build(self):
        options: list[discord.SelectOption] = []
        for row in self.candidates:
            species = str(row.get("species") or "Unknown").replace("-", " ").title()
            level = int(row.get("level") or 1)
            team_slot = row.get("team_slot")
            loc = f"Team {team_slot}" if team_slot and 1 <= int(team_slot) <= 6 else "PC"
            shiny = "‚ú® " if row.get("shiny") else ""
            options.append(
                discord.SelectOption(
                    label=f"{shiny}{species} Lv{level}",
                    value=str(int(row.get("id"))),
                    description=loc,
                )
            )
        if options:
            sel = discord.ui.Select(
                placeholder=f"Choose parent slot #{self.slot_index + 1}",
                options=options,
                custom_id=f"adv:dc:pick:{self.slot_index}",
            )
            sel.callback = self._on_pick
            self.add_item(sel)

        cancel_btn = discord.ui.Button(label="Cancel", style=discord.ButtonStyle.secondary, custom_id="adv:dc:pick:cancel")
        cancel_btn.callback = self._on_cancel
        self.add_item(cancel_btn)

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    async def _on_pick(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        values = _itx_select_values(itx)
        if not values:
            return await itx.response.send_message("Choose a Pok√©mon first.", ephemeral=True)
        try:
            selected_id = int(values[0])
        except Exception:
            return await itx.response.send_message("Invalid selection.", ephemeral=True)
        await itx.response.defer(ephemeral=True, thinking=False)
        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        rec = _daycare_get_record(state, DAYCARE_CITY_ID)
        parents = list((rec.get("parents") or [None, None])[:2])
        while len(parents) < 2:
            parents.append(None)
        other = 1 - self.slot_index
        if parents[other] is not None and int(parents[other]) == selected_id:
            await itx.followup.send("That Pok√©mon is already in the other daycare slot.", ephemeral=True)
            return
        # Validate selection and, when chosen from team, remove it from team slots.
        selected_team_slot: Optional[int] = None
        try:
            async with db.session() as conn:
                cur = await conn.execute(
                    "SELECT team_slot FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                    (uid, int(selected_id)),
                )
                row = await cur.fetchone()
                await cur.close()
            if not row:
                await itx.followup.send("That Pok√©mon no longer exists.", ephemeral=True)
                return
            raw_slot = row["team_slot"] if hasattr(row, "keys") else row[0]
            if raw_slot is not None:
                try:
                    slot_i = int(raw_slot)
                    if 1 <= slot_i <= 6:
                        selected_team_slot = slot_i
                except Exception:
                    selected_team_slot = None
        except Exception:
            await itx.followup.send("Couldn't validate the selected Pok√©mon.", ephemeral=True)
            return

        if selected_team_slot is not None:
            # Never allow daycare deposit to leave player with no team mons.
            team_count = await _daycare_team_count(uid)
            if team_count <= 1:
                await itx.followup.send(
                    "You must keep at least **1 non-egg Pok√©mon** in your team.",
                    ephemeral=True,
                )
                return
        try:
            # Daycare parents should not remain in team slots or box slots.
            async with db.session() as conn:
                await conn.execute(
                    "UPDATE pokemons SET team_slot=NULL, box_no=NULL, box_pos=NULL WHERE owner_id=? AND id=?",
                    (uid, int(selected_id)),
                )
                await conn.commit()
            db.invalidate_pokemons_cache(uid)
            if selected_team_slot is not None:
                await _compact_team_slots(uid)
        except Exception:
            await itx.followup.send("Couldn't move that Pok√©mon into daycare right now.", ephemeral=True)
            return

        parents[self.slot_index] = selected_id
        rec["parents"] = parents
        rec["breed_progress"] = 0.0
        await _save_adventure_state(uid, state)
        await _send_adventure_panel(itx, state, edit_original=True)

    async def _on_cancel(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        await itx.response.defer(ephemeral=True, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        await _send_adventure_panel(itx, state, edit_original=True)


class AdventureDaycareView(discord.ui.View):
    def __init__(self, author_id: int, area_id: str, state: dict, rec: dict, parent_rows: list[Optional[dict]], pair_info: dict):
        super().__init__(timeout=180)
        self.author_id = author_id
        self.area_id = area_id
        self.state = state
        self.rec = rec
        self.parent_rows = parent_rows
        self.pair_info = pair_info
        self._handled = False
        self._last_handled_id: str | None = None
        self._last_handled_ts: float = 0.0
        self._build_buttons()

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    def _build_buttons(self):
        daycare_cfg = ADVENTURE_CITIES.get(self.area_id, {})
        if daycare_cfg.get("heal"):
            heal_btn = discord.ui.Button(label="Heal", style=discord.ButtonStyle.success, custom_id="adv:dc:heal")
            heal_btn.callback = self._on_heal
            self.add_item(heal_btn)

        p0 = self.parent_rows[0] if len(self.parent_rows) > 0 else None
        p1 = self.parent_rows[1] if len(self.parent_rows) > 1 else None

        if p0:
            b0 = discord.ui.Button(label="Swap Out Parent #1", style=discord.ButtonStyle.danger, custom_id="adv:dc:out:0")
            b0.callback = self._on_swap_out
        else:
            b0 = discord.ui.Button(label="Swap In Parent #1", style=discord.ButtonStyle.primary, custom_id="adv:dc:in:0")
            b0.callback = self._on_swap_in
        self.add_item(b0)

        if p1:
            b1 = discord.ui.Button(label="Swap Out Parent #2", style=discord.ButtonStyle.danger, custom_id="adv:dc:out:1")
            b1.callback = self._on_swap_out
        else:
            b1 = discord.ui.Button(label="Swap In Parent #2", style=discord.ButtonStyle.primary, custom_id="adv:dc:in:1")
            b1.callback = self._on_swap_in
        self.add_item(b1)

        take_btn = discord.ui.Button(
            label=f"Take Eggs ({len(self.rec.get('eggs') or [])})",
            style=discord.ButtonStyle.success,
            custom_id="adv:dc:take",
        )
        take_btn.callback = self._on_take_eggs
        self.add_item(take_btn)

        back_btn = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="adv:dc:back")
        back_btn.callback = self._on_back
        self.add_item(back_btn)

    async def _on_heal(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)
        healed = await _heal_party(str(itx.user.id))
        await itx.followup.send(f"‚úÖ Healed your team ({healed} Pok√©mon).", ephemeral=True)

    async def _on_swap_in(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id", "")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now

        try:
            slot_index = int(cid.rsplit(":", 1)[-1])
        except Exception:
            return await itx.response.send_message("Invalid daycare slot.", ephemeral=True)

        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        rec = _daycare_get_record(state, DAYCARE_CITY_ID)
        parents = list((rec.get("parents") or [None, None])[:2])
        while len(parents) < 2:
            parents.append(None)
        other_id = parents[1 - slot_index]
        exclude = {int(other_id)} if other_id is not None and str(other_id).isdigit() else set()
        candidates = await _daycare_candidate_mons(uid, exclude_ids=exclude)
        if not candidates:
            self._handled = False
            return await itx.response.send_message("You have no available Pok√©mon to place in daycare.", ephemeral=True)

        emb = discord.Embed(
            title="Daycare ‚Äî Choose Parent",
            description=f"Select a Pok√©mon for parent slot **#{slot_index + 1}**.\nShowing up to 25 options.",
            color=0x5865F2,
        )
        view = DaycareParentSelectView(self.author_id, self.area_id, slot_index, candidates)
        await itx.response.edit_message(embed=emb, view=view, attachments=[])

    async def _on_swap_out(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id", "")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            slot_index = int(cid.rsplit(":", 1)[-1])
        except Exception:
            return await itx.response.send_message("Invalid daycare slot.", ephemeral=True)

        await itx.response.defer(ephemeral=True, thinking=False)
        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        rec = _daycare_get_record(state, DAYCARE_CITY_ID)
        parents = list((rec.get("parents") or [None, None])[:2])
        while len(parents) < 2:
            parents.append(None)
        removed = parents[slot_index]
        parents[slot_index] = None
        rec["parents"] = parents
        rec["breed_progress"] = 0.0
        placed_slot: Optional[int] = None
        kept_in_pc = False
        kept_due_duplicate = False
        if removed is not None and str(removed).isdigit():
            removed_id = int(removed)
            try:
                async with db.session() as conn:
                    cur = await conn.execute(
                        "SELECT team_slot, species FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                        (uid, removed_id),
                    )
                    row = await cur.fetchone()
                    await cur.close()
                if row:
                    raw_slot = row["team_slot"] if hasattr(row, "keys") else row[0]
                    raw_species = row["species"] if hasattr(row, "keys") else row[1]
                    cur_slot: Optional[int] = None
                    if raw_slot is not None:
                        try:
                            v = int(raw_slot)
                            if 1 <= v <= 6:
                                cur_slot = v
                        except Exception:
                            cur_slot = None
                    duplicate_team_species = await _team_has_species(uid, str(raw_species or ""), exclude_mon_id=removed_id)
                    if duplicate_team_species:
                        kept_in_pc = True
                        kept_due_duplicate = True
                    elif cur_slot is not None:
                        placed_slot = cur_slot
                    else:
                        free_slot = await db.next_free_team_slot(uid)
                        if free_slot is not None:
                            await db.set_team_slot(uid, removed_id, int(free_slot))
                            placed_slot = int(free_slot)
                            db.invalidate_pokemons_cache(uid)
                        else:
                            kept_in_pc = True
            except Exception:
                kept_in_pc = True
        await _save_adventure_state(uid, state)
        if removed is None:
            msg = "That daycare slot is already empty."
        elif placed_slot is not None:
            msg = f"Parent removed from daycare and returned to your team (Slot {placed_slot})."
        elif kept_due_duplicate:
            msg = "Parent removed from daycare and sent to your PC (duplicate species already on team)."
        elif kept_in_pc:
            msg = "Parent removed from daycare and sent to your PC (team is full)."
        else:
            msg = "Parent removed from daycare."
        await itx.followup.send(msg, ephemeral=True)
        await _send_adventure_panel(itx, state, edit_original=True)

    async def _on_take_eggs(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id", "")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)

        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        rec = _daycare_get_record(state, DAYCARE_CITY_ID)
        eggs = list(rec.get("eggs") or [])
        if not eggs:
            await itx.followup.send("No eggs are ready right now.", ephemeral=True)
            await _send_adventure_panel(itx, state, edit_original=True)
            return

        incubating = list(rec.get("incubating") or [])
        team_count = await _daycare_team_count(uid)
        if team_count <= 0:
            await itx.followup.send(
                "You must keep at least **1 real Pok√©mon** in your team before taking eggs.",
                ephemeral=True,
            )
            await _send_adventure_panel(itx, state, edit_original=True)
            return
        free_slots = max(0, DAYCARE_INCUBATE_MAX - team_count - len(incubating))
        if free_slots <= 0:
            await itx.followup.send(
                "Your team/incubator is full. Free a team slot before taking eggs.",
                ephemeral=True,
            )
            await _send_adventure_panel(itx, state, edit_original=True)
            return

        take_n = min(free_slots, len(eggs))
        moved = eggs[:take_n]
        remaining = eggs[take_n:]
        for egg in moved:
            if isinstance(egg, dict):
                egg["progress"] = float(egg.get("progress", 0.0) or 0.0)
                egg["hatch_steps"] = float(egg.get("hatch_steps", random.uniform(DAYCARE_HATCH_MIN, DAYCARE_HATCH_MAX)))
        incubating.extend(moved)
        rec["incubating"] = incubating[:DAYCARE_INCUBATE_MAX]
        rec["eggs"] = remaining
        await _save_adventure_state(uid, state)

        has_boost = await _daycare_has_hatch_boost(uid)
        boost_msg = " Hatch speed is currently **boosted** (Flame Body / Magma Armor)." if has_boost else ""
        await itx.followup.send(
            f"ü•ö Took **{take_n}** egg(s) into your team incubator.{boost_msg}",
            ephemeral=True,
        )
        await _send_adventure_panel(itx, state, edit_original=True)

    async def _on_back(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id", "")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.0:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        await itx.response.defer(ephemeral=True, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        if not isinstance(state.get("area_history"), list) or not state.get("area_history"):
            state["area_id"] = DAYCARE_CITY_ID
        else:
            state["area_id"] = _adv_history_pop(state, DAYCARE_CITY_ID)
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=True)

def _adventure_help_embed(title: str, description: str) -> discord.Embed:
    emb = discord.Embed(title=title, description=description)
    emb.add_field(
        name="Adventure commands",
        value="‚Ä¢ `/adventure` ‚Äî open your map and move between areas\n‚Ä¢ `/refresh` ‚Äî re-send the last panel the bot sent you (adventure or battle)\n‚Ä¢ `/route <number>` ‚Äî encounter a discovered Pok√©mon on a cleared route",
        inline=False,
    )
    return emb

class RivalIntroView(discord.ui.View):
    def __init__(self, author_id: int, area_id: str = "pallet-town"):
        super().__init__(timeout=180)
        self.author_id = author_id
        self.area_id = area_id
        self._handled = False
        self._last_handled_id: str | None = None
        self._last_handled_ts: float = 0.0
        yes_btn = discord.ui.Button(label="Ready to lose?", style=discord.ButtonStyle.success, custom_id="rival:yes")
        no_btn = discord.ui.Button(label="Another time", style=discord.ButtonStyle.secondary, custom_id="rival:no")
        yes_btn.callback = self._on_yes
        no_btn.callback = self._on_no
        self.add_item(yes_btn)
        self.add_item(no_btn)

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    async def _on_yes(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        # Defer immediately
        if not itx.response.is_done():
            try:
                await itx.response.defer(ephemeral=True, thinking=False)
            except Exception:
                pass
        try:
            state = await _get_adventure_state(str(itx.user.id))
            ok = await _run_rival_battle(itx, self.area_id, state)
            if ok is None:
                await itx.followup.send("Couldn't start the rival battle. Please try again in a moment.", ephemeral=False)
        except Exception as e:
            import traceback
            traceback.print_exc()
            try:
                await itx.followup.send(f"Rival battle failed: {type(e).__name__}: {e}", ephemeral=True)
            except Exception:
                pass
        finally:
            try:
                for item in self.children:
                    if hasattr(item, "disabled"):
                        item.disabled = True
                await itx.message.edit(view=self)
            except Exception:
                pass

    async def _on_no(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        emb = _adventure_help_embed(
            "Come back anytime",
            "When you're ready to continue the story, open your adventure panel.",
        )
        await itx.response.edit_message(embed=emb, view=None)

class AdventureRouteView(discord.ui.View):
    def __init__(self, author_id: int, area_id: str, state: dict):
        super().__init__(timeout=180)
        self.author_id = author_id
        self.area_id = area_id
        self.state = state
        self._handled = False
        self._last_handled_id: str | None = None
        self._last_handled_ts: float = 0.0
        self._build_buttons()

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    def _build_buttons(self):
        route = ADVENTURE_ROUTES.get(self.area_id, {})
        collectible = route.get("collectible_button")
        collected = collectible and self.state.get(collectible.get("state_key"))

        if not collected and collectible:
            # Area with collectible (e.g. Pok√©ball on ground): show collect button only; no paths, no Next until collected
            collect_btn = discord.ui.Button(
                label=collectible.get("label", "Collect"),
                style=discord.ButtonStyle.primary,
                custom_id="adv:collect",
            )
            collect_btn.callback = self._on_collect
            self.add_item(collect_btn)
            # Next is hidden until collected; Back still available if history exists (added below)
        else:
            # Maze routes use directional exit buttons per node
            if route.get("layout") == "maze":
                nodes = route.get("nodes") or {}
                node_id = _maze_get_node(self.state, self.area_id, route)
                entry_node = route.get("entry_node") or "start"
                prev_area = route.get("prev")
                if node_id == entry_node and prev_area and (self.state.get("area_history") or route.get("back_always")):
                    back_btn = discord.ui.Button(label="‚¨ÖÔ∏è Back", style=discord.ButtonStyle.secondary, custom_id=f"adv:maze:{self.area_id}:back")
                    back_btn.callback = self._on_maze_back
                    self.add_item(back_btn)
                node_cfg = nodes.get(node_id)
                if node_cfg:
                    for exit_cfg in (node_cfg.get("exits") or []):
                        if isinstance(exit_cfg, dict) and exit_cfg.get("id") and exit_cfg.get("target"):
                            btn = discord.ui.Button(
                                label=exit_cfg.get("label", exit_cfg["id"]),
                                style=discord.ButtonStyle.secondary,
                                custom_id=f"adv:maze:{self.area_id}:{exit_cfg['id']}",
                            )
                            btn.callback = self._on_maze_exit
                            self.add_item(btn)
                force_btn = discord.ui.Button(label="‚öîÔ∏è Battle", style=discord.ButtonStyle.danger, custom_id=f"adv:maze:{self.area_id}:force")
                force_btn.callback = self._on_maze_force
                self.add_item(force_btn)
            # Routes with panels (route-1, route-2) use Forward/Back navigation instead of path selection
            else:
                panels = route.get("panels") or []
                if isinstance(panels, list) and len(panels) >= 3:
                    back_btn = discord.ui.Button(label="‚¨áÔ∏è", style=discord.ButtonStyle.secondary, custom_id=f"adv:panel:{self.area_id}:back")
                    back_btn.callback = self._on_back_panel
                    self.add_item(back_btn)

                    fwd_btn = discord.ui.Button(label="‚¨ÜÔ∏è", style=discord.ButtonStyle.primary, custom_id=f"adv:panel:{self.area_id}:fwd")
                    fwd_btn.callback = self._on_forward_panel
                    self.add_item(fwd_btn)

                    force_btn = discord.ui.Button(label="‚öîÔ∏è Battle", style=discord.ButtonStyle.danger, custom_id=f"adv:panel:{self.area_id}:force")
                    force_btn.callback = self._on_force_panel
                    self.add_item(force_btn)
                    # Panel-specific sign/readable (e.g. Route 2 sign on panel 1)
                    panel_signs = route.get("panel_signs") or {}
                    rp = (self.state.get("route_panels") or {}).get(self.area_id) or {}
                    panel = max(1, min(int(rp.get("panel", 1)), 3))
                    sign_cfg = panel_signs.get(panel)
                    if sign_cfg and isinstance(sign_cfg, dict):
                        sign_btn = discord.ui.Button(
                            label=sign_cfg.get("label", "Read Sign"),
                            style=discord.ButtonStyle.secondary,
                            custom_id=f"adv:sign:{self.area_id}:{panel}",
                        )
                        sign_btn.callback = self._on_read_sign
                        self.add_item(sign_btn)
                else:
                    for path_id in sorted((route.get("grass_paths") or {}).keys()):
                        btn = discord.ui.Button(label=str(path_id), style=discord.ButtonStyle.secondary, custom_id=f"adv:path:{path_id}")
                        btn.callback = self._on_path
                        self.add_item(btn)

        next_id = route.get("next")
        cleared = self.area_id in self.state.get("cleared_routes", [])
        next_always = route.get("next_always", False)
        next_blocker = route.get("next_blocker")
        next_blocker_defeated = not next_blocker or next_blocker in self.state.get("defeated_trainers", {}) or route.get("next_show_when_path_blockers_only")
        # When next_show_when_path_blockers_only: show Next as soon as path blockers (not next_blocker) are defeated
        path_blockers_cleared = route.get("next_show_when_path_blockers_only") and _route_path_blockers_cleared(self.state, self.area_id)
        # Don't show Next if there's an uncollected collectible (user must collect first)
        # Panel/maze routes use arrows/exits to navigate, so no Next button
        has_panels = isinstance(route.get("panels"), list) and len(route.get("panels", [])) >= 3
        has_maze = route.get("layout") == "maze"
        show_next = next_id and not has_panels and not has_maze and (cleared or next_always or path_blockers_cleared) and next_blocker_defeated and (not collectible or collected)
        if show_next:
            next_label = "Next"
            if _is_city(next_id):
                next_label = ADVENTURE_CITIES.get(next_id, {}).get("name", next_id.replace("-", " ").title())
            next_btn = discord.ui.Button(label=next_label, style=discord.ButtonStyle.primary, custom_id=f"adv:next:{next_id}")
            next_btn.callback = self._on_next
            self.add_item(next_btn)

        # Optional rematch buttons (24h cooldown); skip if trainer has rematch: False
        trainers = route.get("trainers") or {}
        for tid, tdata in trainers.items():
            if tdata.get("rematch", True) is False:
                continue
            last = self.state.get("defeated_trainers", {}).get(tid, 0)
            if last:
                label = f"Rematch: {tdata.get('name', 'Trainer')}"
                btn = discord.ui.Button(label=label, style=discord.ButtonStyle.danger, custom_id=f"adv:rematch:{tid}")
                btn.callback = self._on_rematch
                self.add_item(btn)
        # Back button if history exists or route always shows back (e.g. route-22)
        # Panel/maze routes use their own navigation, not this button
        if (self.state.get("area_history") or route.get("back_always")) and not has_panels and not has_maze:
            back_btn = discord.ui.Button(label="Back", style=discord.ButtonStyle.secondary, custom_id="adv:back")
            back_btn.callback = self._on_back
            self.add_item(back_btn)

    async def _on_next(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            route = ADVENTURE_ROUTES.get(self.area_id, {})
            rival_id = route.get("rival_battle")
            if rival_id and rival_id not in state.get("rival_defeated", []):
                user_name = itx.user.display_name if hasattr(itx.user, "display_name") else itx.user.name
                if self.area_id == "route-22":
                    challenge_emb, challenge_files = _embed_with_image(
                        "WAIT!",
                        f"**Rival:** {user_name}! Don't you dare walk away! I challenge you to a battle!",
                        route.get("image_rival_arrived") or route.get("image_uncleared"),
                    )
                    challenge_emb.color = 0x5865F2
                    await itx.followup.send(embed=challenge_emb, files=challenge_files or None, ephemeral=False)
                else:
                    challenge_emb = discord.Embed(
                        title="Your rival appears!",
                        description="**Rival:** Think you can get past me? Let's battle!",
                        color=0x5865F2,
                    )
                    await itx.followup.send(embed=challenge_emb, ephemeral=False)
                won = await _run_rival_battle(itx, self.area_id, state)
                if won is None:
                    return await itx.followup.send("Couldn't start the rival battle. Please try again.", ephemeral=False)
                if not won:
                    return
                state = await _get_adventure_state(str(itx.user.id))
            _, next_id = itx.data["custom_id"].split("adv:next:", 1)
            # Require route to be cleared before going to next area (no skipping)
            current_area = state.get("area_id") or self.area_id
            route_def = ADVENTURE_ROUTES.get(current_area, {})
            if current_area in ADVENTURE_ROUTES:
                if not route_def.get("next_always"):
                    cleared = current_area in state.get("cleared_routes", [])
                    path_blockers_ok = route_def.get("next_show_when_path_blockers_only") and _route_path_blockers_cleared(state, current_area)
                    if not cleared and not _route_is_cleared(state, current_area) and not path_blockers_ok:
                        await itx.followup.send("Clear this route first before moving on.", ephemeral=False)
                        return
            # If route has next_trainer: second trainer is only triggerable by clicking Next, not by blocking a path
            next_trainer_id = route_def.get("next_trainer")
            if next_trainer_id and next_trainer_id not in state.get("defeated_trainers", {}):
                trainer = (route_def.get("trainers") or {}).get(next_trainer_id)
                if trainer:
                    trainer_name = trainer.get("name", "Trainer")
                    blocker_quote = trainer.get("blocker_quote") or "You'll have to beat me first!"
                    challenge_emb = discord.Embed(
                        title="Before you go...",
                        description=f"**{trainer_name}:** {blocker_quote}",
                        color=0x5865F2,
                    )
                    await itx.followup.send(embed=challenge_emb, ephemeral=False)
                    team = []
                    for m in trainer.get("team", []):
                        mon = await _build_mon_from_team_entry(m)
                        if mon:
                            team.append(mon)
                    if not team:
                        return await itx.followup.send("Trainer team failed to load.", ephemeral=False)
                    won = await _start_pve_battle(itx, team, trainer_name, resend_adventure_panel=False)
                    if won is None:
                        return await itx.followup.send("Couldn't start the battle. Please try again.", ephemeral=False)
                    if not won:
                        state = await _get_adventure_state(str(itx.user.id))
                        await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
                        return
                    state.setdefault("defeated_trainers", {})[next_trainer_id] = int(time.time())
                    if _route_is_cleared(state, current_area) and current_area not in state.get("cleared_routes", []):
                        state.setdefault("cleared_routes", []).append(current_area)
                    await _save_adventure_state(str(itx.user.id), state)
                    state = await _get_adventure_state(str(itx.user.id))
                    # Stay on current area and re-send panel so user can click Next again to advance
                    await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
                    return
            _adv_history_push(state, state.get("area_id"))
            state["area_id"] = next_id
            await _save_adventure_state(str(itx.user.id), state)
            await _send_adventure_panel(itx, state, edit_original=True)
        finally:
            self._handled = False

    async def _on_back(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.0:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            if not isinstance(state.get("area_history"), list) or not state.get("area_history"):
                return await itx.followup.send("No previous area.", ephemeral=False)
            state["area_id"] = _adv_history_pop(state, "pallet-town")
            await _save_adventure_state(str(itx.user.id), state)
            await _send_adventure_panel(itx, state, edit_original=True)
        finally:
            self._handled = False


    # ===== Route 1 3-panel navigation =====
    def _r1_get(self, state: dict) -> dict:
        rp = (state.setdefault("route_panels", {})).get(self.area_id)
        if not isinstance(rp, dict):
            rp = {"panel": 1}
            state["route_panels"][self.area_id] = rp
        try:
            rp["panel"] = max(1, min(int(rp.get("panel", 1)), 3))
        except Exception:
            rp["panel"] = 1
        return rp

    def _r1_set(self, state: dict, panel: int) -> None:
        state.setdefault("route_panels", {})[self.area_id] = {"panel": int(panel)}

    async def _r1_try_wild_encounter(self, itx: discord.Interaction, state: dict, *, force: bool = False) -> None:
        """Roll (or force) a wild encounter using the route's grass encounters."""
        await _route_panel_try_wild_encounter(itx, state, self.area_id, force=force)


async def _route_panel_try_wild_encounter(itx: discord.Interaction, state: dict, area_id: str, *, force: bool = False) -> None:
    """Roll (or force) a wild encounter on a panel route (route-1, route-2, etc.)."""
    route = ADVENTURE_ROUTES.get(area_id, {})
    try:
        chance = float(os.environ.get("ROUTE_MOVE_ENCOUNTER_CHANCE", "0.35"))
    except Exception:
        chance = 0.35
    if not force and random.random() > chance:
        return

    all_encounters = []
    for p in (route.get("grass_paths") or {}).values():
        enc = (p or {}).get("encounters") or []
        all_encounters.extend(enc)

    if not all_encounters:
        return

    enc_specs = []
    weights = []
    version = "red"
    for e in all_encounters:
        if isinstance(e, str):
            enc_specs.append({"species": e, "min_level": 3, "max_level": 3})
            weights.append(1)
        elif isinstance(e, dict):
            ver = e.get("version")
            if ver and ver.lower() not in str(version).lower():
                continue
            enc_specs.append(
                {
                    "species": e.get("species"),
                    "min_level": int(e.get("min_level", 3)),
                    "max_level": int(e.get("max_level", e.get("min_level", 3))),
                }
            )
            weights.append(int(e.get("weight", 1)))

    if not enc_specs:
        return

    choice = random.choices(enc_specs, weights=weights, k=1)[0]
    species = choice["species"]
    state.setdefault("repeat_seen", [])
    if species and species.lower() not in [s.lower() for s in state["repeat_seen"]]:
        state["repeat_seen"].append(species)
        state["dex_seen"] = state.get("dex_seen", 0) + 1
    try:
        asyncio.create_task(pokedex_mark_seen(str(itx.user.id), species, caught=False))
    except Exception:
        pass

    lvl = random.randint(choice["min_level"], choice["max_level"])
    sync_nature = await _wild_synchronize_nature(str(itx.user.id))
    wild_mon = await _build_mon_from_species(species, level=lvl, sync_nature=sync_nature)
    if not wild_mon:
        return

    route_display = route.get("name", area_id)
    won = await _start_pve_battle(
        itx,
        [wild_mon],
        f"Wild {species.title()}",
        area_id=area_id,
        route_display_name=route_display,
    )
    if won is _PVE_ALREADY_IN_BATTLE:
        return
    if won is None:
        return await itx.followup.send("Couldn't start the encounter battle. Please try again.", ephemeral=False)
    if won:
        _add_discovered(state, area_id, species)
        try:
            asyncio.create_task(pokedex_mark_seen(str(itx.user.id), species, caught=True))
        except Exception:
            pass


async def _route_maze_try_wild_encounter(itx: discord.Interaction, state: dict, area_id: str, target_node_id: Optional[str], *, force: bool = False) -> None:
    """Roll (or force) a wild encounter on a maze route. Uses target node if moving, else current node."""
    route = ADVENTURE_ROUTES.get(area_id, {})
    if route.get("layout") != "maze":
        return
    nodes = route.get("nodes") or {}
    node_id = target_node_id or _maze_get_node(state, area_id, route)
    node_cfg = nodes.get(node_id, {})
    encounters = node_cfg.get("encounters") or []
    if not encounters:
        return
    try:
        chance = float(os.environ.get("ROUTE_MOVE_ENCOUNTER_CHANCE", "0.35"))
    except Exception:
        chance = 0.35
    if not force and random.random() > chance:
        return
    enc_specs = []
    weights = []
    version = "red"
    for e in encounters:
        if isinstance(e, str):
            enc_specs.append({"species": e, "min_level": 3, "max_level": 3})
            weights.append(1)
        elif isinstance(e, dict):
            ver = e.get("version")
            if ver and ver.lower() not in str(version).lower():
                continue
            enc_specs.append({
                "species": e.get("species"),
                "min_level": int(e.get("min_level", 3)),
                "max_level": int(e.get("max_level", e.get("min_level", 3))),
            })
            weights.append(int(e.get("weight", 1)))
    if not enc_specs:
        return
    choice = random.choices(enc_specs, weights=weights, k=1)[0]
    species = choice["species"]
    state.setdefault("repeat_seen", [])
    if species and species.lower() not in [s.lower() for s in state["repeat_seen"]]:
        state["repeat_seen"].append(species)
        state["dex_seen"] = state.get("dex_seen", 0) + 1
    try:
        asyncio.create_task(pokedex_mark_seen(str(itx.user.id), species, caught=False))
    except Exception:
        pass
    lvl = random.randint(choice["min_level"], choice["max_level"])
    sync_nature = await _wild_synchronize_nature(str(itx.user.id))
    wild_mon = await _build_mon_from_species(species, level=lvl, sync_nature=sync_nature)
    if not wild_mon:
        return
    route_display = route.get("name", area_id)
    won = await _start_pve_battle(itx, [wild_mon], f"Wild {species.title()}", area_id=area_id, route_display_name=route_display)
    if won is _PVE_ALREADY_IN_BATTLE:
        return
    if won is None:
        return await itx.followup.send("Couldn't start the encounter battle. Please try again.", ephemeral=False)
    if won:
        _add_discovered(state, area_id, species)
        try:
            asyncio.create_task(pokedex_mark_seen(str(itx.user.id), species, caught=True))
        except Exception:
            pass


def _panel_get_panel(state: dict, area_id: str) -> int:
    """Get current panel (1‚Äì3) for a panel route."""
    rp = (state.get("route_panels") or {}).get(area_id)
    if not isinstance(rp, dict):
        return 1
    return max(1, min(int(rp.get("panel", 1)), 3))


def _panel_set_panel(state: dict, area_id: str, panel: int) -> None:
    """Set panel in state for a panel route."""
    state.setdefault("route_panels", {})[area_id] = {"panel": int(panel)}


def _r1_get_panel(state: dict) -> int:
    return _panel_get_panel(state, "route-1")


def _r1_set_panel(state: dict, panel: int) -> None:
    _panel_set_panel(state, "route-1", panel)


def _get_panel_routes() -> list[str]:
    """Return route ids that have 3+ panels."""
    return [rid for rid, r in ADVENTURE_ROUTES.items()
            if isinstance(r.get("panels"), list) and len(r.get("panels", [])) >= 3]


def _get_maze_routes() -> list[str]:
    """Return route ids that use maze layout."""
    return [rid for rid, r in ADVENTURE_ROUTES.items()
            if r.get("layout") == "maze" and isinstance(r.get("nodes"), dict)]


def _maze_get_node(state: dict, area_id: str, route: dict) -> str:
    """Get current maze node id; init to entry_node if not set."""
    rp = (state.get("route_panels") or {}).get(area_id)
    if isinstance(rp, dict) and rp.get("node"):
        node_id = str(rp["node"])
        if node_id in (route.get("nodes") or {}):
            return node_id
    entry = route.get("entry_node") or "start"
    state.setdefault("route_panels", {})[area_id] = {"node": entry}
    return entry


def _maze_set_node(state: dict, area_id: str, node_id: str) -> None:
    """Set current maze node."""
    state.setdefault("route_panels", {})[area_id] = {"node": str(node_id)}


def _get_maze_exit_ids(route: dict) -> set:
    """Return all unique exit ids used in a maze route's nodes."""
    out = set()
    for node_cfg in (route.get("nodes") or {}).values():
        for ex in (node_cfg.get("exits") or []):
            if isinstance(ex, dict) and ex.get("id"):
                out.add(ex["id"])
    return out


class AdventureRoute1PersistentView(discord.ui.View):
    """Persistent view so panel route (route-1, route-2, etc.) arrow buttons work after bot restart or view timeout."""
    def __init__(self):
        super().__init__(timeout=None)
        # Legacy route-1 + panel format buttons for each route
        for area_id in _get_panel_routes():
            for direction, label, style in [("back", "‚¨áÔ∏è", discord.ButtonStyle.secondary), ("fwd", "‚¨ÜÔ∏è", discord.ButtonStyle.primary)]:
                cid = f"adv:panel:{area_id}:{direction}"
                b = discord.ui.Button(label=label, style=style, custom_id=cid)
                b.callback = self._handle_panel_move
                self.add_item(b)
        # Maze routes: exit buttons, force, back
        for area_id in _get_maze_routes():
            route = ADVENTURE_ROUTES.get(area_id, {})
            exit_ids = _get_maze_exit_ids(route)
            for eid in sorted(exit_ids):
                cid = f"adv:maze:{area_id}:{eid}"
                b = discord.ui.Button(label=eid.title(), style=discord.ButtonStyle.secondary, custom_id=cid)
                b.callback = self._handle_maze
                self.add_item(b)
            bf = discord.ui.Button(label="‚öîÔ∏è Battle", style=discord.ButtonStyle.danger, custom_id=f"adv:maze:{area_id}:force")
            bf.callback = self._handle_maze
            self.add_item(bf)
            bb = discord.ui.Button(label="‚¨ÖÔ∏è Back", style=discord.ButtonStyle.secondary, custom_id=f"adv:maze:{area_id}:back")
            bb.callback = self._handle_maze
            self.add_item(bb)
        # Legacy adv:r1:back/fwd for old Route 1 messages
        for cid, label, style in [("adv:r1:back", "‚¨áÔ∏è", discord.ButtonStyle.secondary), ("adv:r1:fwd", "‚¨ÜÔ∏è", discord.ButtonStyle.primary)]:
            b = discord.ui.Button(label=label, style=style, custom_id=cid)
            b.callback = self._handle_panel_move
            self.add_item(b)

    async def _handle_maze(self, itx: discord.Interaction, button: discord.ui.Button):
        cid = (button.custom_id or (itx.data or {}).get("custom_id") or "")
        if not cid.startswith("adv:maze:") or cid.count(":") < 3:
            await itx.response.defer(ephemeral=False, thinking=False)
            await _send_adventure_panel(itx, await _get_adventure_state(str(itx.user.id)), edit_original=False)
            return
        parts = cid.split(":", 3)
        area_id, action = parts[2], parts[3]
        await itx.response.defer(ephemeral=False, thinking=False)
        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        if state.get("area_id") != area_id:
            await _send_adventure_panel(itx, state, edit_original=False)
            return
        route = ADVENTURE_ROUTES.get(area_id, {})
        if route.get("layout") != "maze":
            await _send_adventure_panel(itx, state, edit_original=False)
            return
        if action == "force":
            await _route_maze_try_wild_encounter(itx, state, area_id, None, force=True)
            await _save_adventure_state(uid, state)
            await _send_adventure_panel(itx, state, edit_original=False)
            return
        if action == "back":
            prev_area = route.get("prev")
            if prev_area:
                _adv_history_push(state, area_id)
                state["area_id"] = prev_area
                state.get("route_panels", {}).pop(area_id, None)
            await _save_adventure_state(uid, state)
            await _send_adventure_panel(itx, state, edit_original=False)
            return
        # Exit: north, south, east, west, etc.
        nodes = route.get("nodes") or {}
        node_id = _maze_get_node(state, area_id, route)
        node_cfg = nodes.get(node_id, {})
        exits_list = node_cfg.get("exits") or []
        target = None
        for ex in exits_list:
            if isinstance(ex, dict) and ex.get("id") == action:
                target = ex.get("target")
                break
        if not target:
            await _send_adventure_panel(itx, state, edit_original=False)
            return
        exit_node = route.get("exit_node")
        moved_within_route = True
        if target == exit_node:
            next_area = route.get("next")
            if next_area:
                _adv_history_push(state, area_id)
                state["area_id"] = next_area
            state.get("route_panels", {}).pop(area_id, None)
            moved_within_route = False
        else:
            _maze_set_node(state, area_id, target)
        await _save_adventure_state(uid, state)
        if moved_within_route:
            await _route_maze_try_wild_encounter(itx, state, area_id, target, force=False)
            await _save_adventure_state(uid, state)
        await _send_adventure_panel(itx, state, edit_original=False)

    async def _handle_panel_move(self, itx: discord.Interaction, button: discord.ui.Button):
        cid = (button.custom_id or (itx.data or {}).get("custom_id") or "")
        if cid.startswith("adv:r1:"):
            area_id, direction = "route-1", ("back" if "back" in cid else "fwd")
        elif cid.startswith("adv:panel:") and cid.count(":") >= 3:
            parts = cid.split(":", 3)
            area_id, direction = parts[2], parts[3].split(":")[0] if ":" in parts[3] else parts[3]
        else:
            await itx.response.defer(ephemeral=False, thinking=False)
            await _send_adventure_panel(itx, await _get_adventure_state(str(itx.user.id)), edit_original=False)
            return
        await self._handle_route_panel_move(itx, area_id, direction)

    async def _handle_route_panel_move(self, itx: discord.Interaction, area_id: str, direction: str) -> None:
        await itx.response.defer(ephemeral=False, thinking=False)
        uid = str(itx.user.id)
        state = await _get_adventure_state(uid)
        if state.get("area_id") != area_id:
            await _send_adventure_panel(itx, state, edit_original=False)
            return
        route = ADVENTURE_ROUTES.get(area_id, {})
        panels = route.get("panels") or []
        num_panels = max(3, len(panels)) if isinstance(panels, list) else 3
        panel = _panel_get_panel(state, area_id)
        moved_within_route = False
        if direction == "fwd":
            if panel < num_panels:
                _panel_set_panel(state, area_id, panel + 1)
                moved_within_route = True
            else:
                next_area = route.get("next")
                if next_area:
                    _adv_history_push(state, area_id)
                    state["area_id"] = next_area
                state.get("route_panels", {}).pop(area_id, None)
        else:
            if panel > 1:
                _panel_set_panel(state, area_id, panel - 1)
                moved_within_route = True
            else:
                state["area_id"] = route.get("prev") or "pallet-town"
                state.get("route_panels", {}).pop(area_id, None)
        await _save_adventure_state(uid, state)
        print(f"[Adventure] Persistent view: moved_within_route={moved_within_route}, sending panel with roll_route1_item={moved_within_route}")
        if moved_within_route:
            await _route_panel_try_wild_encounter(itx, state, area_id)
            await _save_adventure_state(uid, state)
        await _send_adventure_panel(itx, state, edit_original=False, roll_route1_item=moved_within_route)


class _AdventureRouteViewRoute1Methods:
    """Mixin-style: methods for AdventureRouteView (panel route ‚¨ÜÔ∏è‚¨áÔ∏è handlers for route-1, route-2, etc.)."""
    async def _on_back_panel(self, itx: discord.Interaction):
        print("[Adventure] Ephemeral view _on_back_route1 (‚¨áÔ∏è) called")
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not itx.response.is_done():
            await itx.response.defer(ephemeral=False, thinking=False)

        state = await _get_adventure_state(str(itx.user.id))
        rp = self._r1_get(state)
        panel = int(rp["panel"])
        moved_within_route = False

        route = ADVENTURE_ROUTES.get(self.area_id, {})
        prev_area = route.get("prev") or "pallet-town"

        if panel > 1:
            self._r1_set(state, panel - 1)
            moved_within_route = True
        else:
            state["area_id"] = prev_area
            state.get("route_panels", {}).pop(self.area_id, None)

        await _save_adventure_state(str(itx.user.id), state)
        print(f"[Adventure] Ephemeral view (back): moved_within_route={moved_within_route}, roll_route1_item={moved_within_route}")
        if moved_within_route:
            await self._r1_try_wild_encounter(itx, state, force=False)
            await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=False, roll_route1_item=moved_within_route)

    async def _on_forward_panel(self, itx: discord.Interaction):
        print("[Adventure] Ephemeral view _on_forward_route1 (‚¨ÜÔ∏è) called")
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        # Always respond quickly so Discord doesn't drop the interaction
        if not itx.response.is_done():
            await itx.response.defer(ephemeral=False, thinking=False)

        state = await _get_adventure_state(str(itx.user.id))
        rp = self._r1_get(state)
        panel = int(rp["panel"])
        moved_within_route = False

        route = ADVENTURE_ROUTES.get(self.area_id, {})
        next_area = route.get("next")

        if panel < 3:
            self._r1_set(state, panel + 1)
            moved_within_route = True
        else:
            # leaving route -> next city
            if next_area:
                _adv_history_push(state, self.area_id)
                state["area_id"] = next_area
            state.get("route_panels", {}).pop(self.area_id, None)

        await _save_adventure_state(str(itx.user.id), state)
        print(f"[Adventure] Ephemeral view: moved_within_route={moved_within_route}, calling _send_adventure_panel with roll_route1_item={moved_within_route}")
        if moved_within_route:
            await self._r1_try_wild_encounter(itx, state, force=False)
            await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=False, roll_route1_item=moved_within_route)


    async def _on_force_panel(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not itx.response.is_done():
            await itx.response.defer(ephemeral=False, thinking=False)

        state = await _get_adventure_state(str(itx.user.id))
        # Force encounter
        await self._r1_try_wild_encounter(itx, state, force=True)
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=False)

    async def _on_maze_back(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not itx.response.is_done():
            await itx.response.defer(ephemeral=False, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        route = ADVENTURE_ROUTES.get(self.area_id, {})
        prev_area = route.get("prev")
        if prev_area:
            _adv_history_push(state, self.area_id)
            state["area_id"] = prev_area
            state.get("route_panels", {}).pop(self.area_id, None)
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=False)

    async def _on_maze_exit(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not itx.response.is_done():
            await itx.response.defer(ephemeral=False, thinking=False)
        cid = (itx.data or {}).get("custom_id", "")
        parts = cid.split(":") if cid else []
        if len(parts) < 4:
            return await itx.followup.send("Invalid maze exit.", ephemeral=True)
        area_id, exit_id = parts[2], parts[3]
        state = await _get_adventure_state(str(itx.user.id))
        route = ADVENTURE_ROUTES.get(area_id, {})
        if route.get("layout") != "maze":
            return await itx.followup.send("Not a maze route.", ephemeral=True)
        nodes = route.get("nodes") or {}
        node_id = _maze_get_node(state, area_id, route)
        node_cfg = nodes.get(node_id, {})
        exits_list = node_cfg.get("exits") or []
        target = None
        for ex in exits_list:
            if isinstance(ex, dict) and ex.get("id") == exit_id:
                target = ex.get("target")
                break
        if not target:
            return await itx.followup.send("That exit isn't available from here.", ephemeral=True)
        exit_node = route.get("exit_node")
        moved_within_route = True
        if target == exit_node:
            next_area = route.get("next")
            if next_area:
                _adv_history_push(state, area_id)
                state["area_id"] = next_area
            state.get("route_panels", {}).pop(area_id, None)
            moved_within_route = False
        else:
            _maze_set_node(state, area_id, target)
        await _save_adventure_state(str(itx.user.id), state)
        if moved_within_route:
            await _route_maze_try_wild_encounter(itx, state, area_id, target, force=False)
            await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=False)

    async def _on_maze_force(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if not itx.response.is_done():
            await itx.response.defer(ephemeral=False, thinking=False)
        state = await _get_adventure_state(str(itx.user.id))
        await _route_maze_try_wild_encounter(itx, state, self.area_id, None, force=True)
        await _save_adventure_state(str(itx.user.id), state)
        await _send_adventure_panel(itx, state, edit_original=False)

    async def _on_read_sign(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id", "")
        route = ADVENTURE_ROUTES.get(self.area_id, {})
        panel_signs = route.get("panel_signs") or {}
        try:
            parts = cid.split(":")
            if len(parts) >= 4:
                area_id, panel = parts[2], int(parts[3])
                sign_cfg = panel_signs.get(panel) if isinstance(panel_signs, dict) else None
                if sign_cfg and isinstance(sign_cfg, dict):
                    text = sign_cfg.get("text", "")
                    text_alt = sign_cfg.get("text_alt")
                    if text_alt is not None:
                        chance = float(sign_cfg.get("text_chance", 0.9))
                        text = text if random.random() < chance else text_alt
                    if text:
                        await itx.response.send_message(f"**Sign:**\n>>> {text}", ephemeral=True)
                        return
        except Exception:
            pass
        await itx.response.send_message("Nothing to read.", ephemeral=True)

    async def _on_collect(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            route = ADVENTURE_ROUTES.get(self.area_id, {})
            collectible = route.get("collectible_button")
            if not collectible or state.get(collectible.get("state_key")):
                await itx.followup.send("Nothing to collect here.", ephemeral=False)
                return
            state[collectible.get("state_key")] = True
            item_id = collectible.get("item")
            qty = int(collectible.get("qty", 1))
            if item_id and qty > 0:
                try:
                    await db.give_item(str(itx.user.id), item_id, qty)
                except Exception:
                    pass
            next_area = collectible.get("next_area")
            if next_area:
                # Don't push collectible area to history: Back from next_area should go to the area before (e.g. don't return to pokeball screen once it's gone)
                state["area_id"] = next_area
            await _save_adventure_state(str(itx.user.id), state)
            collect_label = collectible.get("label", "Item")
            await itx.followup.send(f"You picked up **{collect_label}**!", ephemeral=False)
            await _send_adventure_panel(itx, state, edit_original=True)
        finally:
            self._handled = False

    async def _on_path(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        path_id: Optional[int] = None
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            route = ADVENTURE_ROUTES.get(self.area_id, {})
            rival_id = route.get("rival_battle")
            if rival_id and rival_id not in state.get("rival_defeated", []):
                user_name = itx.user.display_name if hasattr(itx.user, "display_name") else itx.user.name
                if self.area_id == "route-22":
                    challenge_emb, challenge_files = _embed_with_image(
                        "WAIT!",
                        f"**Rival:** {user_name}! Don't you dare walk away! I challenge you to a battle!",
                        route.get("image_rival_arrived") or route.get("image_uncleared"),
                    )
                    challenge_emb.color = 0x5865F2
                    await itx.followup.send(embed=challenge_emb, files=challenge_files or None, ephemeral=False)
                else:
                    challenge_emb = discord.Embed(
                        title="Your rival appears!",
                        description="**Rival:** Think you can get past me? Let's battle!",
                        color=0x5865F2,
                    )
                    await itx.followup.send(embed=challenge_emb, ephemeral=False)
                won = await _run_rival_battle(itx, self.area_id, state)
                if won is None:
                    return await itx.followup.send("Couldn't start the rival battle. Please try again.", ephemeral=False)
                if not won:
                    return
                state = await _get_adventure_state(str(itx.user.id))
            path_id = int(itx.data["custom_id"].split(":")[-1])
            path = (route.get("grass_paths") or {}).get(path_id)
            if not path:
                return await itx.followup.send("That path doesn't exist.", ephemeral=False)
            # Random item drop on path move (same kind of trigger as Route 1 encounter chance)
            await _try_route_move_item_drop(itx, str(itx.user.id))
            blocker = path.get("blocker")
            if blocker and blocker not in state.get("defeated_trainers", {}):
                trainer = (route.get("trainers") or {}).get(blocker)
                if not trainer:
                    return await itx.followup.send("Trainer data missing.", ephemeral=False)
                trainer_name = trainer.get("name", "Trainer")
                blocker_quote = trainer.get("blocker_quote") or f"You'll have to beat me first if you want to cross!"
                challenge_emb = discord.Embed(
                    title="While trying to cross grass",
                    description=f"**{trainer_name}:** {blocker_quote}",
                    color=0x5865F2,
                )
                await itx.followup.send(embed=challenge_emb, ephemeral=False)
                team = []
                for m in trainer.get("team", []):
                    mon = await _build_mon_from_team_entry(m)
                    if mon:
                        team.append(mon)
                if not team:
                    return await itx.followup.send("Trainer team failed to load.", ephemeral=False)
                won = await _start_pve_battle(itx, team, trainer_name, resend_adventure_panel=False)
                if won is None:
                    return await itx.followup.send("Couldn't start the battle. Please try again.", ephemeral=False)
                if not won:
                    await itx.followup.send("‚ùå You lost the battle.", ephemeral=False)
                    state = await _get_adventure_state(str(itx.user.id))
                    await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
                    return
                state.setdefault("defeated_trainers", {})[blocker] = int(time.time())
                if _route_is_cleared(state, self.area_id) and self.area_id not in state.get("cleared_routes", []):
                    state.setdefault("cleared_routes", []).append(self.area_id)
                await _save_adventure_state(str(itx.user.id), state)
                await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
                return

            # Encounter
            encounters = path.get("encounters") or []
            if not encounters:
                return await itx.followup.send("No encounters here yet.", ephemeral=False)
            # Support weighted encounters with level ranges and version filters
            enc_specs = []
            weights = []
            # Game version (Red/Blue differences). If not stored anywhere, fall back to Red.
            version = "red"
            for e in encounters:
                if isinstance(e, str):
                    enc_specs.append({"species": e, "min_level": 3, "max_level": 3})
                    weights.append(1)
                elif isinstance(e, dict):
                    ver = e.get("version")
                    if ver and ver.lower() not in str(version).lower():
                        continue  # skip encounters not for this version
                    enc_specs.append(
                        {
                            "species": e.get("species"),
                            "min_level": int(e.get("min_level", 3)),
                            "max_level": int(e.get("max_level", e.get("min_level", 3))),
                        }
                    )
                    weights.append(int(e.get("weight", 1)))
            choice = random.choices(enc_specs, weights=weights, k=1)[0]
            species = choice["species"]
            # track seen species for Repeat Ball / dex counts
            state.setdefault("repeat_seen", [])
            if species.lower() not in [s.lower() for s in state["repeat_seen"]]:
                state["repeat_seen"].append(species)
                state["dex_seen"] = state.get("dex_seen", 0) + 1
            # Persist to pokedex table (fire-and-forget so encounter starts faster)
            try:
                asyncio.create_task(pokedex_mark_seen(str(itx.user.id), species, caught=False))
            except Exception:
                pass
            lvl = random.randint(choice["min_level"], choice["max_level"])
            sync_nature = await _wild_synchronize_nature(str(itx.user.id))
            wild_mon = await _build_mon_from_species(species, level=lvl, sync_nature=sync_nature)
            if not wild_mon:
                await _save_adventure_state(str(itx.user.id), state)
                return await itx.followup.send("Encounter failed to load.", ephemeral=False)

            route_display = route.get("name", self.area_id)
            won = await _start_pve_battle(
                itx,
                [wild_mon],
                f"Wild {species.title()}",
                area_id=self.area_id,
                route_display_name=route_display,
                resend_adventure_panel=False,
            )
            if won is _PVE_ALREADY_IN_BATTLE:
                return  # "You're already in a battle." was already sent; don't send a second message
            if won is None:
                await _save_adventure_state(str(itx.user.id), state)
                return await itx.followup.send("Couldn't start the encounter battle. Please try again.", ephemeral=False)
            if won:
                _add_discovered(state, self.area_id, species)
                # Mark caught in Pok√©dex (fire-and-forget)
                try:
                    asyncio.create_task(pokedex_mark_seen(str(itx.user.id), species, caught=True))
                except Exception:
                    pass
            await _save_adventure_state(str(itx.user.id), state)
            await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            print(tb)
            print(f"[Adventure] Error handling path {self.area_id}:{path_id} -> {e}")
            try:
                preview = (tb or str(e)).splitlines()[-1] if tb else str(e)
                await itx.followup.send(f"‚ö†Ô∏è Something went wrong starting that encounter.\n`{preview}`", ephemeral=False)
            except Exception:
                pass
        finally:
            self._handled = False

    async def _on_rematch(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id")
        now = time.time()
        if self._handled and self._last_handled_id == cid and (now - self._last_handled_ts) < 1.5:
            return await itx.response.send_message("Already handled.", ephemeral=True)
        self._handled = True
        self._last_handled_id = cid
        self._last_handled_ts = now
        try:
            await itx.response.defer(ephemeral=True, thinking=False)
            state = await _get_adventure_state(str(itx.user.id))
            route = ADVENTURE_ROUTES.get(self.area_id, {})
            tid = itx.data["custom_id"].split(":")[-1]
            last = state.get("defeated_trainers", {}).get(tid)
            if not last:
                return await itx.followup.send("You haven't defeated this trainer yet.", ephemeral=False)
            trainer = (route.get("trainers") or {}).get(tid)
            if not trainer:
                return await itx.followup.send("Trainer data missing.", ephemeral=False)
            team = []
            for m in trainer.get("team", []):
                mon = await _build_mon_from_team_entry(m)
                if mon:
                    team.append(mon)
            if not team:
                return await itx.followup.send("Trainer team failed to load.", ephemeral=False)
            won = await _start_pve_battle(
                itx,
                team,
                trainer.get("name", "Trainer"),
                resend_adventure_panel=False,
            )
            if won is None:
                return await itx.followup.send("Couldn't start the battle. Please try again.", ephemeral=False)
            if won:
                state.setdefault("defeated_trainers", {})[tid] = int(time.time())
                await _save_adventure_state(str(itx.user.id), state)
                await itx.followup.send("‚úÖ Rematch won.", ephemeral=False)
            else:
                await itx.followup.send("‚ùå Rematch lost.", ephemeral=False)
            state = await _get_adventure_state(str(itx.user.id))
            await _send_adventure_panel(itx, state, edit_original=False, force_new_message=True)
        finally:
            self._handled = False

# Last panel sent per user (for /refresh: re-send the latest panel ‚Äî adventure or battle)
LAST_PANEL_BY_USER: Dict[str, Dict[str, Any]] = {}

async def _cancel_previous_panel_for_user(bot: discord.Client, uid: str) -> None:
    """Disable the previous panel's buttons (like a timeout); keep the panel visible but unusable."""
    try:
        last = LAST_PANEL_BY_USER.get(uid)
        if not last:
            return
        message_id = last.get("message_id")
        channel_id = last.get("channel_id")
        view = last.get("view")
        if message_id is None or channel_id is None:
            data = last.get("data") or {}
            message_id = data.get("message_id")
            channel_id = data.get("channel_id")
            if view is None:
                view = data.get("view")
        if message_id is None or channel_id is None:
            return
        ch = bot.get_channel(channel_id)
        if ch is None:
            try:
                ch = await bot.fetch_channel(channel_id)
            except Exception:
                return
        if ch is None:
            return
        msg = await ch.fetch_message(message_id)
        if not msg:
            return
        if view is not None and hasattr(view, "children"):
            for child in view.children:
                if hasattr(child, "disabled"):
                    child.disabled = True
            await msg.edit(view=view)
        else:
            await msg.edit(view=None)
    except Exception:
        pass

async def _send_adventure_panel(
    itx: discord.Interaction,
    state: dict,
    *,
    edit_original: bool,
    route_move_item_message: Optional[str] = None,
    roll_route1_item: bool = False,
    force_new_message: bool = False,
) -> None:
    # If this is a button-press (component interaction), edit the clicked message.
    is_component = (
        not force_new_message
        and getattr(itx, 'type', None) == discord.InteractionType.component
        and getattr(itx, 'message', None) is not None
    )
    msg = None

    async def _edit_with_files(edit_fn):
        try:
            return await edit_fn(embed=emb, attachments=files, view=view)
        except TypeError:
            # Compatibility fallback for discord forks that expect files= on edit.
            return await edit_fn(embed=emb, files=files, view=view)

    uid = str(itx.user.id)
    hatch_messages: list[str] = []
    try:
        changed, hatch_messages = await _daycare_tick(uid, state, command_credit=1.0)
        if changed:
            await _save_adventure_state(uid, state)
    except Exception:
        hatch_messages = []
    if not edit_original and not is_component:
        await _cancel_previous_panel_for_user(itx.client, uid)
    LAST_PANEL_BY_USER[uid] = {"type": "adventure", "state": copy.deepcopy(state)}
    area_id = state.get("area_id") or "pallet-town"
    if _is_city(area_id):
        city = ADVENTURE_CITIES.get(area_id, {})
        if city.get("is_daycare"):
            rec, parent_rows, pair_info, changed = await _daycare_pair_context(uid, state)
            if changed:
                await _save_adventure_state(uid, state)
            p1 = parent_rows[0] if len(parent_rows) > 0 else None
            p2 = parent_rows[1] if len(parent_rows) > 1 else None
            p1_txt = f"{str(p1.get('species') or '').replace('-', ' ').title()} Lv{int(p1.get('level') or 1)}" if p1 else "‚Äî"
            p2_txt = f"{str(p2.get('species') or '').replace('-', ' ').title()} Lv{int(p2.get('level') or 1)}" if p2 else "‚Äî"
            eggs_waiting = len(rec.get("eggs") or [])
            eggs_team = len(rec.get("incubating") or [])
            compat_icon = "‚úÖ" if pair_info.get("can_breed") else "‚ùå"
            desc = (
                f"**Parent #1:** {p1_txt}\n"
                f"**Parent #2:** {p2_txt}\n"
                f"**Compatibility:** {compat_icon} {pair_info.get('reason')}\n"
                f"**Eggs at daycare:** {eggs_waiting}/{DAYCARE_EGG_CAP}\n"
                f"**Eggs in team incubator:** {eggs_team}/{DAYCARE_INCUBATE_MAX}"
            )
            parent_species = [
                str(r.get("species") or "")
                for r in parent_rows
                if isinstance(r, dict) and r.get("species")
            ]
            emb, files = _embed_with_daycare_panel(
                city.get("name", "Daycare"),
                desc,
                parent_species=parent_species,
                egg_count=eggs_waiting,
            )
            view = AdventureDaycareView(itx.user.id, area_id, state, rec, parent_rows, pair_info)
        elif city.get("is_pokemart"):
            direct_image = city.get("image")
            if direct_image and Path(direct_image).exists():
                img = direct_image
            elif city.get("parent_city"):
                parent_city = ADVENTURE_CITIES.get(str(city.get("parent_city")), {})
                img = parent_city.get("image_cleared") or parent_city.get("image_uncleared")
            else:
                img = city.get("image_uncleared") or city.get("image_cleared")
            balance = await db.get_currency(uid, "coins")
            desc = (
                f"Welcome to the Pok√© Mart.\n\n"
                f"Use **Buy Menu** or **Sell Menu** to trade from the market list.\n"
                f"Your balance: **{balance:,} {PKDollar_NAME}**"
            )
            emb, files = _embed_with_image(city.get("name", area_id), desc, img)
            effective_city = city.get("parent_city") or area_id
            if state.get("last_city") != effective_city:
                state["last_city"] = effective_city
                await _save_adventure_state(str(itx.user.id), state)
            view = AdventurePokeMartView(itx.user.id, area_id, state)
        else:
            cleared = _city_is_cleared(state, area_id)
            # Sub-areas use sprite sheet regions; main cities use image_uncleared/image_cleared
            sprite_sheet = city.get("sprite_sheet")
            sprite_region = city.get("sprite_region")
            direct_image = city.get("image")
            used_sprite = False
            if sprite_sheet and sprite_region and isinstance(sprite_region, (list, tuple)) and len(sprite_region) >= 4:
                sheet_path = Path(sprite_sheet)
                if sheet_path.exists():
                    emb, files = _embed_with_sprite_region(
                        city.get("name", area_id),
                        "Choose your next action.",
                        sheet_path,
                        tuple(sprite_region[:4]),
                    )
                    used_sprite = True
            if not used_sprite:
                # Sub-areas: try direct image; main cities: use image_cleared/image_uncleared
                if direct_image and Path(direct_image).exists():
                    img = direct_image
                elif not city.get("parent_city"):
                    img = city.get("image_cleared") if cleared else city.get("image_uncleared")
                else:
                    img = sprite_sheet or city.get("image_uncleared")  # sub-area fallback
                desc = "You are in the city. Choose your next action."
                if not cleared and city.get("rival_battle"):
                    desc = "Your rival is waiting for a battle."
                emb, files = _embed_with_image(city.get("name", area_id), desc, img)
            # Track last visited city for blackout fallback (use parent_city for sub-areas)
            effective_city = city.get("parent_city") or area_id
            if state.get("last_city") != effective_city:
                state["last_city"] = effective_city
                await _save_adventure_state(str(itx.user.id), state)
            has_surf = await _team_has_surf(str(itx.user.id)) if not city.get("parent_city") else False
            view = AdventureCityView(itx.user.id, area_id, state, has_surf=has_surf)
    else:
        route = ADVENTURE_ROUTES.get(area_id, {})
        # route-22 is only added to cleared_routes when the path-1 blocker is defeated in _on_path, not here
        if area_id != "route-22" and _route_is_cleared(state, area_id) and area_id not in state.get("cleared_routes", []):
            state.setdefault("cleared_routes", []).append(area_id)
            await _save_adventure_state(str(itx.user.id), state)
        cleared = area_id in state.get("cleared_routes", [])
        # Route panel navigation state (used for Route 1 3-panel navigation)
        route_panels = state.setdefault("route_panels", {})
        rp = route_panels.get(area_id)
        is_maze = route.get("layout") == "maze"
        if is_maze:
            _maze_get_node(state, area_id, route)  # ensure node is initialized
            rp = route_panels.get(area_id) or {}
        elif not isinstance(rp, dict):
            rp = {"panel": 1, "pos": "start"}
            route_panels[area_id] = rp
        if not is_maze:
            try:
                rp["panel"] = max(1, min(int(rp.get("panel", 1)), 3))
            except Exception:
                rp["panel"] = 1
            rp["pos"] = rp.get("pos", "start")
            if rp["pos"] not in ("start", "end"):
                rp["pos"] = "start"
        # Route 22: four-stage images (rival not arrived ‚Üí rival arrived ‚Üí uncleared ‚Üí cleared)
        if area_id == "route-22":
            rival_id = route.get("rival_battle")
            if rival_id and rival_id not in state.get("rival_defeated", []):
                img = route.get("image_rival_not_arrived") or route.get("image_uncleared")
            elif not cleared:
                img = route.get("image_uncleared")
            else:
                img = route.get("image_cleared")
        else:
            img = route.get("image_cleared") if cleared else route.get("image_uncleared")
        # Maze routes use per-node images and exit buttons
        if is_maze:
            nodes = route.get("nodes") or {}
            node_id = _maze_get_node(state, area_id, route)
            node_cfg = nodes.get(node_id, {})
            maze_img = node_cfg.get("image") if isinstance(node_cfg, dict) else None
            img = maze_img if maze_img and Path(str(maze_img)).exists() else img
            desc = "Use the arrows to explore the forest. Moving may trigger an encounter. Use ‚öîÔ∏è Battle to force one."
            emb, files = _embed_with_image(route.get("name", area_id), desc, img)
            if route_move_item_message:
                emb.add_field(name="", value=route_move_item_message, inline=False)
        # Panel routes (route-1, route-2) use 3-panel navigation with Forward/Back
        else:
            panels = route.get("panels") or []
            has_panels = isinstance(panels, list) and len(panels) >= 3
            if has_panels:
                panel = _panel_get_panel(state, area_id)
                if roll_route1_item and area_id in _get_panel_routes():
                    route_move_item_message = await _roll_and_give_route_move_item_async(uid)
                if isinstance(panels, list) and len(panels) >= 3:
                    try:
                        img_panel = panels[max(0, min(panel - 1, len(panels) - 1))]
                    except Exception:
                        img_panel = img
                else:
                    img_panel = img
                num_panels = len(panels) if isinstance(panels, list) else 3
                desc = f"Use ‚¨ÜÔ∏è/‚¨áÔ∏è to walk through the route. (Panel {panel}/{num_panels})\nMoving may trigger an encounter. Use ‚öîÔ∏è Battle to force one."
                emb, files = _embed_with_image(route.get("name", area_id), desc, img_panel)
                if route_move_item_message:
                    emb.add_field(name="", value=route_move_item_message, inline=False)
            else:
                desc = "Choose a grass path to encounter Pok√©mon."
                emb, files = _embed_with_image(route.get("name", area_id), desc, img)
                if route_move_item_message:
                    emb.add_field(name="", value=route_move_item_message, inline=False)
        view = AdventureRouteView(itx.user.id, area_id, state)

    if is_component:
        if not itx.response.is_done():
            try:
                await _edit_with_files(itx.response.edit_message)
                try:
                    msg = await itx.original_response()
                except Exception:
                    msg = getattr(itx, "message", None)
            except Exception:
                msg = await _edit_with_files(itx.message.edit)
        else:
            try:
                msg = await _edit_with_files(itx.edit_original_response)
            except Exception:
                msg = await _edit_with_files(itx.message.edit)
    elif edit_original and not force_new_message:
        msg = await _edit_with_files(itx.edit_original_response)
    else:
        # Fresh slash command without editing original; send a normal (non-ephemeral) message
        msg = await itx.followup.send(embed=emb, files=files, view=view, ephemeral=False)
    if msg:
        LAST_PANEL_BY_USER[uid]["message_id"] = msg.id
        LAST_PANEL_BY_USER[uid]["channel_id"] = msg.channel.id
        LAST_PANEL_BY_USER[uid]["view"] = view
    if hatch_messages:
        for line in hatch_messages[:3]:
            try:
                await itx.followup.send(line, ephemeral=True)
            except Exception:
                pass

@bot.tree.command(name="adventure", description="Open your adventure panel.")
async def adventure_cmd(interaction: discord.Interaction):
    if not interaction.response.is_done():
        await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    user = await db.get_user(uid)
    if not user or not (user.get("starter") if isinstance(user, dict) else user["starter"]):
        return await interaction.followup.send("Use `/start` to begin your journey first.", ephemeral=False)
    state = await _get_adventure_state(uid)
    await _send_adventure_panel(interaction, state, edit_original=True)

@bot.tree.command(name="refresh", description="Re-send the last panel the bot sent you (adventure, battle, etc.).")
async def refresh_cmd(interaction: discord.Interaction):
    if not interaction.response.is_done():
        await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    last = LAST_PANEL_BY_USER.get(uid)
    if not last:
        user = await db.get_user(uid)
        if not user or not (user.get("starter") if isinstance(user, dict) else user["starter"]):
            return await interaction.followup.send("Use `/start` to begin your journey first.", ephemeral=False)
        state = await _get_adventure_state(uid)
        await _send_adventure_panel(interaction, state, edit_original=True)
        return
    panel_type = last.get("type")
    if panel_type == "adventure":
        state = last.get("state")
        if not state:
            state = await _get_adventure_state(uid)
        await _send_adventure_panel(interaction, state, edit_original=True)
        return
    if panel_type == "battle":
        await _cancel_previous_panel_for_user(interaction.client, uid)
        data = last.get("data") or {}
        room_id = data.get("room_id")
        if room_id is not None:
            from pvp.panel import send_battle_panel_refresh
            out = await send_battle_panel_refresh(interaction, room_id, int(interaction.user.id))
            if out is not None:
                msg, view = out if isinstance(out, tuple) and len(out) == 2 else (out, None)
                panel_data = {"room_id": room_id}
                if msg is not None:
                    panel_data["message_id"] = msg.id
                    panel_data["channel_id"] = msg.channel.id
                panel_data["view"] = view
                LAST_PANEL_BY_USER[uid] = {"type": "battle", "data": panel_data}
                return
        await interaction.followup.send("Battle not found or already ended. Opening adventure panel.", ephemeral=True)
        state = await _get_adventure_state(uid)
        await _send_adventure_panel(interaction, state, edit_original=True)
        return
    # Fallback: send adventure panel
    state = await _get_adventure_state(uid)
    await _send_adventure_panel(interaction, state, edit_original=True)

# Patch AdventureRouteView with Route1/mixin methods (mixin defined after the view)
for _attr in dir(_AdventureRouteViewRoute1Methods):
    if _attr.startswith("_on_") and not _attr.startswith("_on_timeout"):
        setattr(AdventureRouteView, _attr, getattr(_AdventureRouteViewRoute1Methods, _attr))

@bot.tree.command(name="route", description="Encounter a discovered Pok√©mon from a cleared route.")
@app_commands.describe(number="Route number (e.g., 1)")
async def route_cmd(interaction: discord.Interaction, number: int):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    route_id = f"route-{int(number)}"
    state = await _get_adventure_state(uid)
    if route_id not in state.get("cleared_routes", []) and not _route_is_cleared(state, route_id):
        return await interaction.followup.send("That route isn't cleared yet.", ephemeral=True)
    if _route_is_cleared(state, route_id) and route_id not in state.get("cleared_routes", []):
        state.setdefault("cleared_routes", []).append(route_id)
        await _save_adventure_state(uid, state)
    discovered = state.get("discovered", {}).get(route_id, [])
    if not discovered:
        return await interaction.followup.send("You haven't discovered any Pok√©mon on that route yet.", ephemeral=True)
    species = random.choice(discovered)
    sync_nature = await _wild_synchronize_nature(uid)
    wild_mon = await _build_mon_from_species(species, level=3, sync_nature=sync_nature)
    if not wild_mon:
        return await interaction.followup.send("Encounter failed to load.", ephemeral=True)
    won = await _start_pve_battle(interaction, [wild_mon], f"Wild {species.title()}")
    if won is _PVE_ALREADY_IN_BATTLE:
        return  # "You're already in a battle." was already sent
    if won is None:
        return await interaction.followup.send("Couldn't start the encounter battle. Please try again.", ephemeral=True)

def _tm_hm_item_to_move_name(item_id: str) -> Optional[str]:
    """Return move name for a TM/HM item_id (from GEN1_TMS/GEN1_HMS)."""
    item_id = (item_id or "").strip().lower()
    for iid, mname in GEN1_TMS:
        if (iid or "").strip().lower() == item_id:
            return mname
    for iid, mname in GEN1_HMS:
        if (iid or "").strip().lower() == item_id:
            return mname
    return None

class UseTMHMSelectView(discord.ui.View):
    """Select which TM/HM to use."""
    def __init__(self, author_id: int, uid: str, qty_by_id: Dict[str, int]):
        super().__init__(timeout=120)
        self.author_id = author_id
        self.uid = uid
        self.qty_by_id = qty_by_id
        options = []
        for item_id, move_name in GEN1_TMS + GEN1_HMS:
            q = qty_by_id.get(item_id, 0)
            if q <= 0:
                continue
            pre = "TM" if item_id.startswith("tm-") else "HM"
            num = item_id.replace("tm-", "").replace("hm-", "").zfill(2)
            options.append(discord.SelectOption(label=f"{pre}{num} {move_name}", value=item_id, description=f"√ó{q}" if q > 1 else "Use on a Pok√©mon"))
            if len(options) >= 25:
                break
        if options:
            sel = discord.ui.Select(placeholder="Use TM/HM on a Pok√©mon‚Ä¶", options=options, custom_id="tm_use:select")
            sel.callback = self._on_select
            self.add_item(sel)

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    async def _on_select(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        values = _itx_select_values(itx)
        if not values:
            return await itx.response.send_message("Pick a TM or HM.", ephemeral=True)
        item_id = values[0]
        move_name = _tm_hm_item_to_move_name(item_id)
        if not move_name:
            return await itx.response.send_message("Invalid TM/HM.", ephemeral=True)
        await itx.response.defer(ephemeral=True, thinking=False)
        gen = await _user_selected_gen(self.uid)
        team_can_learn = await _get_team_can_learn_move(self.uid, move_name, gen)
        if not team_can_learn:
            return await itx.followup.send("None of your team can learn this move (in your generation) or they already know it.", ephemeral=True)
        emb = discord.Embed(
            title=f"Teach {move_name}",
            description=f"Choose a Pok√©mon to teach **{move_name}** to. (Only Pok√©mon that can learn it are shown.)",
            color=0x5865F2,
        )
        for r in team_can_learn:
            name = f"Slot {r.get('team_slot', '?')} ‚Äî **{(r.get('species') or '?').title()}** Lv{r.get('level', '?')}"
            emb.add_field(name=name, value=f"ID #{r.get('id', '?')}", inline=True)
        view = UseTMHMPokemonView(self.author_id, self.uid, item_id, move_name, team_can_learn)
        await itx.followup.send(embed=emb, view=view, ephemeral=False)

class UseTMHMPokemonView(discord.ui.View):
    """Buttons for each Pok√©mon that can learn the selected move."""
    def __init__(self, author_id: int, uid: str, item_id: str, move_name: str, team_can_learn: List[Dict[str, Any]]):
        super().__init__(timeout=120)
        self.author_id = author_id
        self.uid = uid
        self.item_id = item_id
        self.move_name = move_name
        self.team_can_learn = team_can_learn
        self._handled = False
        for r in team_can_learn[:25]:
            mon_id = r.get("id")
            species = (r.get("species") or "?").title()
            level = r.get("level", "?")
            label = f"{species} Lv{level}"
            if len(label) > 80:
                label = label[:77] + "..."
            btn = discord.ui.Button(label=label, style=discord.ButtonStyle.secondary, custom_id=f"tm_use:mon:{item_id}:{mon_id}")
            btn.callback = self._on_mon
            self.add_item(btn)

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    async def _on_mon(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        if self._handled:
            return await itx.response.send_message("Already used.", ephemeral=True)
        cid = (itx.data or {}).get("custom_id", "")
        if not cid.startswith("tm_use:mon:"):
            return await itx.response.send_message("Invalid.", ephemeral=True)
        parts = cid.split(":", 3)
        if len(parts) < 4:
            return await itx.response.send_message("Invalid.", ephemeral=True)
        _, _, item_id, mon_id_str = parts[0], parts[1], parts[2], parts[3]
        try:
            mon_id = int(mon_id_str)
        except ValueError:
            return await itx.response.send_message("Invalid Pok√©mon.", ephemeral=True)
        entry = next((e for e in self.team_can_learn if e.get("id") == mon_id), None)
        if not entry:
            return await itx.response.send_message("Pok√©mon not in list.", ephemeral=True)
        await itx.response.defer(ephemeral=True, thinking=False)
        species = (entry.get("species") or "?").title()
        try:
            async with db.session() as conn:
                cur = await conn.execute("SELECT moves FROM pokemons WHERE owner_id=? AND id=?", (self.uid, mon_id))
                row = await cur.fetchone()
                await cur.close()
            if not row:
                return await itx.followup.send("Pok√©mon not found.", ephemeral=False)
            moves_raw = row.get("moves")
            if isinstance(moves_raw, str):
                try:
                    moves_raw = json.loads(moves_raw)
                except Exception:
                    moves_raw = []
            if not isinstance(moves_raw, (list, tuple)):
                moves_raw = []
            current = [str(m).strip() for m in moves_raw[:4]]
            while len(current) < 4:
                current.append("")
            replaced = False
            for i in range(4):
                if not (current[i] or "").strip():
                    current[i] = self.move_name
                    replaced = True
                    break
            if not replaced:
                current[3] = self.move_name
            await _set_pokemon_moves(self.uid, mon_id, current[:4])
            is_tm = (item_id or "").lower().startswith("tm-")
            if is_tm:
                await db.give_item(self.uid, item_id, -1)
            self._handled = True
            for item in self.children:
                item.disabled = True
            try:
                await itx.message.edit(view=self)
            except Exception:
                pass
            await itx.followup.send(f"‚úÖ Taught **{self.move_name}** to **{species}**!{' (TM used.)' if is_tm else ''}", ephemeral=True)
        except Exception as e:
            await itx.followup.send(f"Failed to teach move: {e}", ephemeral=False)

@bot.tree.command(name="tm_machine", description="TM Machine ‚Äî View your TMs (consumable) and HMs (permanent).")
async def tm_machine_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    qty_by_id: Dict[str, int] = {}
    if db_cache is not None:
        try:
            cached = db_cache.get_cached_tm_machine(uid)
            if cached is not None:
                for row in cached:
                    iid = str(row.get("item_id") or "").strip()
                    if iid:
                        qty_by_id[iid] = int(row.get("qty") or 0)
        except Exception:
            pass
    if not qty_by_id:
        try:
            async with db.session() as conn:
                cur = await conn.execute(
                    "SELECT item_id, qty FROM user_items WHERE owner_id = ? AND (item_id LIKE 'tm-%' OR item_id LIKE 'hm-%')",
                    (uid,),
                )
                rows = await cur.fetchall()
                await cur.close()
            for row in rows or []:
                iid = str(row.get("item_id", "") or "").strip()
                if iid:
                    qty_by_id[iid] = int(row.get("qty") or 0)
            if db_cache is not None:
                try:
                    db_cache.set_cached_tm_machine(uid, [{"item_id": iid, "qty": q} for iid, q in qty_by_id.items()])
                except Exception:
                    pass
        except Exception:
            pass
    tm_lines: List[str] = []
    for item_id, move_name in GEN1_TMS:
        q = qty_by_id.get(item_id, 0)
        if q > 0:
            num = item_id.replace("tm-", "").zfill(2)
            tm_lines.append(f"**TM{num}** {move_name} √ó {q}")
    hm_lines: List[str] = []
    for item_id, move_name in GEN1_HMS:
        q = qty_by_id.get(item_id, 0)
        if q > 0:
            num = item_id.replace("hm-", "").zfill(2)
            hm_lines.append(f"**HM{num}** {move_name} ‚úì (permanent)")
    fragment_q = qty_by_id.get(TM_FRAGMENT_ITEM_ID, 0)
    if not tm_lines and not hm_lines:
        msg = "You have no TMs or HMs."
        if fragment_q > 0:
            msg += f"\n\nYou have **{fragment_q}** TM Fragment(s) ‚Äî exchange them at the TM Seller."
        return await interaction.followup.send(msg, ephemeral=True)
    emb = discord.Embed(title="Your TM Machine", description="TMs are **consumable** (single use). HMs are **permanent**.", color=0x5865F2)
    if tm_lines:
        emb.add_field(name="TMs (consumable)", value="\n".join(tm_lines), inline=False)
    else:
        emb.add_field(name="TMs (consumable)", value="*None*", inline=False)
    if hm_lines:
        emb.add_field(name="HMs (permanent)", value="\n".join(hm_lines), inline=False)
    else:
        emb.add_field(name="HMs (permanent)", value="*None*", inline=False)
    if fragment_q > 0:
        emb.add_field(name="TM Fragment", value=f"You have **{fragment_q}** TM Fragment(s). (Rare finds from the field ‚Äî exchange at the TM Seller.)", inline=False)
    view = UseTMHMSelectView(interaction.user.id, uid, qty_by_id) if any(qty_by_id.get(iid, 0) > 0 for iid, _ in GEN1_TMS + GEN1_HMS) else None
    send_kwargs: Dict[str, Any] = {"embed": emb, "ephemeral": True}
    if view is not None:
        send_kwargs["view"] = view
    await interaction.followup.send(**send_kwargs)

@bot.tree.command(name="start", description="Begin your journey with Professor Oak.")
@app_commands.guild_only()
async def start_cmd(interaction: discord.Interaction):
    # Defer early to avoid "Unknown interaction" if processing exceeds 3s
    try:
        if not interaction.response.is_done():
            await interaction.response.defer(ephemeral=True, thinking=False)
    except Exception:
        pass

    uid = str(interaction.user.id)

    # Ensure there is a users row + user_rulesets(gen=1) for the player.
    try:
        await _ensure_user_in_gen1(uid)
    except Exception as e:
        return await interaction.response.send_message(f"Init error: {e}", ephemeral=True)

    # Check if they already started (have a starter OR any stored Pok√©mon).
    try:
        existing = await db.get_user(uid)
    except Exception as e:
        return await interaction.response.send_message(f"DB error: {e}", ephemeral=True)

    has_starter = False
    if existing:
        row = dict(existing) if not isinstance(existing, dict) else existing
        try:
            if hasattr(db, "has_starter"):
                has_starter = await db.has_starter(uid)
            else:
                has_starter = bool(row.get("starter"))
        except Exception:
            has_starter = bool(row.get("starter"))

    has_any_mon = False
    conn = await db.connect()
    try:
        cur = await conn.execute("SELECT 1 FROM pokemons WHERE owner_id=? LIMIT 1", (uid,))
        has_any_mon = bool(await cur.fetchone())
        await cur.close()
    except Exception:
        pass
    finally:
        try:
            await conn.close()
        except Exception:
            pass

    if has_starter or has_any_mon:
        try:
            if not interaction.response.is_done():
                return await interaction.response.send_message(
                    "‚ùå You already started your journey. Use `/profile` to view your Pok√©mon!",
                    ephemeral=True
                )
            else:
                return await interaction.followup.send(
                    "‚ùå You already started your journey. Use `/profile` to view your Pok√©mon!",
                    ephemeral=True
                )
        except Exception:
            return

    # Not started yet ‚Üí ALWAYS show Oak intro (gender + Yes/No)
    emb = discord.Embed(title="Welcome Trainer to Kanto")
    emb.description = (
        f"Hello, I am **Professor Oak** and you must be **{interaction.user.display_name}**!\n"
        "Welcome to the world of pokemon where you can encounter, catch, train, "
        "and most importantly create bonds with your future partners!\n\n"
        "Less about me‚Äîlet‚Äôs talk about you. Are you a girl or a boy?"
    )
    emb.set_thumbnail(url=OAK_IMAGE_URL)

    try:
        if not interaction.response.is_done():
            await interaction.response.send_message(
                embed=emb,
                view=OakIntroView(interaction.user.id),
                ephemeral=True
            )
        else:
            await interaction.followup.send(
                embed=emb,
                view=OakIntroView(interaction.user.id),
                ephemeral=True
            )
    except Exception:
        try:
            await interaction.followup.send(
                embed=emb,
                view=OakIntroView(interaction.user.id),
                ephemeral=True
            )
        except Exception:
            pass
@bot.tree.command(name="profile", description="Show your saved profile.")
async def profile_slash(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    user = None
    async with db.session() as conn:
        cur = await conn.execute("SELECT * FROM users WHERE user_id = ? LIMIT 1", (uid,))
        row = await cur.fetchone()
        await cur.close()
        if row:
            user = dict(row)
            user["coins"] = db.get_currency_from_row(user, "coins")

    if not user:
        return await interaction.followup.send(
            "No profile yet. Use `/start` first.",
            ephemeral=True
        )

    embed = discord.Embed(title=f"{interaction.user.display_name}'s Profile")
    embed.add_field(name="User ID", value=user["user_id"], inline=False)
    embed.add_field(name="Created at (UTC)", value=user["created_at"], inline=False)
    embed.add_field(name="Starter", value=user["starter"] or "Not chosen", inline=True)
    embed.add_field(name="Pok√©Dollars", value=f"{int(user.get('coins') or 0):,} {PKDollar_NAME}", inline=True)
    await interaction.followup.send(embed=embed, ephemeral=True)


@bot.tree.command(name="wallet", description="Show your wallet and currencies.")
async def wallet_slash(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    u = await db.get_user(uid)
    if not u:
        return await interaction.followup.send("No wallet yet. Use `/start` first.", ephemeral=True)
    currencies = u.get("currencies") or {}
    user = interaction.user
    avatar_url = user.display_avatar.url if getattr(user, "display_avatar", None) else (user.avatar.url if user.avatar else None)

    emb = discord.Embed(title="Wallet", colour=discord.Colour.blurple())
    emb.set_author(name=user.display_name, icon_url=avatar_url)
    # Currency list from currencies JSON (add more currencies later)
    emb.add_field(
        name="\u200b",
        value=f"{COIN} **{int(currencies.get('coins', 0)):,}** {PKDollar_NAME}",
        inline=False,
    )
    # Optional: add more currency lines here, e.g. for key in currencies if key != 'coins'

    await interaction.followup.send(embed=emb, ephemeral=True)

async def _ruleset_gen(conn, guild: discord.Guild | None) -> int:
    """Pick generation from rulesets table, preferring guild scope, else global, else 6."""
    if db_cache:
        rules = db_cache.get_cached_rulesets()
        if rules:
            if guild:
                for r in rules:
                    if str(r.get("scope") or "") == f"guild:{guild.id}":
                        return int(r.get("generation") or 6)
            for r in rules:
                if str(r.get("scope") or "").lower() == "global":
                    return int(r.get("generation") or 6)
    try:
        if guild:
            cur = await conn.execute("SELECT generation FROM rulesets WHERE scope = ? LIMIT 1", (f"guild:{guild.id}",))
            row = await cur.fetchone(); await cur.close()
            if row: return int(row["generation"])
        cur = await conn.execute("SELECT generation FROM rulesets WHERE scope = 'global' LIMIT 1")
        row = await cur.fetchone(); await cur.close()
        if row: return int(row["generation"])
    except Exception:
        pass
    return 6  # default baseline
def _gender_icon(g: str | None) -> str:
    if not g: return ""
    g = g.lower()
    return "‚ôÇÔ∏è" if g == "male" else ("‚ôÄÔ∏è" if g == "female" else "")
def pretty_item_name(name_or_id: str) -> str:
    try:
        return pretty_item(name_or_id)  # you already defined pretty_item elsewhere
    except Exception:
        import re
        s = re.sub(r"[_\-]+", " ", str(name_or_id)).strip().title()
        return s

SPRITES_DIR = Path(__file__).resolve().parent / "pvp" / "_common" / "sprites"

def _species_folder_name(species: str) -> str:
    """Normalize folder name to match on-disk layout."""
    s = str(species or "").strip().lower()
    s = s.replace(" ", "-").replace("_", "-")
    return s

def pokemon_sprite_attachment(
    species: str,
    *,
    shiny: bool = False,
    gender: Optional[str] = None,
) -> Tuple[Optional[str], Optional[discord.File]]:
    """
    Returns (attachment_url, discord.File) for the best local FRONT sprite, or (None, None)
    if nothing is found.

    Rules:
      - Use female sprite ONLY if gender == 'female'; else normal.
      - Use shiny sprite ONLY if shiny is True; else non-shiny.
      - Prefer animated GIFs over static PNGs.
      - If female sprite missing, fall back to normal sprite set.
      - If shiny sprite missing, fall back to non-shiny.
      - Last resort: icon.png if present.
    """
    folder = SPRITES_DIR / _species_folder_name(species)
    if not folder.is_dir():
        return None, None

    def _exists(name: str) -> Optional[Path]:
        p = folder / name
        try:
            return p if p.exists() and p.stat().st_size > 0 else None
        except Exception:
            return None

    is_female = (str(gender or "").strip().lower() == "female")

    candidates: List[str] = []
    if is_female:
        if shiny:
            candidates += ["female-animated-shiny-front.gif", "female-shiny-front.png"]
        candidates += ["female-animated-front.gif", "female-front.png"]

    if shiny:
        candidates += ["animated-shiny-front.gif", "shiny-front.png"]
    candidates += ["animated-front.gif", "front.png", "icon.png"]  # icon last

    for fname in candidates:
        fp = _exists(fname)
        if fp:
            # Use an attachment:// URL so Embed thumbnail can reference the file
            return f"attachment://{fp.name}", discord.File(fp, filename=fp.name)

    return None, None


def attach_sprite_to_embed(
    emb: discord.Embed,
    *,
    species: str,
    shiny: bool,
    gender: Optional[str],
    form_key: Optional[str] = None,
) -> List[discord.File]:
    """
    Convenience wrapper for mpokeinfo (and others).
    Sets embed thumbnail and returns a list of files to pass to send().
    If form_key is provided, looks for sprites in {species}-{form_key}/ folder.
    """
    files: List[discord.File] = []
    # If form_key is provided, determine the correct folder name
    if form_key:
        sp_norm = str(species or "").strip().lower()
        fk_norm = str(form_key or "").strip().lower().replace(" ", "-").replace("_", "-")
        
        # Special-case: Greninja Ash/Battle Bond normalization
        if sp_norm == "greninja" and ("ash" in fk_norm or "battle" in fk_norm or "bond" in fk_norm):
            fk_norm = "battle-bond"
        
        # Special-case: Missing n0 forms - normalize species name first
        if sp_norm == "missing n0" or sp_norm == "missing-n0":
            sp_norm = "missing-n0"  # Normalize to hyphenated version
            if fk_norm in ["n1", "n2", "n3", "n4", "n5"]:
                lookup_species = f"{sp_norm}-{fk_norm}"
            else:
                lookup_species = sp_norm
        # If form_key already contains the species name (e.g., "shaymin-sky"), use it as-is
        # Otherwise, prepend species (e.g., species="shaymin", form_key="land" ‚Üí "shaymin-land")
        elif fk_norm.startswith(f"{sp_norm}-"):
            lookup_species = fk_norm
        else:
            lookup_species = f"{sp_norm}-{fk_norm}"
    else:
        # Normalize Missing n0 species name
        sp_norm = str(species or "").strip().lower()
        if sp_norm == "missing n0" or sp_norm == "missing-n0":
            lookup_species = "missing-n0"
        else:
            lookup_species = species
    att_url, att_file = pokemon_sprite_attachment(species=lookup_species, shiny=shiny, gender=gender)
    if att_file:
        emb.set_thumbnail(url=att_url)
        files.append(att_file)
    return files
PRIVATE_EMOJI_GUILD_ID = globals().get("DEV_GUILD_ID", None)

def _normalize_stats_keys(stats: dict) -> dict:
    """
    Normalize stat keys to use atk/def/spa/spd/spe instead of attack/defense/special-attack/etc.
    """
    if not isinstance(stats, dict):
        return {}
    
    key_map = {
        "hp": "hp",
        "attack": "atk",
        "atk": "atk",
        "defense": "def",
        "def": "def",
        "special-attack": "spa",
        "special_attack": "spa",
        "spa": "spa",
        "special-defense": "spd",
        "special_defense": "spd",
        "spd": "spd",
        "speed": "spe",
        "spe": "spe"
    }
    
    normalized = {}
    for k, v in stats.items():
        norm_key = key_map.get(str(k).lower().replace("_", "-"), k)
        normalized[norm_key] = v
    return normalized

# === Form Selection View for /pokeinfo ===
class PokeInfoFormView(discord.ui.View):
    """Interactive form selection buttons for /pokeinfo"""
    def __init__(self, species_id: int, species_name: str, available_forms: List[dict], 
                 current_form: Optional[str], shiny: bool, gender: Optional[str], gen: Optional[int]):
        super().__init__(timeout=300)  # 5 minute timeout
        self.species_id = species_id
        self.species_name = species_name
        self.available_forms = available_forms
        self.current_form = current_form
        self.shiny = shiny
        self.gender = gender
        self.gen = gen
        
        # Add buttons for each form (max 25 buttons, 5 per row)
        for i, form_data in enumerate(available_forms[:25]):
            is_current = (form_data['form_key'] == current_form) if current_form else (form_data['form_key'] is None)
            button = discord.ui.Button(
                label=form_data['display_name'],
                style=discord.ButtonStyle.primary if is_current else discord.ButtonStyle.secondary,
                row=i // 5,  # 5 buttons per row
                custom_id=f"piform_{form_data['form_key'] or 'base'}"
            )
            button.callback = self._make_callback(form_data['form_key'])
            self.add_item(button)
    
    def _make_callback(self, form_key: Optional[str]):
        async def callback(interaction: discord.Interaction):
            # Re-run pokeinfo with the selected form
            await interaction.response.defer()
            # Build the command to simulate clicking the form
            form_param = form_key if form_key else ""
            # Redirect to pokeinfo command - we'll need to call it programmatically
            # For now, just send a message
            await interaction.followup.send(
                f"üîÑ Use `/pokeinfo name_or_id:{self.species_name} form:{form_key or 'base'}` to see this form!",
                ephemeral=True
            )
        return callback


class _MPokeInfoFlipView(discord.ui.View):
    """Front/back flip button for /mypokeinfo when a mon is registered."""
    def __init__(
        self,
        cog: "MPokeInfo",
        *,
        owner_user_id: int,
        mon: dict,
        species: str,
        level: int,
        shiny: bool,
        gender: str,
        current_form: Optional[str],
        types: List[str],
        exp_to_next_val: Optional[int],
        friendship_value: int,
        is_locked: bool,
        hp_max: int,
        stats_obj: dict,
        ivs_map: dict,
        evs_map: dict,
        moves: list[str],
        register_profile: dict,
    ):
        super().__init__(timeout=300)
        self.cog = cog
        self.owner_user_id = int(owner_user_id)
        self.mon = dict(mon or {})
        self.species = str(species or "")
        self.level = int(level or 1)
        self.shiny = bool(shiny)
        self.gender = str(gender or "")
        self.current_form = current_form
        self.types = list(types or [])
        self.exp_to_next_val = exp_to_next_val
        self.friendship_value = int(friendship_value or 0)
        self.is_locked = bool(is_locked)
        self.hp_max = int(hp_max or 1)
        self.stats_obj = dict(stats_obj or {})
        self.ivs_map = dict(ivs_map or {})
        self.evs_map = dict(evs_map or {})
        self.moves = list(moves or [])
        self.register_profile = dict(register_profile or {})
        self.showing_back = False

    async def _front_file(self, interaction: discord.Interaction) -> Optional[discord.File]:
        return await self.cog._render_mpokeinfo_panel(
            interaction,
            self.mon,
            species=self.species,
            level=self.level,
            shiny=self.shiny,
            gender=self.gender,
            current_form=self.current_form,
            types=self.types,
            exp_to_next_val=self.exp_to_next_val,
            friendship_value=self.friendship_value,
            is_locked=self.is_locked,
            hp_max=self.hp_max,
            stats_obj=self.stats_obj,
            ivs_map=self.ivs_map,
            evs_map=self.evs_map,
            moves=self.moves,
            use_back_sprite=False,
            is_registered=True,
        )

    async def _back_file(self, interaction: discord.Interaction) -> Optional[discord.File]:
        return await self.cog._render_register_panel(
            interaction,
            self.mon,
            profile=self.register_profile,
            species=self.species,
            level=self.level,
            shiny=self.shiny,
            gender=self.gender,
            current_form=self.current_form,
            types=self.types,
            use_back_sprite=True,
            is_registered=True,
        )

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.owner_user_id:
            try:
                if interaction.response.is_done():
                    await interaction.followup.send("Only the command user can flip this card.", ephemeral=True)
                else:
                    await interaction.response.send_message("Only the command user can flip this card.", ephemeral=True)
            except Exception:
                pass
            return False
        return True

    @discord.ui.button(label="Back", style=discord.ButtonStyle.secondary)
    async def flip(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await interaction.response.defer()
        except Exception:
            pass
        target_back = not self.showing_back
        file: Optional[discord.File] = None
        try:
            file = await (self._back_file(interaction) if target_back else self._front_file(interaction))
            if file is None:
                await interaction.followup.send("Could not render that panel.", ephemeral=True)
                return
            self.showing_back = target_back
            button.label = "Front" if self.showing_back else "Back"
            button.style = discord.ButtonStyle.primary if self.showing_back else discord.ButtonStyle.secondary
            await interaction.edit_original_response(attachments=[file], view=self)
        except Exception:
            try:
                await interaction.followup.send("Could not update panel.", ephemeral=True)
            except Exception:
                pass
        finally:
            if file is not None:
                try:
                    file.close()
                except Exception:
                    pass

    async def on_timeout(self) -> None:
        try:
            for item in self.children:
                if isinstance(item, discord.ui.Button):
                    item.disabled = True
        except Exception:
            pass


class _ConfirmDeclineView(discord.ui.View):
    def __init__(
        self,
        *,
        owner_user_id: int,
        confirm_label: str = "Confirm",
        decline_label: str = "Decline",
        timeout: float = 90.0,
    ):
        super().__init__(timeout=timeout)
        self.owner_user_id = int(owner_user_id)
        self.choice: Optional[bool] = None
        confirm_btn = discord.ui.Button(label=str(confirm_label), style=discord.ButtonStyle.success)
        decline_btn = discord.ui.Button(label=str(decline_label), style=discord.ButtonStyle.danger)
        confirm_btn.callback = self._on_confirm
        decline_btn.callback = self._on_decline
        self.add_item(confirm_btn)
        self.add_item(decline_btn)

    def _disable_all(self) -> None:
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                child.disabled = True

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.owner_user_id:
            try:
                if interaction.response.is_done():
                    await interaction.followup.send("Only the command user can choose this.", ephemeral=True)
                else:
                    await interaction.response.send_message("Only the command user can choose this.", ephemeral=True)
            except Exception:
                pass
            return False
        return True

    async def _on_confirm(self, interaction: discord.Interaction) -> None:
        self.choice = True
        self._disable_all()
        try:
            if interaction.response.is_done():
                await interaction.message.edit(view=self)  # type: ignore[union-attr]
            else:
                await interaction.response.edit_message(view=self)
        except Exception:
            try:
                await interaction.response.defer()
            except Exception:
                pass
        self.stop()

    async def _on_decline(self, interaction: discord.Interaction) -> None:
        self.choice = False
        self._disable_all()
        try:
            if interaction.response.is_done():
                await interaction.message.edit(view=self)  # type: ignore[union-attr]
            else:
                await interaction.response.edit_message(view=self)
        except Exception:
            try:
                await interaction.response.defer()
            except Exception:
                pass
        self.stop()

    async def on_timeout(self) -> None:
        self._disable_all()


class MPokeInfo(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        # local sprites location (adjust if yours differs)
        self.sprites_base = Path(__file__).resolve().parent / "pvp" / "_common" / "sprites"

    # --------------------- tiny utils ---------------------
    @staticmethod
    def _as_mapping(x: Any) -> dict:
        if isinstance(x, Mapping): return dict(x)
        if isinstance(x, dict):    return x
        if isinstance(x, str):
            try:
                v = json.loads(x)
                return v if isinstance(v, dict) else {}
            except Exception:
                return {}
        return {}

    @staticmethod
    def _as_dict(x: Any) -> dict:
        if isinstance(x, dict): return x
        if isinstance(x, str):
            try:
                v = json.loads(x)
                return v if isinstance(v, dict) else {}
            except Exception:
                return {}
        return {}

    @staticmethod
    def _as_list(x: Any) -> list:
        if isinstance(x, list): return x
        if isinstance(x, str):
            try:
                v = json.loads(x)
                if isinstance(v, list):
                    return v
            except Exception:
                pass
            return [p.strip() for p in x.split(",") if p.strip()]
        return []

    @staticmethod
    def _species_folder_name(species: str) -> str:
        return str(species or "").strip().lower().replace(" ", "-").replace("_", "-")

    @staticmethod
    def _gender_icon_local(g: Optional[str]) -> str:
        g = (g or "").lower()
        return "‚ôÇÔ∏è" if g in {"male", "m", "‚ôÇ"} else "‚ôÄÔ∏è" if g in {"female", "f", "‚ôÄ"} else "‚àÖ" if g in {"genderless", "none", "unknown"} else ""

    def _pick_sprite_file(self, species: str, gender: Optional[str], shiny: bool, form: Optional[str] = None) -> Optional[discord.File]:
        """
        Load a sprite file for the given Pokemon species and form.
        Returns a discord.File object or None if not found.
        """
        # Build the folder name
        if form:
            # If form already includes species name (e.g., "kyurem-white"), use as-is
            # Otherwise prepend species (e.g., "meloetta" + "aria" ‚Üí "meloetta-aria")
            if form.startswith(f"{species}-"):
                folder_name = form
            else:
                folder_name = f"{species}-{form}"
        else:
            folder_name = species
        
        folder_name = self._species_folder_name(folder_name)
        folder = self.sprites_base / folder_name
        
        if not folder.is_dir():
            return None
        
        # Priority order for sprite files
        is_female = (str(gender or "").strip().lower() == "female")
        candidates: List[str] = []
        
        if is_female:
            if shiny:
                candidates += ["female-animated-shiny-front.gif", "female-shiny-front.png"]
            candidates += ["female-animated-front.gif", "female-front.png"]
        
        if shiny:
            candidates += ["animated-shiny-front.gif", "shiny-front.png"]
        candidates += ["animated-front.gif", "front.png", "icon.png"]
        
        for fname in candidates:
            fp = folder / fname
            try:
                if fp.exists() and fp.stat().st_size > 0:
                    return discord.File(fp, filename=fp.name)
            except Exception:
                continue
        
        return None

    # --------------------- emoji helpers ---------------------
    @staticmethod
    def _emoji_by_name(guild: Optional[discord.Guild], name: Optional[str]) -> str:
        """Find a custom emoji by (approx) name in a guild."""
        if not guild or not name:
            return ""
        base = name.lower()
        variants = {base, base.replace("-", ""), base.replace("-", " "), base.split("-")[0]}
        try:
            for e in guild.emojis:
                if e.name.lower() in variants:
                    return str(e)  # <:name:id>
        except Exception:
            pass
        return ""

    async def _get_emoji_global(self, guild: Optional[discord.Guild], key: Optional[str]) -> str:
        """
        General emoji getter:
        1) Items table (items.emoji) by id or name match
        2) Current guild custom emoji by name
        3) PRIVATE_EMOJI_GUILD_ID custom emoji by name (if set)
        """
        if not key:
            return ""
        name = str(key).lower()

        # 1) DB items.emoji
        try:
            db_mod = globals().get("db")
            if db_mod:
                conn = await db_mod.connect()
                # try id then name
                cur = await conn.execute(
                    "SELECT emoji FROM items WHERE LOWER(id)=? OR LOWER(name)=? LIMIT 1",
                    (name, name.title())
                )
                row = await cur.fetchone(); await cur.close()
                if row and row.get("emoji"):
                    raw = str(row["emoji"])
                    # <a:name:123> / <:name:123>
                    m = re.search(r":(\d+)>$", raw)
                    if m:
                        if guild and (em := guild.get_emoji(int(m.group(1)))):
                            return str(em)
                        # private guild
                        if PRIVATE_EMOJI_GUILD_ID:
                            g2 = self.bot.get_guild(int(PRIVATE_EMOJI_GUILD_ID))
                            if g2 and (em2 := g2.get_emoji(int(m.group(1)))):
                                return str(em2)
                    if raw.isdigit():
                        # stored as just the emoji id
                        if guild and (em := guild.get_emoji(int(raw))):
                            return str(em)
                        if PRIVATE_EMOJI_GUILD_ID:
                            g2 = self.bot.get_guild(int(PRIVATE_EMOJI_GUILD_ID))
                            if g2 and (em2 := g2.get_emoji(int(raw))):
                                return str(em2)
                    if raw.startswith("<") and raw.endswith(">"):
                        return raw  # already a full emoji tag
                    # try by name
                    emn = self._emoji_by_name(guild, raw) or (
                        self._emoji_by_name(self.bot.get_guild(int(PRIVATE_EMOJI_GUILD_ID)), raw)
                        if PRIVATE_EMOJI_GUILD_ID else ""
                    )
                    if emn:
                        return emn
        except Exception:
            pass

        # 2) Current guild by name
        em = self._emoji_by_name(guild, name)
        if em:
            return em

        # 3) Private emoji guild by name
        if PRIVATE_EMOJI_GUILD_ID:
            g2 = self.bot.get_guild(int(PRIVATE_EMOJI_GUILD_ID))
            em = self._emoji_by_name(g2, name)
            if em:
                return em

        return ""

    async def _label_with_emoji(self, guild: Optional[discord.Guild], key: Optional[str]) -> str:
        """For Ball/Held Item fields: 'üü† Pok√© Ball' if emoji found, else 'pokeball'."""
        if not key:
            return "‚Äî"
        em = await self._get_emoji_global(guild, key)
        nice = str(key).replace("_", " ").replace("-", " ").title()
        return f"{em} {nice}" if em else nice

    # --------------------- types / stats helpers ---------------------
    async def _extract_types(self, species: str, mon: dict, dex: Optional[dict]) -> List[str]:
        def _extract_token(v: Any) -> Optional[str]:
            if v is None:
                return None
            if isinstance(v, Mapping):
                if isinstance(v.get("type"), Mapping):
                    tn = str(v.get("type", {}).get("name") or "").strip()
                    if tn:
                        return tn
                for k in ("name", "type_name", "type", "value"):
                    vv = v.get(k)
                    if isinstance(vv, Mapping):
                        nn = str(vv.get("name") or "").strip()
                        if nn:
                            return nn
                    elif vv not in (None, ""):
                        s = str(vv).strip()
                        if s:
                            return s
                return None
            s = str(v).strip()
            if not s:
                return None
            if s.startswith("{") and s.endswith("}"):
                try:
                    parsed = json.loads(s)
                    return _extract_token(parsed)
                except Exception:
                    m = re.search(r"""['"]name['"]\s*:\s*['"]([^'"]+)['"]""", s)
                    if m:
                        return str(m.group(1) or "").strip()
                    return None
            s = s.strip("[](){}")
            if (s.startswith("'") and s.endswith("'")) or (s.startswith('"') and s.endswith('"')):
                s = s[1:-1].strip()
            if s.lower().startswith("type="):
                s = s.split("=", 1)[1].strip()
            return s

        def _norm_list(x: Any) -> list[str]:
            if x is None:
                return []
            if isinstance(x, Mapping):
                nested_types = x.get("types")
                if nested_types is not None:
                    return _norm_list(nested_types)
                pairs = [
                    x.get("type1") or x.get("type_1"),
                    x.get("type2") or x.get("type_2"),
                    x.get("primary_type"),
                    x.get("secondary_type"),
                    x.get("primary"),
                    x.get("secondary"),
                    x.get("first_type"),
                    x.get("second_type"),
                    x.get("main_type"),
                    x.get("sub_type"),
                    x.get("0"),
                    x.get("1"),
                    x.get(0),  # type: ignore[index]
                    x.get(1),  # type: ignore[index]
                ]
                if any(pairs):
                    return _norm_list(pairs)
                keyed_vals: list[Any] = []
                for k, vv in x.items():
                    kk = str(k or "").strip().lower().replace("-", "_")
                    if kk in {
                        "0", "1", "2", "primary", "secondary", "first", "second",
                        "type1", "type2", "type_1", "type_2", "primary_type", "secondary_type",
                        "first_type", "second_type", "main_type", "sub_type",
                    } or "type" in kk:
                        keyed_vals.append(vv)
                if keyed_vals:
                    parsed = _norm_list(keyed_vals)
                    if parsed:
                        return parsed
                tok = _extract_token(x)
                return [tok] if tok else []
            if isinstance(x, (list, tuple, set)):
                seq = list(x)
            elif isinstance(x, str):
                try:
                    parsed = json.loads(x)
                    if parsed is not None and parsed is not x:
                        return _norm_list(parsed)
                except Exception:
                    pass
                seq = [p.strip() for p in re.split(r"[,/|]", x) if p.strip()]
            else:
                seq = [x]
            out: list[str] = []
            seen: set[str] = set()
            for t in seq:
                tok = _extract_token(t)
                if tok is None:
                    continue
                key = tok.strip().lower().replace("_", "-")
                if not key or key in {"none", "unknown"}:
                    continue
                if key not in seen:
                    seen.add(key)
                    out.append(key)
            return out

        def _fmt_types(li: list[str]) -> list[str]:
            return [s.replace("_", " ").replace("-", " ").title() for s in li[:2]]

        best: list[str] = []

        def _consider(cand: Any) -> None:
            nonlocal best
            if cand is None:
                return
            li = _norm_list(cand)
            if not li:
                return
            li = li[:2]
            if len(li) > len(best):
                best = li

        # 1) Prefer dex (pokedex / ensure_species) as source of truth for fixed info.
        # Keep scanning instead of returning early so a single-type stale field
        # doesn't override a valid dual-type candidate from another source.
        d = self._as_mapping(dex) if dex else {}
        for cand in (
            d.get("types"),
            d.get("typing"),
            [d.get("type1") or d.get("type_1"), d.get("type2") or d.get("type_2")] if (d.get("type1") or d.get("type_1") or d.get("type2") or d.get("type_2")) else None,
            [d.get("primary_type"), d.get("secondary_type")] if (d.get("primary_type") or d.get("secondary_type")) else None,
            (d.get("species") or {}).get("types") if isinstance(d.get("species"), dict) else None,
            mon.get("types") if isinstance(mon, Mapping) else None,
            [mon.get("type1"), mon.get("type2"), mon.get("primary_type"), mon.get("secondary_type")] if isinstance(mon, Mapping) else None,
            d.get("type"),
            mon.get("type") if isinstance(mon, Mapping) else None,
        ):
            _consider(cand)
        if len(best) >= 2:
            return _fmt_types(best)

        # 2) Zero-DB fallback: static cache is usually warmed at startup.
        if db_cache:
            species_key = str(species or "").strip().lower()
            cache_keys = {
                species_key,
                species_key.replace(" ", "-"),
                species_key.replace("-", " "),
                species_key.replace("_", "-"),
                species_key.replace("-", "_"),
            }
            for ck in cache_keys:
                entry = db_cache.get_cached_pokedex(ck)
                if not isinstance(entry, Mapping):
                    continue
                _consider(entry.get("types"))
                _consider([entry.get("type1"), entry.get("type2"), entry.get("primary_type"), entry.get("secondary_type")])
            if len(best) >= 2:
                return _fmt_types(best)

        # 3) DB fallback by species.
        try:
            db_mod = globals().get("db")
            if db_mod:
                pokedex_row = await db_mod.get_pokedex_by_name(species.lower())
                if pokedex_row:
                    _consider(pokedex_row.get("types"))
                # Direct query fallback (pokedex has types JSONB only)
                conn = await db_mod.connect()
                try:
                    cur = await conn.execute(
                        "SELECT types FROM pokedex WHERE LOWER(name)=? LIMIT 1",
                        (species.lower(),)
                    )
                    row = await cur.fetchone()
                    await cur.close()
                    if row and row.get("types"):
                        _consider(row.get("types"))
                finally:
                    await conn.close()
        except Exception:
            pass

        # 4) Last fallback: re-fetch canonical species payload.
        if len(best) < 2:
            try:
                ref = await ensure_species_and_learnsets(species)
                if isinstance(ref, Mapping):
                    _consider(ref.get("types"))
                    _consider([ref.get("type1"), ref.get("type2"), ref.get("primary_type"), ref.get("secondary_type")])
            except Exception:
                pass

        return _fmt_types(best) if best else []

    def _pick_sprite_file(self, species: str, gender: str, shiny: bool, form: Optional[str] = None) -> Optional[discord.File]:
        # Try form-specific folder first, then fall back to base species
        folder_name = self._species_folder_name(species)
        if form and form != "normal":
            # Try form-specific folder (e.g., "rotom-heat", "deoxys-attack")
            form_folder = self.sprites_base / f"{folder_name}-{form}"
            if form_folder.is_dir():
                folder = form_folder
            else:
                folder = self.sprites_base / folder_name
        else:
            folder = self.sprites_base / folder_name

        def exists(name: str) -> Optional[Path]:
            p = folder / name
            try:
                return p if p.exists() and p.stat().st_size > 0 else None
            except Exception:
                return None

        g_norm = str(gender or "").strip().lower()
        is_female = g_norm in {"female", "f", "‚ôÄ"}
        cand: List[str] = []
        if is_female:
            if shiny: cand += ["female-animated-shiny-front.gif", "female-shiny-front.png"]
            cand += ["female-animated-front.gif", "female-front.png"]
        if shiny: cand += ["animated-shiny-front.gif", "shiny-front.png"]
        cand += ["animated-front.gif", "front.png", "icon.png"]

        for fname in cand:
            fp = exists(fname)
            if fp:
                if str(fp.suffix or "").lower() == ".gif":
                    try:
                        with Image.open(str(fp)) as g:
                            if not bool(getattr(g, "is_animated", False)) or int(getattr(g, "n_frames", 1) or 1) <= 1:
                                continue
                    except Exception:
                        continue
                return discord.File(fp, filename=fp.name)
        return None

    @staticmethod
    def _format_ot(bot: commands.Bot, owner_id: Optional[str]) -> str:
        if not owner_id:
            return "‚Äî"
        try:
            uid = int(owner_id)
        except Exception:
            return f"<@{owner_id}>"
        u = bot.get_user(uid)
        return u.mention if u else f"<@{uid}>"

    @staticmethod
    def _mpokeinfo_text_width(draw, text: str, font) -> int:
        try:
            box = draw.textbbox((0, 0), str(text or ""), font=font)
            return max(0, int(box[2] - box[0]))
        except Exception:
            try:
                return int(draw.textlength(str(text or ""), font=font))
            except Exception:
                return len(str(text or "")) * 6

    @staticmethod
    def _mpokeinfo_draw_shadow_text(
        draw,
        xy: tuple[int, int],
        text: str,
        *,
        font,
        fill: tuple[int, int, int, int] = (236, 244, 248, 255),
        shadow: tuple[int, int, int, int] = (0, 0, 0, 220),
        shadow_offset: tuple[int, int] = (1, 1),
    ) -> None:
        txt = str(text or "")
        if not txt or font is None:
            return
        x, y = int(xy[0]), int(xy[1])
        sx, sy = int(shadow_offset[0]), int(shadow_offset[1])
        try:
            draw.text((x + sx, y + sy), txt, font=font, fill=shadow)
            draw.text((x, y), txt, font=font, fill=fill)
        except Exception:
            pass

    def _mpokeinfo_font(self, size: int, *, bold: bool = False):
        size = max(6, int(size))
        team_font_fn = globals().get("_team_font")
        if callable(team_font_fn):
            try:
                f = team_font_fn(size, bold=bold)
                if f is not None:
                    return f
            except Exception:
                pass
        try:
            from PIL import ImageFont  # type: ignore
        except Exception:
            return None
        candidates = [
            "/usr/share/fonts/truetype/dejavu/DejaVuSansMono-Bold.ttf" if bold else "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf",
            "/usr/share/fonts/truetype/jetbrains-mono/JetBrainsMono-Bold.ttf" if bold else "/usr/share/fonts/truetype/jetbrains-mono/JetBrainsMono-Regular.ttf",
            "/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf" if bold else "/usr/share/fonts/truetype/liberation/LiberationMono-Regular.ttf",
            "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf" if bold else "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
            "/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf" if bold else "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
        ]
        for fp in candidates:
            try:
                return ImageFont.truetype(fp, size)
            except Exception:
                continue
        try:
            return ImageFont.load_default()
        except Exception:
            return None

    def _mpokeinfo_fit_font(self, draw, text: str, *, max_width: int, start_size: int, min_size: int = 8, bold: bool = False):
        for size in range(int(start_size), int(min_size) - 1, -1):
            f = self._mpokeinfo_font(size, bold=bold)
            if f is None:
                continue
            if self._mpokeinfo_text_width(draw, text, f) <= int(max_width):
                return f
        return self._mpokeinfo_font(max(8, int(min_size)), bold=bold)

    def _pick_sprite_path(self, species: str, gender: str, shiny: bool, form: Optional[str] = None, *, back: bool = False) -> Optional[Path]:
        base_species = self._species_folder_name(species)
        form_norm = self._species_folder_name(form or "")
        folder_candidates: List[Path] = []
        if form_norm and form_norm not in ("normal", "base", "default"):
            if form_norm.startswith(f"{base_species}-"):
                folder_candidates.append(self.sprites_base / form_norm)
            else:
                folder_candidates.append(self.sprites_base / f"{base_species}-{form_norm}")
        folder_candidates.append(self.sprites_base / base_species)

        g_norm = str(gender or "").strip().lower()
        is_female = g_norm in {"female", "f", "‚ôÄ"}
        filenames: List[str] = []
        side = "back" if bool(back) else "front"
        if is_female:
            if shiny:
                filenames += [f"female-animated-shiny-{side}.gif", f"female-shiny-{side}.png"]
            filenames += [f"female-animated-{side}.gif", f"female-{side}.png"]
        if shiny:
            filenames += [f"animated-shiny-{side}.gif", f"shiny-{side}.png"]
        filenames += [f"animated-{side}.gif", f"{side}.png"]
        # If back sprite doesn't exist, gracefully fall back to front/icon.
        if bool(back):
            if is_female:
                if shiny:
                    filenames += ["female-animated-shiny-front.gif", "female-shiny-front.png"]
                filenames += ["female-animated-front.gif", "female-front.png"]
            if shiny:
                filenames += ["animated-shiny-front.gif", "shiny-front.png"]
            filenames += ["animated-front.gif", "front.png"]
        filenames += ["icon.png"]

        for folder in folder_candidates:
            try:
                if not folder.is_dir():
                    continue
            except Exception:
                continue
            for fname in filenames:
                p = folder / fname
                try:
                    if p.exists() and p.is_file() and p.stat().st_size > 0:
                        if str(p.suffix or "").lower() == ".gif":
                            try:
                                with Image.open(str(p)) as g:
                                    if not bool(getattr(g, "is_animated", False)) or int(getattr(g, "n_frames", 1) or 1) <= 1:
                                        continue
                            except Exception:
                                continue
                        return p
                except Exception:
                    continue
        return None

    @staticmethod
    def _held_item_icon_path(item_id: Optional[str]) -> Optional[Path]:
        raw = str(item_id or "").strip().lower()
        if not raw:
            return None
        candidates: list[str] = []
        for c in (
            raw,
            raw.replace(" ", "_"),
            raw.replace(" ", "-"),
            raw.replace("-", "_"),
            raw.replace("_", "-"),
        ):
            c2 = str(c or "").strip().lower()
            if c2 and c2 not in candidates:
                candidates.append(c2)
        for c in candidates:
            p = ITEM_ICON_DIR / f"{c}.png"
            try:
                if p.exists() and p.is_file() and p.stat().st_size > 0:
                    return p
            except Exception:
                continue
        return None

    @staticmethod
    def _pokeball_icon_path(ball_id: Optional[str]) -> Optional[Path]:
        """Resolve a Pok√© Ball icon path from stored ball id/name."""
        canonical = _normalize_ball_item_id(ball_id)
        candidates: list[str] = []
        for c in (
            canonical,
            canonical + "_ball" if canonical and not canonical.endswith("_ball") else "",
            canonical.replace("_", "-"),
            canonical.replace("_", " "),
            canonical.replace("_ball", "") if canonical.endswith("_ball") else "",
            "poke_ball" if canonical in {"pokeball", "poke_ball", "pok_ball"} else "",
        ):
            c2 = str(c or "").strip().lower()
            if c2 and c2 not in candidates:
                candidates.append(c2)
        for c in candidates:
            p = MPokeInfo._held_item_icon_path(c)
            if p is not None:
                return p
        return MPokeInfo._held_item_icon_path("poke_ball")

    @staticmethod
    def _mpokeinfo_type_badge_path(type_name: Optional[str]) -> Optional[Path]:
        raw = str(type_name or "").strip().lower()
        if not raw:
            return None
        base_dir = Path(__file__).resolve().parent
        candidate_dirs = [
            # Preferred runtime location requested by user.
            base_dir / "pvp" / "_common" / "types",
            Path("/home/container/pvp/_common/types"),
            # Legacy fallback.
            ASSETS_DIR / "ui" / "mypokeinfo-types",
        ]
        norm = raw.replace(" ", "_").replace("-", "_")
        aliases = [norm]
        if norm == "???":
            aliases.append("unknown")
        if norm == "none":
            aliases.append("unknown")
        for d in candidate_dirs:
            for key in aliases:
                p = d / f"{key}.png"
                try:
                    if p.exists() and p.is_file() and p.stat().st_size > 0:
                        return p
                except Exception:
                    continue
        return None

    async def _render_mpokeinfo_panel(
        self,
        interaction: Interaction,
        mon: dict,
        *,
        species: str,
        level: int,
        shiny: bool,
        gender: str,
        current_form: Optional[str],
        types: list[str],
        exp_to_next_val: Optional[int],
        friendship_value: int,
        is_locked: bool,
        hp_max: int,
        stats_obj: dict,
        ivs_map: dict,
        evs_map: dict,
        moves: list[str],
        use_back_sprite: bool = False,
        is_registered: bool = False,
    ) -> Optional[discord.File]:
        if Image is None:
            return None
        try:
            from PIL import ImageDraw, ImageSequence  # type: ignore
        except Exception:
            return None

        panel_path = ASSETS_DIR / "ui" / "mpokeinfo.png"
        if not panel_path.exists():
            return None
        try:
            with Image.open(str(panel_path)) as src:
                base = src.convert("RGBA")
        except Exception:
            return None

        try:
            resample = Image.Resampling.NEAREST
        except Exception:
            resample = Image.NEAREST

        w, h = base.size
        sx = float(w) / 400.0
        sy = float(h) / 300.0
        scale = min(sx, sy)
        if bool(is_registered):
            theme_fill = (255, 116, 116, 255)
            theme_shadow = (92, 20, 20, 220)
        elif bool(shiny):
            theme_fill = (255, 224, 118, 255)
            theme_shadow = (98, 74, 24, 220)
        else:
            theme_fill = (236, 244, 248, 255)
            theme_shadow = (0, 0, 0, 220)

        cache_payload = {
            "panel": "mpokeinfo-front-v3",
            "mon_id": int(mon.get("id") or 0),
            "species": str(species or "").strip().lower(),
            "level": int(level or 1),
            "shiny": int(bool(shiny)),
            "gender": str(gender or "").strip().lower(),
            "form": str(current_form or "").strip().lower(),
            "types": [str(t or "").strip().lower() for t in list(types or [])[:2]],
            "exp_to_next": None if exp_to_next_val is None else int(exp_to_next_val),
            "friendship": int(friendship_value or 0),
            "locked": int(bool(is_locked)),
            "hp_max": int(hp_max or 1),
            "hp_now": int(mon.get("hp_now") or 0),
            "nature": str(mon.get("nature") or ""),
            "ability": str(mon.get("ability") or ""),
            "held_item": str(mon.get("held_item") or ""),
            "pokeball": str(mon.get("pokeball") or ""),
            "nickname": str(mon.get("nickname") or ""),
            "moves": [str(m or "").strip().lower() for m in list(moves or [])[:4]],
            "ivs": dict(ivs_map or {}),
            "evs": dict(evs_map or {}),
            "stats": dict(stats_obj or {}),
            "use_back_sprite": int(bool(use_back_sprite)),
            "registered_theme": int(bool(is_registered)),
            "ot_name": str(getattr(interaction.user, "display_name", "") or ""),
        }
        cache_raw = json.dumps(cache_payload, ensure_ascii=True, sort_keys=True, separators=(",", ":"), default=str)
        cache_key = hashlib.sha1(cache_raw.encode("utf-8")).hexdigest()
        cached_render = _binary_render_cache_get(
            _MPOKEINFO_RENDER_CACHE,
            cache_key,
            ttl_seconds=MPOKEINFO_RENDER_CACHE_TTL_SECONDS,
        )
        if cached_render is not None:
            cached_data, cached_ext = cached_render
            cached_filename = f"mpokeinfo_{int(mon.get('id') or 0)}.{cached_ext}"
            return discord.File(fp=BytesIO(cached_data), filename=cached_filename)

        def _pt(x: int, y: int) -> tuple[int, int]:
            return int(round(x * sx)), int(round(y * sy))

        def _clip_text(text: str, font, max_width: int) -> str:
            t = str(text or "").strip()
            if not t or font is None:
                return t
            if self._mpokeinfo_text_width(draw_probe, t, font) <= int(max_width):
                return t
            suffix = "..."
            if self._mpokeinfo_text_width(draw_probe, suffix, font) > int(max_width):
                return ""
            lo, hi = 0, len(t)
            best = suffix
            while lo <= hi:
                mid = (lo + hi) // 2
                cand = f"{t[:mid].rstrip()}{suffix}"
                if self._mpokeinfo_text_width(draw_probe, cand, font) <= int(max_width):
                    best = cand
                    lo = mid + 1
                else:
                    hi = mid - 1
            return best

        # Use a probe draw so we can fit/clip text cleanly.
        draw_probe = ImageDraw.Draw(base)

        # Load sprite frames first so we can emit animated GIF output when possible.
        sprite_frames: list[Any] = []
        sprite_duration_ms = 95
        sprite_frame_durations: list[int] = []
        species_norm_for_anim = _daycare_norm_species(species)
        sprite_frame_limit = 192 if species_norm_for_anim == "eevee" else 128
        sprite_path = self._pick_sprite_path(species, gender, shiny, current_form, back=bool(use_back_sprite))
        if sprite_path is not None:
            try:
                with Image.open(str(sprite_path)) as src:
                    is_anim = bool(getattr(src, "is_animated", False))
                    if is_anim:
                        try:
                            d = int(src.info.get("duration") or 95)
                            sprite_duration_ms = max(55, min(160, d))
                        except Exception:
                            sprite_duration_ms = 95
                        for i, fr in enumerate(ImageSequence.Iterator(src)):
                            if i >= int(sprite_frame_limit):
                                break
                            try:
                                sprite_frames.append(fr.copy().convert("RGBA"))
                            except Exception:
                                sprite_frames.append(fr.convert("RGBA"))
                            try:
                                fd = int(fr.info.get("duration") or 0)
                            except Exception:
                                fd = 0
                            if fd <= 0:
                                try:
                                    fd = int(src.info.get("duration") or 0)
                                except Exception:
                                    fd = 0
                            if fd <= 0:
                                fd = sprite_duration_ms
                            if species_norm_for_anim == "eevee":
                                fd = max(90, min(260, int(fd)))
                            else:
                                fd = max(70, min(220, int(fd)))
                            sprite_frame_durations.append(int(fd))
                    else:
                        sprite_frames = [src.convert("RGBA")]
            except Exception:
                sprite_frames = []

        if sprite_frames:
            union_bbox = None
            for fr in sprite_frames:
                try:
                    bb = fr.split()[-1].getbbox()
                except Exception:
                    bb = None
                if bb is None:
                    continue
                if union_bbox is None:
                    union_bbox = bb
                else:
                    union_bbox = (
                        min(union_bbox[0], bb[0]),
                        min(union_bbox[1], bb[1]),
                        max(union_bbox[2], bb[2]),
                        max(union_bbox[3], bb[3]),
                    )
            processed_frames: list[Any] = []
            max_sw = max(16, int(round(84 * sx)))
            max_sh = max(16, int(round(76 * sy)))
            for fr in sprite_frames:
                sprite = fr
                if union_bbox is not None:
                    try:
                        crop = fr.crop(union_bbox)
                        if crop.size[0] > 0 and crop.size[1] > 0:
                            sprite = crop
                    except Exception:
                        pass
                try:
                    sprite.thumbnail((max_sw, max_sh), resample=resample)
                except Exception:
                    pass
                processed_frames.append(sprite)
            sprite_frames = processed_frames

        # Draw all static text/icons onto a base panel once.
        panel_static = base.copy()
        draw = ImageDraw.Draw(panel_static)
        font_stats = self._mpokeinfo_font(max(8, int(round(11 * scale))), bold=True)
        right_box_left = _pt(266, 0)[0]
        right_box_w = max(26, int(round(108 * sx)))

        def _draw_centered_in_box(
            text: str,
            font,
            *,
            left: int,
            y: int,
            width: int,
            height: Optional[int] = None,
            fill: tuple[int, int, int, int] = theme_fill,
            shadow: tuple[int, int, int, int] = theme_shadow,
        ) -> str:
            txt = _clip_text(text, font, max(8, int(width)))
            if not txt or font is None:
                return txt
            tw = self._mpokeinfo_text_width(draw_probe, txt, font)
            tx = int(left + max(0, ((int(width) - tw) // 2)))
            ty = int(y)
            if height is not None:
                try:
                    tb = draw_probe.textbbox((0, 0), txt, font=font)
                    th = max(1, int(tb[3] - tb[1]))
                except Exception:
                    th = max(8, int(round(9 * scale)))
                ty = int(y + max(0, (int(height) - th) // 2 - 1))
            self._mpokeinfo_draw_shadow_text(draw, (tx, ty), txt, font=font, fill=fill, shadow=shadow)
            return txt

        def _clear_row(
            *,
            left: int,
            top: int,
            width: int,
            height: int,
            fill: tuple[int, int, int, int] = (28, 36, 46, 235),
        ) -> None:
            x0 = int(left + max(1, int(round(1 * sx))))
            y0 = int(top + max(1, int(round(1 * sy))))
            x1 = int(left + width - max(1, int(round(1 * sx))))
            y1 = int(top + height - max(1, int(round(1 * sy))))
            if x1 <= x0 or y1 <= y0:
                return
            try:
                draw.rectangle((x0, y0, x1, y1), fill=fill)
            except Exception:
                pass

        # --- top row / summary ---
        ot_name = str(getattr(interaction.user, "display_name", None) or interaction.user.name or "Trainer").strip()
        ot_name = re.sub(r"\s+", " ", ot_name)
        # Template already has the OT label art/text; render only the trainer name
        # in the dedicated name sub-area so it doesn't stack over the label.
        ot_box_left, ot_box_y = _pt(106, 15)
        ot_box_w = max(26, int(round(74 * sx)))
        ot_box_h = max(10, int(round(13 * sy)))
        ot_font = self._mpokeinfo_fit_font(
            draw_probe,
            ot_name,
            max_width=ot_box_w,
            start_size=max(8, int(round(9 * scale))),
            min_size=max(6, int(round(6 * scale))),
            bold=True,
        )
        _draw_centered_in_box(ot_name, ot_font, left=ot_box_left, y=ot_box_y, width=ot_box_w, height=ot_box_h)

        lv_line = f"{int(level)}"
        lv_box_left, lv_box_y = _pt(202, 13)
        lv_box_w = max(22, int(round(56 * sx)))
        lv_box_h = max(10, int(round(13 * sy)))
        gender_key = str(gender or "").strip().lower()
        gender_symbol = {
            "male": "‚ôÇ", "m": "‚ôÇ", "‚ôÇ": "‚ôÇ",
            "female": "‚ôÄ", "f": "‚ôÄ", "‚ôÄ": "‚ôÄ",
            "genderless": "‚àÖ", "none": "‚àÖ", "unknown": "‚àÖ",
        }.get(gender_key)
        lv_font = self._mpokeinfo_fit_font(
            draw_probe,
            lv_line,
            max_width=max(12, int(lv_box_w)),
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=True,
        )
        lv_line = _clip_text(lv_line, lv_font, max(12, int(lv_box_w)))
        try:
            lvb = draw_probe.textbbox((0, 0), lv_line, font=lv_font)
            lv_h = max(1, int(lvb[3] - lvb[1]))
        except Exception:
            lv_h = max(8, int(round(9 * sy)))
        lv_w = self._mpokeinfo_text_width(draw_probe, lv_line, lv_font)

        gender_font = None
        gfill = theme_fill
        gw = 0
        gh = max(8, int(round(9 * sy)))
        if gender_symbol:
            try:
                from PIL import ImageFont  # type: ignore
                gender_font = ImageFont.truetype(
                    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                    max(8, int(round(10 * scale))),
                )
            except Exception:
                gender_font = self._mpokeinfo_font(max(8, int(round(10 * scale))), bold=True)
            gw = self._mpokeinfo_text_width(draw_probe, gender_symbol, gender_font)
            try:
                gb = draw_probe.textbbox((0, 0), gender_symbol, font=gender_font)
                gh = max(1, int(gb[3] - gb[1]))
            except Exception:
                gh = max(8, int(round(9 * sy)))

        gap = max(1, int(round(2 * sx))) if gender_symbol else 0
        group_w = int(lv_w + (gap + gw if gender_symbol else 0))
        group_x = int(lv_box_left + max(0, ((lv_box_w - group_w) // 2)))
        lv_nudge_x = max(4, int(round(8 * sx)))
        lv_y = int(lv_box_y + max(0, ((lv_box_h - lv_h) // 2) - 1))
        self._mpokeinfo_draw_shadow_text(
            draw,
            (group_x + lv_nudge_x, lv_y),
            lv_line,
            font=lv_font,
            fill=theme_fill,
            shadow=theme_shadow,
        )
        if gender_symbol and gender_font is not None:
            gender_nudge_x = max(2, int(round(4 * sx)))
            gx = int(group_x + lv_nudge_x + lv_w + gap + gender_nudge_x)
            gender_nudge_y = -max(1, int(round(1 * sy)))
            gy = int(lv_box_y + max(0, ((lv_box_h - gh) // 2) - 1 + gender_nudge_y))
            self._mpokeinfo_draw_shadow_text(
                draw,
                (gx, gy),
                gender_symbol,
                font=gender_font,
                fill=gfill,
                shadow=theme_shadow,
            )

        type_tokens = [str(t or "").strip() for t in list(types or []) if str(t or "").strip()]
        if not type_tokens:
            type_tokens = ["Normal"]
        badge_left, badge_top = _pt(198, 31)
        badge_w = max(24, int(round(63 * sx)))
        badge_h = max(10, int(round(13 * sy)))
        badge_gap = max(1, int(round(2 * sy)))
        for i, tok in enumerate(type_tokens[:2]):
            row_y = int(badge_top + (i * (badge_h + badge_gap)))
            icon_path = self._mpokeinfo_type_badge_path(tok)
            if icon_path is not None:
                try:
                    with Image.open(str(icon_path)) as src:
                        icon = src.convert("RGBA")
                    icon.thumbnail((badge_w, badge_h), resample=resample)
                    icon_x = int(badge_left + max(0, (badge_w - icon.width) // 2))
                    icon_y = int(row_y + max(0, (badge_h - icon.height) // 2))
                    panel_static.alpha_composite(icon, dest=(icon_x, icon_y))
                    continue
                except Exception:
                    pass
            # Per-row fallback so missing one badge does not hide dual typing.
            fallback_type = str(tok).upper()
            try:
                draw.rectangle(
                    (badge_left, row_y, badge_left + badge_w, row_y + badge_h),
                    fill=(160, 168, 181, 205),
                    outline=(188, 198, 214, 228),
                    width=max(1, int(round(1 * scale))),
                )
            except Exception:
                pass
            type_font = self._mpokeinfo_fit_font(
                draw_probe,
                fallback_type,
                max_width=max(18, badge_w - 4),
                start_size=max(8, int(round(9 * scale))),
                min_size=max(7, int(round(8 * scale))),
                bold=True,
            )
            fallback_type = _clip_text(fallback_type, type_font, max(18, badge_w - 4))
            type_w = self._mpokeinfo_text_width(draw_probe, fallback_type, type_font)
            type_x = int(badge_left + ((badge_w - type_w) // 2))
            type_y = int(row_y + max(0, (badge_h - int(round(9 * scale))) // 2) - 1)
            self._mpokeinfo_draw_shadow_text(
                draw,
                (type_x, type_y),
                fallback_type,
                font=type_font,
                fill=theme_fill,
                shadow=theme_shadow,
            )

        nature_text = str(mon.get("nature") or "Hardy").replace("-", " ").replace("_", " ").title()
        nature_font = self._mpokeinfo_fit_font(
            draw_probe,
            nature_text,
            max_width=right_box_w,
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=False,
        )
        right_row_h = max(11, int(round(15 * sy)))
        _draw_centered_in_box(
            nature_text,
            nature_font,
            left=right_box_left,
            y=_pt(0, 32)[1],
            width=right_box_w,
            height=right_row_h,
        )

        exp_text = "MAX" if exp_to_next_val is None else f"{int(exp_to_next_val):,}"
        exp_font = self._mpokeinfo_fit_font(
            draw_probe,
            exp_text,
            max_width=right_box_w,
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=True,
        )
        _draw_centered_in_box(
            exp_text,
            exp_font,
            left=right_box_left,
            y=_pt(0, 63)[1],
            width=right_box_w,
            height=right_row_h,
        )

        fr_val = max(0, min(255, int(friendship_value or 0)))
        fr_text = str(fr_val)
        fr_font = self._mpokeinfo_fit_font(
            draw_probe,
            fr_text,
            max_width=right_box_w,
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=True,
        )
        _draw_centered_in_box(
            fr_text,
            fr_font,
            left=right_box_left,
            y=_pt(0, 94)[1],
            width=right_box_w,
            height=right_row_h,
        )

        species_display = str(species or "").replace("-", " ").replace("_", " ").title() or "Unknown"
        if current_form and str(current_form).strip().lower() not in {"", "normal", "base", "default"}:
            ftitle = str(current_form).replace("-", " ").replace("_", " ").title()
            if ftitle and ftitle.lower() not in species_display.lower():
                species_display = f"{species_display} ({ftitle})"
        pokemon_font = self._mpokeinfo_fit_font(
            draw_probe,
            species_display,
            max_width=right_box_w,
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=False,
        )
        species_display = _draw_centered_in_box(
            species_display,
            pokemon_font,
            left=right_box_left,
            y=_pt(0, 124)[1],
            width=right_box_w,
            height=right_row_h,
        )

        # --- main sprite region ---
        nickname = str(mon.get("nickname") or species_display).strip() or species_display
        nick_box_left, nick_box_y = _pt(86, 132)
        nick_max_w = max(28, int(round(136 * sx)))
        if bool(is_locked):
            lx, ly = _pt(82, 132)
            lock_w = max(7, int(round(8 * sx)))
            lock_h = max(8, int(round(9 * sy)))
            shackle_h = max(3, int(round(lock_h * 0.45)))
            body_top = int(ly + shackle_h)
            body_bottom = int(ly + lock_h)
            body_right = int(lx + lock_w)
            try:
                draw.rounded_rectangle(
                    (lx, body_top, body_right, body_bottom),
                    radius=max(1, int(round(1 * scale))),
                    fill=(246, 197, 77, 248),
                    outline=(84, 54, 10, 255),
                    width=1,
                )
            except Exception:
                draw.rectangle((lx, body_top, body_right, body_bottom), fill=(246, 197, 77, 248), outline=(84, 54, 10, 255), width=1)
            sh_l = int(lx + max(1, int(round(1 * sx))))
            sh_r = int(body_right - max(1, int(round(1 * sx))))
            sh_b = int(body_top + max(1, int(round(shackle_h * 0.75))))
            try:
                draw.arc((sh_l, ly, sh_r, sh_b), 180, 360, fill=(255, 236, 176, 255), width=1)
            except Exception:
                pass
            key_x = int(lx + (lock_w // 2))
            key_y0 = int(body_top + max(1, int(round(1 * sy))))
            key_y1 = int(body_bottom - max(2, int(round(2 * sy))))
            try:
                draw.line((key_x, key_y0, key_x, key_y1), fill=(84, 54, 10, 255), width=1)
                draw.point((key_x, key_y1 + 1), fill=(84, 54, 10, 255))
            except Exception:
                pass
            nick_box_left = int(nick_box_left + max(8, int(round(10 * sx))))
            nick_max_w = max(20, int(nick_max_w - max(8, int(round(10 * sx)))))
        nick_font = self._mpokeinfo_fit_font(
            draw_probe,
            nickname,
            max_width=nick_max_w,
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=True,
        )
        _draw_centered_in_box(
            nickname,
            nick_font,
            left=nick_box_left,
            y=nick_box_y,
            width=nick_max_w,
        )

        def _draw_front_shiny_stars(target_img: Any) -> None:
            if not shiny:
                return
            try:
                draw_star = ImageDraw.Draw(target_img)
            except Exception:
                return
            try:
                from PIL import ImageFont  # type: ignore
                star_font = ImageFont.truetype(
                    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                    max(10, int(round(14 * scale))),
                )
                side_star_font = ImageFont.truetype(
                    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                    max(8, int(round(10 * scale))),
                )
            except Exception:
                star_font = self._mpokeinfo_font(max(10, int(round(14 * scale))), bold=True)
                side_star_font = self._mpokeinfo_font(max(8, int(round(10 * scale))), bold=True)
            self._mpokeinfo_draw_shadow_text(
                draw_star,
                _pt(98, 79),
                "‚òÖ",
                font=star_font,
                fill=(255, 110, 132, 255),
                shadow=(88, 20, 26, 220),
            )
            self._mpokeinfo_draw_shadow_text(
                draw_star,
                _pt(112, 69),
                "‚òÖ",
                font=side_star_font,
                fill=(255, 110, 132, 255),
                shadow=(88, 20, 26, 220),
            )

        ball_raw = str(mon.get("pokeball") or "poke_ball").strip().lower()
        ball_icon = self._pokeball_icon_path(ball_raw)
        if ball_icon is not None:
            try:
                with Image.open(str(ball_icon)) as src:
                    icon = src.convert("RGBA")
                try:
                    bb = icon.split()[-1].getbbox()
                    if bb is not None:
                        cropped = icon.crop(bb)
                        if cropped.size[0] > 0 and cropped.size[1] > 0:
                            icon = cropped
                except Exception:
                    pass
                icon.thumbnail((max(12, int(round(22 * sx))), max(12, int(round(22 * sy)))), resample=resample)
                ix, iy = _pt(86, 38)
                panel_static.alpha_composite(icon, dest=(int(ix), int(iy)))
            except Exception:
                pass

        held_item_raw = str(mon.get("held_item") or "").strip().lower()
        held_icon = self._held_item_icon_path(held_item_raw)
        if held_icon is not None:
            try:
                with Image.open(str(held_icon)) as src:
                    icon = src.convert("RGBA")
                icon.thumbnail((max(10, int(round(20 * sx))), max(10, int(round(20 * sy)))), resample=resample)
                panel_static.alpha_composite(icon, dest=_pt(229, 73))
            except Exception:
                pass

        # --- moves / ability / item ---
        moves_clean = [str(m).replace("-", " ").replace("_", " ").title() for m in list(moves or []) if str(m).strip()]
        if not moves_clean:
            moves_clean = ["‚Äî"]
        move_start_x, move_start_y = _pt(86, 162)
        move_box_w = max(24, int(round(138 * sx)))
        move_box_bottom = _pt(0, 222)[1]
        move_count = max(1, min(4, len(moves_clean)))
        usable_h = max(12, move_box_bottom - move_start_y)
        move_line_h = max(10, usable_h // move_count)
        for idx, mv in enumerate(moves_clean[:4]):
            y = int(move_start_y + (idx * move_line_h))
            mv_font = self._mpokeinfo_fit_font(
                draw_probe,
                mv,
                max_width=move_box_w,
                start_size=max(8, int(round(9 * scale))),
                min_size=max(7, int(round(7 * scale))),
                bold=False,
            )
            mv = _clip_text(mv, mv_font, move_box_w)
            self._mpokeinfo_draw_shadow_text(draw, (move_start_x, y), mv, font=mv_font, fill=theme_fill, shadow=theme_shadow)

        ability_text = str(mon.get("ability") or "Unknown").replace("-", " ").replace("_", " ").title() or "Unknown"
        ability_font = self._mpokeinfo_fit_font(
            draw_probe,
            ability_text,
            max_width=max(24, int(round(136 * sx))),
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=False,
        )
        ability_text = _clip_text(ability_text, ability_font, max(24, int(round(136 * sx))))
        ability_center_x = _pt(156, 0)[0]
        ability_y = _pt(0, 238)[1]
        ability_w = self._mpokeinfo_text_width(draw_probe, ability_text, ability_font)
        self._mpokeinfo_draw_shadow_text(
            draw,
            (ability_center_x - (ability_w // 2), ability_y),
            ability_text,
            font=ability_font,
            fill=theme_fill,
            shadow=theme_shadow,
        )

        item_text = pretty_item_name(held_item_raw) if held_item_raw else "None"
        item_font = self._mpokeinfo_fit_font(
            draw_probe,
            item_text,
            max_width=max(24, int(round(136 * sx))),
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=False,
        )
        item_text = _clip_text(item_text, item_font, max(24, int(round(136 * sx))))
        item_center_x = _pt(156, 0)[0]
        item_y = _pt(0, 272)[1]
        item_w = self._mpokeinfo_text_width(draw_probe, item_text, item_font)
        self._mpokeinfo_draw_shadow_text(
            draw,
            (item_center_x - (item_w // 2), item_y),
            item_text,
            font=item_font,
            fill=theme_fill,
            shadow=theme_shadow,
        )

        # --- stats table ---
        def _as_stat_map(v: Any) -> dict[str, Any]:
            if isinstance(v, Mapping):
                d = dict(v)
            elif isinstance(v, str):
                try:
                    parsed = json.loads(v)
                    if isinstance(parsed, Mapping):
                        d = dict(parsed)
                    elif isinstance(parsed, list):
                        d = {str(i): parsed[i] for i in range(min(6, len(parsed)))}
                    else:
                        d = {}
                except Exception:
                    d = {}
            elif isinstance(v, (list, tuple)):
                seq = list(v)
                d = {str(i): seq[i] for i in range(min(6, len(seq)))}
            else:
                d = {}
            # Normalize legacy numeric keys into stat aliases.
            if "hp" not in d and "0" in d:
                d["hp"] = d.get("0")
            if "atk" not in d and "1" in d:
                d["atk"] = d.get("1")
            if "def" not in d and "2" in d:
                d["def"] = d.get("2")
            if "spa" not in d and "3" in d:
                d["spa"] = d.get("3")
            if "spd" not in d and "4" in d:
                d["spd"] = d.get("4")
            if "spe" not in d and "5" in d:
                d["spe"] = d.get("5")
            # Common prefixed key styles used by legacy rows / migrations.
            pref_aliases = {
                "hp": ("ev_hp", "hp_ev", "iv_hp", "hp_iv"),
                "atk": ("ev_atk", "atk_ev", "iv_atk", "atk_iv", "ev_attack", "attack_ev", "iv_attack", "attack_iv"),
                "def": ("ev_def", "def_ev", "iv_def", "def_iv", "ev_defense", "defense_ev", "iv_defense", "defense_iv", "ev_defn", "defn_ev", "iv_defn", "defn_iv"),
                "spa": ("ev_spa", "spa_ev", "iv_spa", "spa_iv", "ev_sp_atk", "sp_atk_ev", "iv_sp_atk", "sp_atk_iv", "ev_special_attack", "special_attack_ev", "iv_special_attack", "special_attack_iv", "ev_special-attack", "special-attack_ev", "iv_special-attack", "special-attack_iv", "ev_spatk", "spatk_ev", "iv_spatk", "spatk_iv"),
                "spd": ("ev_spd", "spd_ev", "iv_spd", "spd_iv", "ev_sp_def", "sp_def_ev", "iv_sp_def", "sp_def_iv", "ev_special_defense", "special_defense_ev", "iv_special_defense", "special_defense_iv", "ev_special-defense", "special-defense_ev", "iv_special-defense", "special-defense_iv", "ev_spdef", "spdef_ev", "iv_spdef", "spdef_iv"),
                "spe": ("ev_spe", "spe_ev", "iv_spe", "spe_iv", "ev_speed", "speed_ev", "iv_speed", "speed_iv"),
            }
            for dest, keys in pref_aliases.items():
                if dest in d and d.get(dest) not in (None, ""):
                    continue
                for k in keys:
                    if k in d and d.get(k) not in (None, ""):
                        d[dest] = d.get(k)
                        break
            return d

        def _pick_int(maps: list[dict[str, Any]], *keys: str) -> int:
            for m in maps:
                for k in keys:
                    if k in m and m.get(k) not in (None, ""):
                        try:
                            return int(float(m.get(k)))
                        except Exception:
                            continue
            return 0

        stat_maps = [
            _as_stat_map(stats_obj),
            _as_stat_map(mon.get("final_stats")),
            _as_stat_map(mon.get("stats")),
            _as_stat_map(mon),
        ]
        iv_maps = [
            _as_stat_map(ivs_map),
            _as_stat_map(mon.get("ivs")),
            _as_stat_map(mon.get("iv")),
            _as_stat_map(mon),
        ]
        ev_maps = [
            _as_stat_map(evs_map),
            _as_stat_map(mon.get("evs")),
            _as_stat_map(mon.get("ev")),
            _as_stat_map(mon),
        ]

        final_stats = {
            "hp": int(max(1, hp_max)),
            "atk": _pick_int(stat_maps, "attack", "atk"),
            "def": _pick_int(stat_maps, "defense", "def", "defn"),
            "spa": _pick_int(stat_maps, "special_attack", "special-attack", "spa", "sp_atk", "spatk"),
            "spd": _pick_int(stat_maps, "special_defense", "special-defense", "spd", "sp_def", "spdef"),
            "spe": _pick_int(stat_maps, "speed", "spe"),
        }
        iv_vals = {
            "hp": _pick_int(iv_maps, "hp", "iv_hp", "hp_iv"),
            "atk": _pick_int(iv_maps, "attack", "atk", "iv_atk", "atk_iv", "iv_attack", "attack_iv"),
            "def": _pick_int(iv_maps, "defense", "def", "defn", "iv_def", "def_iv", "iv_defense", "defense_iv", "iv_defn", "defn_iv"),
            "spa": _pick_int(iv_maps, "special_attack", "special-attack", "spa", "sp_atk", "spatk", "iv_spa", "spa_iv", "iv_sp_atk", "sp_atk_iv", "iv_special_attack", "special_attack_iv", "iv_special-attack", "special-attack_iv", "iv_spatk", "spatk_iv"),
            "spd": _pick_int(iv_maps, "special_defense", "special-defense", "spd", "sp_def", "spdef", "iv_spd", "spd_iv", "iv_sp_def", "sp_def_iv", "iv_special_defense", "special_defense_iv", "iv_special-defense", "special-defense_iv", "iv_spdef", "spdef_iv"),
            "spe": _pick_int(iv_maps, "speed", "spe", "iv_spe", "spe_iv", "iv_speed", "speed_iv"),
        }
        ev_vals = {
            "hp": _pick_int(ev_maps, "hp", "ev_hp", "hp_ev"),
            "atk": _pick_int(ev_maps, "attack", "atk", "ev_atk", "atk_ev", "ev_attack", "attack_ev"),
            "def": _pick_int(ev_maps, "defense", "def", "defn", "ev_def", "def_ev", "ev_defense", "defense_ev", "ev_defn", "defn_ev"),
            "spa": _pick_int(ev_maps, "special_attack", "special-attack", "spa", "sp_atk", "spatk", "ev_spa", "spa_ev", "ev_sp_atk", "sp_atk_ev", "ev_special_attack", "special_attack_ev", "ev_special-attack", "special-attack_ev", "ev_spatk", "spatk_ev"),
            "spd": _pick_int(ev_maps, "special_defense", "special-defense", "spd", "sp_def", "spdef", "ev_spd", "spd_ev", "ev_sp_def", "sp_def_ev", "ev_special_defense", "special_defense_ev", "ev_special-defense", "special-defense_ev", "ev_spdef", "spdef_ev"),
            "spe": _pick_int(ev_maps, "speed", "spe", "ev_spe", "spe_ev", "ev_speed", "speed_ev"),
        }
        stat_rows = ["hp", "atk", "def", "spa", "spd", "spe"]
        stat_ys = [170, 190, 210, 230, 250, 270]
        stat_right = _pt(299, 0)[0]
        iv_right = _pt(333, 0)[0]
        ev_right = _pt(374, 0)[0]
        for key, yy in zip(stat_rows, stat_ys):
            y = _pt(0, yy)[1]
            sval = f"{int(final_stats.get(key, 0))}"
            ival = f"{max(0, min(31, int(iv_vals.get(key, 0)))):02d}"
            eval_ = f"{max(0, min(252, int(ev_vals.get(key, 0)))):03d}"

            sval_w = self._mpokeinfo_text_width(draw_probe, sval, font_stats)
            ival_w = self._mpokeinfo_text_width(draw_probe, ival, font_stats)
            eval_w = self._mpokeinfo_text_width(draw_probe, eval_, font_stats)

            self._mpokeinfo_draw_shadow_text(
                draw,
                (stat_right - sval_w, y),
                sval,
                font=font_stats,
                fill=(235, 241, 247, 255),
            )
            self._mpokeinfo_draw_shadow_text(
                draw,
                (iv_right - ival_w, y),
                ival,
                font=font_stats,
                fill=(255, 82, 110, 255),
                shadow=(95, 24, 39, 220),
            )
            self._mpokeinfo_draw_shadow_text(
                draw,
                (ev_right - eval_w, y),
                eval_,
                font=font_stats,
                fill=(102, 244, 220, 255),
                shadow=(18, 90, 84, 220),
            )

        # Emit animated panel if animated sprite exists; otherwise static PNG.
        if sprite_frames:
            cx, cy = _pt(162, 84)
            if len(sprite_frames) > 1:
                out_frames: list[Any] = []
                for spr in sprite_frames:
                    fr = panel_static.copy()
                    dx = int(cx - (spr.width // 2))
                    dy = int(cy - (spr.height // 2))
                    try:
                        fr.alpha_composite(spr, dest=(dx, dy))
                    except Exception:
                        pass
                    _draw_front_shiny_stars(fr)
                    out_frames.append(fr)
                if out_frames:
                    out = BytesIO()
                    durations_to_save: Any
                    if sprite_frame_durations and len(sprite_frame_durations) >= len(out_frames):
                        durations_to_save = sprite_frame_durations[:len(out_frames)]
                    else:
                        durations_to_save = int(max(55, min(220, sprite_duration_ms)))
                    try:
                        out_frames[0].save(
                            out,
                            format="GIF",
                            save_all=True,
                            append_images=out_frames[1:],
                            duration=durations_to_save,
                            loop=0,
                            disposal=2,
                            optimize=False,
                        )
                    except Exception:
                        return None
                    data = out.getvalue()
                    _binary_render_cache_set(
                        _MPOKEINFO_RENDER_CACHE,
                        cache_key,
                        data,
                        "gif",
                        max_entries=MPOKEINFO_RENDER_CACHE_MAX_ENTRIES,
                    )
                    out.seek(0)
                    filename = f"mpokeinfo_{int(mon.get('id') or 0)}.gif"
                    return discord.File(fp=out, filename=filename)
            # Single frame fallback.
            try:
                spr = sprite_frames[0]
                panel_static.alpha_composite(spr, dest=(int(cx - (spr.width // 2)), int(cy - (spr.height // 2))))
            except Exception:
                pass
        _draw_front_shiny_stars(panel_static)

        out = BytesIO()
        try:
            panel_static.save(out, format="PNG")
        except Exception:
            return None
        data = out.getvalue()
        _binary_render_cache_set(
            _MPOKEINFO_RENDER_CACHE,
            cache_key,
            data,
            "png",
            max_entries=MPOKEINFO_RENDER_CACHE_MAX_ENTRIES,
        )
        out.seek(0)
        filename = f"mpokeinfo_{int(mon.get('id') or 0)}.png"
        return discord.File(fp=out, filename=filename)

    @staticmethod
    def _register_panel_base_path() -> Optional[Path]:
        candidates = [
            ASSETS_DIR / "ui" / "pkinfo-back.png",
            ASSETS_DIR / "ui" / "pkinfo-back-template.png",
            ASSETS_DIR / "ui" / "register-base.png",
            ASSETS_DIR / "ui" / "register_base.png",
            ASSETS_DIR / "ui" / "register-template.png",
            ASSETS_DIR / "ui" / "register_template.png",
            ASSETS_DIR / "ui" / "register.png",
        ]
        for p in candidates:
            try:
                if p.exists() and p.is_file() and p.stat().st_size > 0:
                    return p
            except Exception:
                continue
        return None

    async def _render_register_panel(
        self,
        interaction: Interaction,
        mon: dict,
        *,
        profile: dict,
        species: str,
        level: int,
        shiny: bool,
        gender: str,
        current_form: Optional[str],
        types: List[str],
        use_back_sprite: bool = True,
        is_registered: bool = True,
    ) -> Optional[discord.File]:
        if Image is None:
            return None
        try:
            from PIL import Image as PILImage, ImageDraw, ImageSequence  # type: ignore
        except Exception:
            return None

        template = self._register_panel_base_path()
        if template is None:
            return None
        try:
            base = PILImage.open(str(template)).convert("RGBA")
        except Exception:
            return None

        W, H = base.size
        sx = max(0.1, float(W) / 800.0)
        sy = max(0.1, float(H) / 488.0)
        scale = min(sx, sy)
        if bool(is_registered):
            theme_fill = (255, 116, 116, 255)
            theme_shadow = (92, 20, 20, 220)
        elif bool(shiny):
            theme_fill = (255, 224, 118, 255)
            theme_shadow = (98, 74, 24, 220)
        else:
            theme_fill = (242, 246, 250, 255)
            theme_shadow = (0, 0, 0, 220)

        profile_keys_int = [
            "most_used_move_count",
            "times_traded",
            "eggs_bred",
            "total_routes",
            "total_exp_gained",
            "pokemon_beat",
            "shinies_killed",
            "legendaries_killed",
            "raids_won",
            "raids_lost",
            "battles_won",
            "battles_lost",
            "ribbons",
        ]
        profile_snapshot: dict[str, int | str] = {
            "most_used_move": str(profile.get("most_used_move") or ""),
        }
        for k in profile_keys_int:
            try:
                profile_snapshot[k] = int(profile.get(k, 0) or 0)
            except Exception:
                profile_snapshot[k] = 0
        register_cache_payload = {
            "panel": "register-back-v3",
            "mon_id": int(mon.get("id") or 0),
            "species": str(species or "").strip().lower(),
            "level": int(level or 1),
            "shiny": int(bool(shiny)),
            "gender": str(gender or "").strip().lower(),
            "form": str(current_form or "").strip().lower(),
            "types": [str(t or "").strip().lower() for t in list(types or [])[:2]],
            "profile": profile_snapshot,
            "use_back_sprite": int(bool(use_back_sprite)),
            "is_registered": int(bool(is_registered)),
            "ot_name": str(getattr(interaction.user, "display_name", "") or ""),
        }
        register_cache_raw = json.dumps(
            register_cache_payload,
            ensure_ascii=True,
            sort_keys=True,
            separators=(",", ":"),
            default=str,
        )
        register_cache_key = hashlib.sha1(register_cache_raw.encode("utf-8")).hexdigest()
        cached_render = _binary_render_cache_get(
            _REGISTER_PANEL_RENDER_CACHE,
            register_cache_key,
            ttl_seconds=REGISTER_PANEL_RENDER_CACHE_TTL_SECONDS,
        )
        if cached_render is not None:
            cached_data, cached_ext = cached_render
            return discord.File(
                fp=BytesIO(cached_data),
                filename=f"register_{int(mon.get('id') or 0)}.{cached_ext}",
            )
        draw_probe = ImageDraw.Draw(base)

        def _pt(x: float, y: float) -> tuple[int, int]:
            return (int(round(x * sx)), int(round(y * sy)))

        def _clip_text(text: str, font, max_width: int) -> str:
            t = str(text or "")
            if not t or font is None:
                return ""
            if self._mpokeinfo_text_width(draw_probe, t, font) <= int(max_width):
                return t
            suffix = "..."
            if self._mpokeinfo_text_width(draw_probe, suffix, font) > int(max_width):
                return ""
            lo, hi = 0, len(t)
            best = suffix
            while lo <= hi:
                mid = (lo + hi) // 2
                cand = f"{t[:mid].rstrip()}{suffix}"
                if self._mpokeinfo_text_width(draw_probe, cand, font) <= int(max_width):
                    best = cand
                    lo = mid + 1
                else:
                    hi = mid - 1
            return best

        panel_static = base.copy()
        draw = ImageDraw.Draw(panel_static)
        value_font_base_size = max(8, int(round(18 * scale)))

        def _draw_center_value(
            text: str,
            left: int,
            top: int,
            width: int,
            height: int,
            *,
            start_size: Optional[int] = None,
            min_size: Optional[int] = None,
            bold: bool = True,
            y_nudge: int = 0,
            x_nudge: int = 0,
        ) -> None:
            txt = str(text or "‚Äî")
            font = self._mpokeinfo_fit_font(
                draw_probe,
                txt,
                max_width=max(10, int(width - max(6, int(round(8 * sx))))),
                start_size=int(start_size if start_size is not None else value_font_base_size),
                min_size=int(min_size if min_size is not None else max(8, int(round(11 * scale)))),
                bold=bool(bold),
            )
            txt = _clip_text(txt, font, max(10, int(width - max(6, int(round(8 * sx)))))
            )
            if not txt or font is None:
                return
            try:
                tb = draw_probe.textbbox((0, 0), txt, font=font)
                tw = max(1, int(tb[2] - tb[0]))
                th = max(1, int(tb[3] - tb[1]))
            except Exception:
                tw = self._mpokeinfo_text_width(draw_probe, txt, font)
                th = max(8, int(round(12 * scale)))
            tx = int(left + max(0, (int(width) - tw) // 2) + int(x_nudge))
            ty = int(top + max(0, (int(height) - th) // 2) + int(y_nudge))
            self._mpokeinfo_draw_shadow_text(
                draw,
                (tx, ty),
                txt,
                font=font,
                fill=theme_fill,
                shadow=theme_shadow,
            )

        # Template already includes static labels; draw only dynamic values.
        def _draw_row_value(value: str, *, left: int, top: int, width: int, y_extra: int = 0) -> None:
            label_h = max(8, int(round(18 * sy)))
            value_h = max(10, int(round(34 * sy)))
            value_nudge = max(2, int(round(4 * sy)))
            _draw_center_value(value, left, top + label_h, width, value_h, y_nudge=value_nudge + int(y_extra), x_nudge=0)

        def _ival(key: str) -> int:
            try:
                return int(profile.get(key, 0) or 0)
            except Exception:
                return 0

        most_used_move = register_stats.display_move_name(profile.get("most_used_move"))
        move_count = _ival("most_used_move_count")
        if move_count > 0 and most_used_move != "‚Äî":
            most_used_move = f"{most_used_move} √ó{move_count}"

        left_x = _pt(44, 0)[0]
        left_w = max(40, int(round(278 * sx)))
        # Under-sprite rows use slightly narrower, shifted boxes on the template.
        left_under_exp_x = _pt(84, 0)[0]
        left_under_exp_w = max(32, int(round(240 * sx)))
        left_under_pb_x = _pt(54, 0)[0]
        left_under_pb_w = max(32, int(round(262 * sx)))
        left_under_shiny_x = _pt(52, 0)[0]
        left_under_shiny_w = max(32, int(round(268 * sx)))
        left_under_leg_x = _pt(44, 0)[0]
        left_under_leg_w = max(32, int(round(282 * sx)))

        right_under_rw_x = _pt(348, 0)[0]
        right_under_rw_w = max(32, int(round(272 * sx)))
        right_under_rl_x = _pt(348, 0)[0]
        right_under_rl_w = max(32, int(round(258 * sx)))
        right_under_bw_x = _pt(344, 0)[0]
        right_under_bw_w = max(32, int(round(270 * sx)))
        right_under_bl_x = _pt(338, 0)[0]
        right_under_bl_w = max(32, int(round(282 * sx)))

        top_rows = [
            (most_used_move, 12, left_x, left_w),
            (f"{_ival('times_traded')}", 74, left_x, left_w),
            (f"{_ival('eggs_bred')}", 128, left_x, left_w),
            (f"{_ival('total_routes')}", 182, left_x, left_w),
            (f"{_ival('total_exp_gained')}", 240, left_under_exp_x, left_under_exp_w),
            (f"{_ival('pokemon_beat')}", 294, left_under_pb_x, left_under_pb_w),
            (f"{_ival('shinies_killed')}", 348, left_under_shiny_x, left_under_shiny_w),
            (f"{_ival('legendaries_killed')}", 402, left_under_leg_x, left_under_leg_w),
        ]
        for value, y, row_left, row_w in top_rows:
            _draw_row_value(value, left=row_left, top=_pt(0, y)[1], width=row_w, y_extra=max(1, int(round(1 * sy))))

        right_rows = [
            (f"{_ival('raids_won')}", 240, right_under_rw_x, right_under_rw_w),
            (f"{_ival('raids_lost')}", 294, right_under_rl_x, right_under_rl_w),
            (f"{_ival('battles_won')}", 348, right_under_bw_x, right_under_bw_w),
            (f"{_ival('battles_lost')}", 402, right_under_bl_x, right_under_bl_w),
        ]
        for value, y, row_left, row_w in right_rows:
            _draw_row_value(value, left=row_left, top=_pt(0, y)[1], width=row_w, y_extra=max(1, int(round(1 * sy))))

        ot_name = str(getattr(interaction.user, "display_name", None) or "Trainer").strip()
        # Match front-panel header geometry (scaled into this panel's coordinate system).
        # Front-equivalent top-row geometry adapted to this panel's scale grid.
        ot_box_left, ot_box_y = _pt(244, 21)
        ot_box_w = max(24, int(round(142 * sx)))
        ot_box_h = max(10, int(round(20 * sy)))
        _draw_center_value(
            ot_name,
            ot_box_left,
            ot_box_y,
            ot_box_w,
            ot_box_h,
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=True,
            y_nudge=0,
        )

        raw_nick = str(mon.get("nickname") or "").strip()
        if raw_nick:
            species_display = raw_nick
        else:
            species_display = str(species or "pokemon").replace("-", " ").replace("_", " ")
        name_font = self._mpokeinfo_fit_font(
            draw_probe,
            species_display,
            max_width=max(20, int(round(220 * sx))),
            start_size=max(10, int(round(18 * scale))),
            min_size=max(8, int(round(10 * scale))),
            bold=True,
        )
        species_display = _clip_text(species_display, name_font, max(20, int(round(220 * sx))))
        if species_display and name_font is not None:
            name_x, name_y = _pt(322, 206)
            name_w = max(20, int(round(236 * sx)))
            name_h = max(10, int(round(24 * sy)))
            _draw_center_value(
                species_display,
                name_x,
                name_y,
                name_w,
                name_h,
                start_size=max(10, int(round(18 * scale))),
                min_size=max(8, int(round(10 * scale))),
                bold=True,
            )

        g_key = str(gender or "").strip().lower()
        g_sym = {"male": "‚ôÇ", "m": "‚ôÇ", "‚ôÄ": "‚ôÄ", "female": "‚ôÄ", "f": "‚ôÄ"}.get(g_key, "")
        lv_text = f"{int(level)}"
        lv_box_left, lv_box_y = _pt(478, 20)
        lv_box_w = max(18, int(round(126 * sx)))
        lv_box_h = max(10, int(round(20 * sy)))
        lv_font = self._mpokeinfo_fit_font(
            draw_probe,
            lv_text,
            max_width=max(12, int(round(lv_box_w * 0.6))),
            start_size=max(8, int(round(10 * scale))),
            min_size=max(7, int(round(8 * scale))),
            bold=True,
        )
        lv_text = _clip_text(lv_text, lv_font, max(12, int(round(lv_box_w * 0.6))))
        if lv_text and lv_font is not None:
            lv_w = self._mpokeinfo_text_width(draw_probe, lv_text, lv_font)
            lv_h = max(8, int(round(10 * sy)))
            try:
                lb = draw_probe.textbbox((0, 0), lv_text, font=lv_font)
                lv_h = max(1, int(lb[3] - lb[1]))
            except Exception:
                pass
            gender_font = None
            gw = 0
            gh = lv_h
            if g_sym:
                try:
                    from PIL import ImageFont  # type: ignore
                    gender_font = ImageFont.truetype(
                        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                        max(8, int(round(10 * scale))),
                    )
                except Exception:
                    gender_font = self._mpokeinfo_font(max(8, int(round(10 * scale))), bold=True)
                gw = self._mpokeinfo_text_width(draw_probe, g_sym, gender_font)
                try:
                    gb = draw_probe.textbbox((0, 0), g_sym, font=gender_font)
                    gh = max(1, int(gb[3] - gb[1]))
                except Exception:
                    pass
            gap = max(1, int(round(2 * sx))) if g_sym else 0
            group_w = int(lv_w + (gap + gw if g_sym else 0))
            group_x = int(lv_box_left + max(0, (lv_box_w - group_w) // 2))
            lv_nudge_x = max(1, int(round(2 * sx)))
            lv_y = int(lv_box_y + max(0, ((lv_box_h - lv_h) // 2) - 1))
            self._mpokeinfo_draw_shadow_text(
                draw,
                (group_x + lv_nudge_x, lv_y),
                lv_text,
                font=lv_font,
                fill=theme_fill,
                shadow=theme_shadow,
            )
            if g_sym and gender_font is not None:
                gender_nudge_x = max(1, int(round(2 * sx)))
                gx = int(group_x + lv_nudge_x + lv_w + gap + gender_nudge_x)
                gender_nudge_y = -max(1, int(round(1 * sy)))
                gy = int(lv_box_y + max(0, ((lv_box_h - gh) // 2) - 1 + gender_nudge_y))
                self._mpokeinfo_draw_shadow_text(
                    draw,
                    (gx, gy),
                    g_sym,
                    font=gender_font,
                    fill=theme_fill,
                    shadow=theme_shadow,
                )

        ribbons = _ival("ribbons")
        _ = ribbons  # ribbon images planned; suppress numeric overlay for now.

        type_tokens = [str(t or "").strip().lower() for t in list(types or []) if str(t or "").strip()]
        if not type_tokens:
            type_tokens = ["normal"]
        type_left, type_top = _pt(518, 56)
        type_w = max(24, int(round(122 * sx)))
        type_h = max(12, int(round(26 * sy)))
        type_gap = max(1, int(round(4 * sy)))
        for i, tok in enumerate(type_tokens[:2]):
            row_y = int(type_top + (i * (type_h + type_gap)))
            badge = self._mpokeinfo_type_badge_path(tok)
            if badge is not None:
                try:
                    with PILImage.open(str(badge)) as src:
                        t_icon = src.convert("RGBA")
                    try:
                        bb = t_icon.split()[-1].getbbox()
                        if bb is not None:
                            cropped = t_icon.crop(bb)
                            if cropped.size[0] > 0 and cropped.size[1] > 0:
                                t_icon = cropped
                    except Exception:
                        pass
                    iw, ih = t_icon.size
                    if iw > 0 and ih > 0:
                        scale_fit = min(float(type_w) / float(iw), float(type_h) / float(ih))
                        scale_fit = min(scale_fit, 1.7)
                        nw = max(1, int(round(iw * scale_fit)))
                        nh = max(1, int(round(ih * scale_fit)))
                        # Allow upscaling so small source badges still fill the back UI.
                        if nw != iw or nh != ih:
                            try:
                                t_icon = t_icon.resize((nw, nh), resample=PILImage.Resampling.NEAREST)
                            except Exception:
                                t_icon = t_icon.resize((nw, nh))
                    icon_x = int(type_left + max(0, (type_w - t_icon.width) // 2))
                    icon_y = int(row_y + max(0, (type_h - t_icon.height) // 2))
                    panel_static.alpha_composite(t_icon, dest=(icon_x, icon_y))
                    continue
                except Exception:
                    pass
            t_txt = str(tok).replace("-", " ").title()
            t_font = self._mpokeinfo_fit_font(
                draw_probe,
                t_txt,
                max_width=max(12, int(round(type_w - 6))),
                start_size=max(8, int(round(14 * scale))),
                min_size=max(7, int(round(10 * scale))),
                bold=True,
            )
            if t_font is not None:
                tw = self._mpokeinfo_text_width(draw_probe, t_txt, t_font)
                tx = int(type_left + max(0, (type_w - tw) // 2))
                ty = int(row_y + max(0, (type_h - int(round(10 * scale))) // 2) - 1)
                self._mpokeinfo_draw_shadow_text(draw, (tx, ty), t_txt, font=t_font, fill=theme_fill, shadow=theme_shadow)

        def _draw_back_shiny_stars(target_img: Any) -> None:
            if not shiny:
                return
            try:
                draw_star = ImageDraw.Draw(target_img)
            except Exception:
                return
            try:
                from PIL import ImageFont  # type: ignore
                star_font = ImageFont.truetype(
                    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                    max(10, int(round(13 * scale))),
                )
                side_star_font = ImageFont.truetype(
                    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                    max(8, int(round(10 * scale))),
                )
            except Exception:
                star_font = self._mpokeinfo_font(max(10, int(round(13 * scale))), bold=True)
                side_star_font = self._mpokeinfo_font(max(8, int(round(10 * scale))), bold=True)
            self._mpokeinfo_draw_shadow_text(
                draw_star,
                _pt(500, 112),
                "‚òÖ",
                font=star_font,
                fill=(255, 110, 132, 255),
                shadow=(88, 20, 26, 220),
            )
            self._mpokeinfo_draw_shadow_text(
                draw_star,
                _pt(334, 132),
                "‚òÖ",
                font=side_star_font,
                fill=(255, 110, 132, 255),
                shadow=(88, 20, 26, 220),
            )

        sprite_frames: list[Any] = []
        durations: list[int] = []
        sprite_path = self._pick_sprite_path(species, gender, shiny, current_form, back=bool(use_back_sprite))
        if sprite_path is not None:
            try:
                with PILImage.open(str(sprite_path)) as src:
                    is_anim = bool(getattr(src, "is_animated", False))
                    if is_anim:
                        frame_cap = 192 if _daycare_norm_species(species) == "eevee" else 128
                        for i, fr in enumerate(ImageSequence.Iterator(src)):
                            if i >= frame_cap:
                                break
                            try:
                                sprite_frames.append(fr.copy().convert("RGBA"))
                            except Exception:
                                sprite_frames.append(fr.convert("RGBA"))
                            try:
                                d = int(fr.info.get("duration") or src.info.get("duration") or 95)
                            except Exception:
                                d = 95
                            d = max(85, min(260, d)) if _daycare_norm_species(species) == "eevee" else max(70, min(220, d))
                            durations.append(int(d))
                    else:
                        sprite_frames = [src.convert("RGBA")]
            except Exception:
                sprite_frames = []
                durations = []

        if sprite_frames:
            union_bbox = None
            for fr in sprite_frames:
                try:
                    bb = fr.split()[-1].getbbox()
                except Exception:
                    bb = None
                if bb is None:
                    continue
                if union_bbox is None:
                    union_bbox = bb
                else:
                    union_bbox = (
                        min(union_bbox[0], bb[0]),
                        min(union_bbox[1], bb[1]),
                        max(union_bbox[2], bb[2]),
                        max(union_bbox[3], bb[3]),
                    )
            fitted: list[Any] = []
            for fr in sprite_frames:
                sp = fr
                if union_bbox is not None:
                    try:
                        crop = fr.crop(union_bbox)
                        if crop.size[0] > 0 and crop.size[1] > 0:
                            sp = crop
                    except Exception:
                        pass
                try:
                    sp.thumbnail((max(20, int(round(210 * sx))), max(20, int(round(180 * sy)))), resample=PILImage.Resampling.LANCZOS)
                except Exception:
                    pass
                fitted.append(sp)
            sprite_frames = fitted

        sprite_cx, sprite_cy = _pt(438, 146)
        if sprite_frames and len(sprite_frames) > 1:
            out_frames: list[Any] = []
            for sp in sprite_frames:
                fr = panel_static.copy()
                try:
                    fr.alpha_composite(sp, dest=(int(sprite_cx - (sp.width // 2)), int(sprite_cy - (sp.height // 2))))
                except Exception:
                    pass
                _draw_back_shiny_stars(fr)
                out_frames.append(fr)
            if out_frames:
                out = BytesIO()
                try:
                    out_frames[0].save(
                        out,
                        format="GIF",
                        save_all=True,
                        append_images=out_frames[1:],
                        duration=durations[:len(out_frames)] if durations else 95,
                        loop=0,
                        disposal=2,
                        optimize=False,
                    )
                except Exception:
                    return None
                data = out.getvalue()
                _binary_render_cache_set(
                    _REGISTER_PANEL_RENDER_CACHE,
                    register_cache_key,
                    data,
                    "gif",
                    max_entries=REGISTER_PANEL_RENDER_CACHE_MAX_ENTRIES,
                )
                out.seek(0)
                return discord.File(fp=out, filename=f"register_{int(mon.get('id') or 0)}.gif")

        if sprite_frames:
            try:
                sp = sprite_frames[0]
                panel_static.alpha_composite(sp, dest=(int(sprite_cx - (sp.width // 2)), int(sprite_cy - (sp.height // 2))))
            except Exception:
                pass
        _draw_back_shiny_stars(panel_static)

        out = BytesIO()
        try:
            panel_static.save(out, format="PNG")
        except Exception:
            return None
        data = out.getvalue()
        _binary_render_cache_set(
            _REGISTER_PANEL_RENDER_CACHE,
            register_cache_key,
            data,
            "png",
            max_entries=REGISTER_PANEL_RENDER_CACHE_MAX_ENTRIES,
        )
        out.seek(0)
        return discord.File(fp=out, filename=f"register_{int(mon.get('id') or 0)}.png")

    # /expshare retired: Exp. Share is now obtained via market pricing.
    async def expshare(self, interaction: Interaction):
        if not interaction.response.is_done():
            await interaction.response.defer(ephemeral=False)

        uid = str(interaction.user.id)
        async with db.session() as conn:
            await conn.execute(
                "INSERT INTO users(user_id, coins, currencies) VALUES(?, 0, '{\"coins\": 0}'::jsonb) ON CONFLICT(user_id) DO NOTHING",
                (uid,),
            )
            cur_user = await conn.execute("SELECT * FROM users WHERE user_id=? LIMIT 1", (uid,))
            user_row = await cur_user.fetchone()
            await cur_user.close()
            balance = int(db.get_currency_from_row(dict(user_row) if user_row else None, "coins"))
            already_owned = await _has_exp_share_bag_item(uid, conn=conn)

        if already_owned:
            return await interaction.followup.send(
                "‚ÑπÔ∏è You already own **Exp. Share**. It is active for your team.",
                ephemeral=True,
            )
        if balance < int(EXP_SHARE_COST_PKC):
            return await interaction.followup.send(
                f"‚ùå You need **{int(EXP_SHARE_COST_PKC):,} {PKDollar_NAME}** for Exp. Share, "
                f"but you only have **{int(balance):,}**.",
                ephemeral=True,
            )

        confirm_view = _ConfirmDeclineView(
            owner_user_id=interaction.user.id,
            confirm_label=f"Confirm (-{int(EXP_SHARE_COST_PKC):,})",
            decline_label="Decline",
            timeout=120,
        )
        prompt_text = (
            f"Buy **Exp. Share** for **{int(EXP_SHARE_COST_PKC):,} {PKDollar_NAME}**?\n"
            f"Current balance: **{int(balance):,}**."
        )
        prompt_msg = await interaction.followup.send(prompt_text, view=confirm_view, ephemeral=False, wait=True)
        await confirm_view.wait()

        if confirm_view.choice is not True:
            cancel_msg = (
                "‚åõ Exp. Share purchase timed out. No PKC was spent."
                if confirm_view.choice is None
                else "‚ùå Exp. Share purchase cancelled. No PKC was spent."
            )
            try:
                await prompt_msg.edit(content=cancel_msg, view=None)
            except Exception:
                await interaction.followup.send(cancel_msg, ephemeral=True)
            return

        charged = int(EXP_SHARE_COST_PKC)
        remaining = int(balance)
        already_owned_after = False
        async with DB_WRITE_LOCK:
            async with db.session() as conn:
                await conn.execute(
                    "INSERT INTO users(user_id, coins, currencies) VALUES(?, 0, '{\"coins\": 0}'::jsonb) ON CONFLICT(user_id) DO NOTHING",
                    (uid,),
                )
                if await _has_exp_share_bag_item(uid, conn=conn):
                    already_owned_after = True
                else:
                    cur_user = await conn.execute("SELECT * FROM users WHERE user_id=? LIMIT 1", (uid,))
                    user_row = await cur_user.fetchone()
                    await cur_user.close()
                    live_balance = int(db.get_currency_from_row(dict(user_row) if user_row else None, "coins"))
                    if live_balance < charged:
                        try:
                            await prompt_msg.edit(
                                content=(
                                    f"‚ùå You need **{charged:,} {PKDollar_NAME}** for Exp. Share, "
                                    f"but you only have **{live_balance:,}**."
                                ),
                                view=None,
                            )
                        except Exception:
                            await interaction.followup.send(
                                f"‚ùå You need **{charged:,} {PKDollar_NAME}** for Exp. Share, "
                                f"but you only have **{live_balance:,}**.",
                                ephemeral=True,
                            )
                        return

                    await conn.execute(
                        "INSERT INTO items (id, name) VALUES (?, ?) ON CONFLICT (id) DO NOTHING",
                        ("exp_share", "Exp. Share"),
                    )
                    await db.add_currency_conn(conn, uid, "coins", -charged)
                    await conn.execute(
                        "INSERT INTO user_items(owner_id, item_id, qty) VALUES(?,?,1) "
                        "ON CONFLICT(owner_id, item_id) DO UPDATE SET qty = 1",
                        (uid, "exp_share"),
                    )
                    await conn.commit()
                    remaining = max(0, live_balance - charged)

        try:
            db.invalidate_bag_cache(uid)
        except Exception:
            pass

        if already_owned_after:
            try:
                await prompt_msg.edit(content="‚ÑπÔ∏è You already own **Exp. Share**. It is active for your team.", view=None)
            except Exception:
                await interaction.followup.send("‚ÑπÔ∏è You already own **Exp. Share**. It is active for your team.", ephemeral=True)
            return

        try:
            await prompt_msg.edit(
                content=(
                    f"‚úÖ Purchased **Exp. Share** for **{charged:,} {PKDollar_NAME}**.\n"
                    f"Remaining balance: **{remaining:,}**.\n"
                    f"All team Pok√©mon now receive EXP/EVs after battles while Exp. Share is owned."
                ),
                view=None,
            )
        except Exception:
            await interaction.followup.send(
                f"‚úÖ Purchased **Exp. Share** for **{charged:,} {PKDollar_NAME}**. Remaining balance: **{remaining:,}**.",
                ephemeral=True,
            )

    @app_commands.command(name="register", description="Register a Pok√©mon for tracking (costs 500,000 PKC).")
    @app_commands.describe(
        name="Pok√©mon species from your team (e.g. pikachu)",
        slot="Team slot (1‚Äì6) if you have duplicates",
    )
    async def register(self, interaction: Interaction, name: str, slot: Optional[int] = None):
        if not interaction.response.is_done():
            await interaction.response.defer(ephemeral=False)

        uid = str(interaction.user.id)
        async with db.session() as conn:
            mon = await resolve_team_mon(interaction, name, slot, conn=conn)  # noqa: F405
            if not mon:
                return
            full = await db.get_pokemon(uid, int(mon["id"]), conn=conn)
            if not full:
                await interaction.followup.send("Could not load Pok√©mon data.", ephemeral=True)
                return
            mon = full
            species = str(mon.get("species") or "unknown")
            try:
                dex = await ensure_species_and_learnsets(species)
            except Exception:
                dex = None

        mon_id = int(mon.get("id") or 0)
        if mon_id <= 0:
            return await interaction.followup.send("Could not resolve Pok√©mon ID for registration.", ephemeral=True)

        reg_cost = int(register_stats.REGISTER_COST_PKC)
        profile = await register_stats.get_profile(uid, mon_id)
        reg_created = False
        reg_balance = await db.get_currency(uid, "coins")

        if profile is None:
            if int(reg_balance) < reg_cost:
                return await interaction.followup.send(
                    f"‚ùå You need **{reg_cost:,} {PKDollar_NAME}** to register this Pok√©mon, "
                    f"but you only have **{int(reg_balance):,}**.",
                    ephemeral=True,
                )

            confirm_view = _ConfirmDeclineView(
                owner_user_id=interaction.user.id,
                confirm_label=f"Confirm (-{reg_cost:,})",
                decline_label="Decline",
                timeout=120,
            )
            confirm_msg = await interaction.followup.send(
                (
                    f"Register **{species.replace('-', ' ').title()}** for stat tracking "
                    f"for **{reg_cost:,} {PKDollar_NAME}**?\n"
                    f"Current balance: **{int(reg_balance):,}**."
                ),
                view=confirm_view,
                ephemeral=False,
                wait=True,
            )
            await confirm_view.wait()
            if confirm_view.choice is not True:
                cancel_text = (
                    "‚åõ Registration timed out. No PKC was spent."
                    if confirm_view.choice is None
                    else "‚ùå Registration cancelled. No PKC was spent."
                )
                try:
                    await confirm_msg.edit(content=cancel_text, view=None)
                except Exception:
                    await interaction.followup.send(cancel_text, ephemeral=True)
                return

            reg = await register_stats.register_mon(
                uid,
                mon_id,
                species,
                cost=reg_cost,
            )
            if not bool(reg.get("ok")):
                if str(reg.get("reason")) == "insufficient_funds":
                    bal = int(reg.get("balance") or 0)
                    return await interaction.followup.send(
                        f"‚ùå You need **{reg_cost:,} {PKDollar_NAME}** to register this Pok√©mon, but you only have **{bal:,}**.",
                        ephemeral=True,
                    )
                return await interaction.followup.send("‚ùå Could not register this Pok√©mon right now.", ephemeral=True)

            reg_created = bool(reg.get("created"))
            reg_balance = int(reg.get("balance") or reg_balance)
            profile = reg.get("profile") if isinstance(reg.get("profile"), dict) else None
            if profile is None:
                profile = await register_stats.get_profile(uid, mon_id)
            profile = profile or {}
            try:
                await confirm_msg.edit(content="‚úÖ Registration confirmed.", view=None)
            except Exception:
                pass
        else:
            profile = profile or {}

        level = int(mon.get("level") or 1)
        shiny = bool(mon.get("shiny"))
        gender = str(mon.get("gender") or "").lower()
        current_form = mon.get("form")
        if not current_form and dex:
            current_form = dex.get("form_name")
        types = await self._extract_types(species, mon, dex)

        panel_file = await self._render_register_panel(
            interaction,
            mon,
            profile=profile,
            species=species,
            level=level,
            shiny=shiny,
            gender=gender,
            current_form=current_form,
            types=types,
            is_registered=True,
        )

        if reg_created:
            charged = reg_cost
            remaining = int(reg_balance or 0)
            msg = (
                f"‚úÖ Registered **{species.replace('-', ' ').title()}** for stat tracking "
                f"(-{charged:,} {PKDollar_NAME}). Remaining balance: **{remaining:,}**."
            )
        else:
            msg = f"‚ÑπÔ∏è **{species.replace('-', ' ').title()}** is already registered. Showing current tracker card."

        if panel_file is not None:
            try:
                await interaction.followup.send(content=msg, file=panel_file, ephemeral=False)
            finally:
                try:
                    panel_file.close()
                except Exception:
                    pass
        else:
            await interaction.followup.send(content=msg, ephemeral=False)

    # --------------------- command ---------------------
    @app_commands.command(name="mypokeinfo", description="Show details for a Pok√©mon on your team.")
    @app_commands.describe(
        name="Pok√©mon species (e.g. pikachu)",
        slot="Team slot (1‚Äì6) if you have duplicates"
    )
    async def mpokeinfo(self, interaction: Interaction, name: str, slot: Optional[int] = None):
        if not interaction.response.is_done():
            await interaction.response.defer(ephemeral=False)
        uid = str(interaction.user.id)
        user_gen = await _user_selected_gen(uid)
        is_locked = False

        # Single DB session: resolve + fetch full row. Parallel dex fetch overlapped with get_pokemon.
        async with db.session() as conn:
            mon = await resolve_team_mon(interaction, name, slot, conn=conn)  # noqa: F405
            if not mon:
                return
            species = str(mon.get("species") or "unknown")
            try:
                mon_id = int(mon.get("id") or 0)
            except Exception:
                mon_id = 0
            if mon_id > 0:
                try:
                    is_locked = await _is_pokemon_locked(uid, mon_id, conn=conn)
                except Exception:
                    is_locked = False
            dex_task = asyncio.create_task(ensure_species_and_learnsets(species))
            full = await db.get_pokemon(uid, int(mon["id"]), conn=conn)
            if not full:
                dex_task.cancel()
                try:
                    await dex_task
                except asyncio.CancelledError:
                    pass
                await interaction.followup.send("Could not load Pok√©mon data.", ephemeral=True)
                return
            mon = full
            try:
                nick = await _get_pokemon_nickname(uid, int(mon.get("id") or 0), conn=conn)
                if nick:
                    mon["nickname"] = nick
            except Exception:
                pass
            # EXP to next level (uses cache when available)
            exp_to_next_val: Optional[int] = None
            cur_exp = int(mon.get("exp") or 0)
            exp_group = (mon.get("exp_group") or "medium_fast").strip().lower()
            cur_level = int(mon.get("level") or 1)
            if cur_level < 100:
                exp_next_total = await _get_exp_total_for_level(conn, exp_group, cur_level + 1)
                if exp_next_total is not None and exp_next_total > 0:
                    exp_to_next_val = max(0, exp_next_total - cur_exp)
            # Await dex_task *inside* session so ensure_species doesn't use conn after release
            try:
                dex = await dex_task
            except asyncio.CancelledError:
                dex = None
            except Exception:
                dex = None
            # Auto-heal invalid stored abilities against species learnset data
            # (e.g. stale carry-over like Blaze on non-Fire species).
            try:
                regs, hides, valid = _ability_set_from_entry(dex if isinstance(dex, Mapping) else None)
                if valid:
                    current_ability = _norm_ability_id(mon.get("ability"))
                    if current_ability not in valid:
                        fixed_ability = regs[0] if regs else hides[0]
                        mon["ability"] = fixed_ability
                        await conn.execute(
                            "UPDATE pokemons SET ability=? WHERE owner_id=? AND id=?",
                            (fixed_ability, uid, int(mon.get("id") or 0)),
                        )
                        await conn.commit()
            except Exception:
                pass

        level   = int(mon.get("level") or 1)
        shiny   = bool(mon.get("shiny"))
        gender  = str(mon.get("gender") or "").lower()

        # Redesigned compact/phone-friendly layout.
        title = f"{'üîí ' if is_locked else ''}{'‚òÖ ' if shiny else ''}{species.replace('-', ' ').title()} Lv {level}"
        emb = discord.Embed(
            title=title,
            colour=(discord.Colour.gold() if shiny else discord.Colour.blurple()),
        )

        # Form for sprite and optional title
        current_form = mon.get("form")
        if not current_form and dex:
            current_form = dex.get("form_name")
        if current_form and current_form != "normal":
            emb.title = f"{'‚òÖ ' if shiny else ''}{species.replace('-', ' ').title()} ({str(current_form).title()}) Lv {level}"
            if is_locked:
                emb.title = f"üîí {emb.title}"

        held_field = await self._label_with_emoji(interaction.guild, mon.get("held_item"))
        if not held_field or held_field.strip() in ("", "‚Äî"):
            held_field = "None"
        ball_key = (mon.get("pokeball") or "pokeball")
        ball_field = await self._label_with_emoji(interaction.guild, ball_key)

        types = await self._extract_types(species, mon, dex)
        type_parts = []
        for t in types:
            em = await get_emoji_global(self.bot, interaction.guild, t)
            type_parts.append(f"{em} {t}" if em else t)
        type_text = " / ".join(type_parts) if type_parts else "Unknown"

        tera_raw = mon.get("tera_type")
        tera_text = "‚Äî"
        if tera_raw:
            tera_name = str(tera_raw).replace("-", " ").replace("_", " ").title()
            tera_emoji = await get_emoji_global(self.bot, interaction.guild, tera_name)
            tera_text = f"{tera_emoji} {tera_name}" if tera_emoji else tera_name

        ot_text = self._format_ot(self.bot, str(mon.get("owner_id") or mon.get("user_id") or ""))
        gender_icon_fn = globals().get("_gender_icon", None)
        gender_icon = gender_icon_fn(gender) if callable(gender_icon_fn) else self._gender_icon_local(gender)
        gender_display = (
            "Male ‚ôÇ" if gender in {"male", "m", "‚ôÇ"} else
            "Female ‚ôÄ" if gender in {"female", "f", "‚ôÄ"} else
            (gender_icon or "‚Äî")
        )

        fr = mon.get("friendship", mon.get("happiness", 0))
        try:
            fr = int(fr or 0)
        except Exception:
            fr = 0
        fr = max(0, min(255, fr))
        friendship_text = f"{fr}/255"

        team_slot = mon.get("team_slot")
        team_text = f"Slot {team_slot}" if team_slot else "‚Äî"

        stats_obj = self._as_dict(mon.get("final_stats"))
        hp_max = int(stats_obj.get("hp", mon.get("hp", 0))) or 1
        hp_now = int(mon.get("hp_now", hp_max))
        hp_pct = int(round((float(hp_now) / float(hp_max)) * 100.0)) if hp_max > 0 else 0
        hp_pct = max(0, min(100, hp_pct))
        hp_bar_fill = int(round((hp_pct / 100.0) * 16.0))
        hp_bar_fill = max(0, min(16, hp_bar_fill))
        hp_bar = f"[{'#' * hp_bar_fill}{'-' * (16 - hp_bar_fill)}]"
        hp_display = f"{hp_now}/{hp_max}"

        def _stat6(d: dict | None) -> dict:
            d = d if isinstance(d, dict) else {}
            def _pick(*keys: str) -> int:
                for k in keys:
                    try:
                        if k in d and d.get(k) not in (None, ""):
                            return int(float(d.get(k)))
                    except Exception:
                        continue
                return 0
            return {
                "hp": _pick("hp"),
                "atk": _pick("attack", "atk"),
                "def": _pick("defense", "def", "defn"),
                "spa": _pick("special_attack", "special-attack", "spa", "sp_atk", "spatk"),
                "spd": _pick("special_defense", "special-defense", "spd", "sp_def", "spdef"),
                "spe": _pick("speed", "spe"),
            }

        def _fmt_stat_block(s: dict) -> str:
            return (
                f"HP  {s['hp']:>3}  Atk {s['atk']:>3}  Def {s['def']:>3}\n"
                f"SpA {s['spa']:>3}  SpD {s['spd']:>3}  Spe {s['spe']:>3}"
            )

        stats_line = _fmt_stat_block(
            {
                "hp": int(hp_now),
                "atk": int(stats_obj.get("attack", stats_obj.get("atk", mon.get("atk", 0)))),
                "def": int(stats_obj.get("defense", stats_obj.get("defn", stats_obj.get("def", mon.get("def", mon.get("defn", 0)))))),
                "spa": int(stats_obj.get("special_attack", stats_obj.get("special-attack", stats_obj.get("spa", mon.get("spa", 0))))),
                "spd": int(stats_obj.get("special_defense", stats_obj.get("special-defense", stats_obj.get("spd", mon.get("spd", 0))))),
                "spe": int(stats_obj.get("speed", stats_obj.get("spe", mon.get("spe", 0)))),
            }
        )

        ivs_map = _stat6(self._as_dict(mon.get("ivs")))
        evs_map = _stat6(self._as_dict(mon.get("evs")))
        ivs_line = _fmt_stat_block(ivs_map)
        evs_line = _fmt_stat_block(evs_map)
        total_ivs = int(sum(max(0, int(v)) for v in ivs_map.values()))

        moves = self._as_list(mon.get("moves"))
        pps_raw = mon.get("moves_pp")
        if isinstance(pps_raw, str):
            try:
                pps_list = json.loads(pps_raw) if pps_raw else []
            except Exception:
                pps_list = []
        else:
            pps_list = list(pps_raw)[:4] if pps_raw else []

        moves_lines: List[str] = []
        if moves:
            for i, m in enumerate(moves[:4]):
                m_name = str(m).replace("-", " ").title()
                cur_pp = pps_list[i] if i < len(pps_list) and pps_list[i] is not None else None
                try:
                    total_pp = _base_pp(m, generation=user_gen)
                except Exception:
                    total_pp = cur_pp if cur_pp is not None else 20
                if cur_pp is not None and total_pp is not None:
                    cur_pp = min(int(cur_pp), int(total_pp))
                cur_str = str(cur_pp) if cur_pp is not None else "?"
                moves_lines.append(f"{i + 1}. {m_name} ({cur_str}/{total_pp})")
        else:
            moves_lines.append("‚Äî")
        moves_text = "\n".join(moves_lines)

        register_profile: Optional[dict] = None
        try:
            register_profile = await register_stats.get_profile(uid, int(mon.get("id") or 0))
        except Exception:
            register_profile = None
        is_registered_mon = register_profile is not None

        # Preferred UI: render the custom mpokeinfo template image.
        panel_file = await self._render_mpokeinfo_panel(
            interaction,
            mon,
            species=species,
            level=level,
            shiny=shiny,
            gender=gender,
            current_form=current_form,
            types=types,
            exp_to_next_val=exp_to_next_val,
            friendship_value=fr,
            is_locked=is_locked,
            hp_max=hp_max,
            stats_obj=stats_obj,
            ivs_map=ivs_map,
            evs_map=evs_map,
            moves=moves,
            is_registered=is_registered_mon,
        )
        if panel_file is not None:
            try:
                if is_registered_mon:
                    view = _MPokeInfoFlipView(
                        self,
                        owner_user_id=interaction.user.id,
                        mon=mon,
                        species=species,
                        level=level,
                        shiny=shiny,
                        gender=gender,
                        current_form=current_form,
                        types=types,
                        exp_to_next_val=exp_to_next_val,
                        friendship_value=fr,
                        is_locked=is_locked,
                        hp_max=hp_max,
                        stats_obj=stats_obj,
                        ivs_map=ivs_map,
                        evs_map=evs_map,
                        moves=moves,
                        register_profile=register_profile or {},
                    )
                    await interaction.followup.send(file=panel_file, view=view, ephemeral=True)
                else:
                    await interaction.followup.send(file=panel_file, ephemeral=True)
            finally:
                try:
                    panel_file.close()
                except Exception:
                    pass
            return

        files: List[discord.File] = []
        try:
            files = attach_sprite_to_embed(
                emb, species=species, shiny=shiny, gender=gender, form_key=current_form
            )
        except Exception:
            try:
                sprites = (dex or {}).get("sprites")
                if isinstance(sprites, dict):
                    sprite_url = (sprites.get("shinyFront") if shiny else sprites.get("front")) or sprites.get("icon")
                    if sprite_url:
                        emb.set_thumbnail(url=str(sprite_url))
            except Exception:
                pass

        exp_next_text = "Max" if exp_to_next_val is None else f"{exp_to_next_val:,}"
        nature_text = str(mon.get("nature") or "Unknown").replace("-", " ").title()
        ability_text = str(mon.get("ability") or "Unknown").replace("-", " ").title()

        overview_lines = [
            f"OT: {ot_text}",
            f"Team: {team_text}",
            f"Lock: {'Locked üîí' if is_locked else 'Unlocked'}",
            f"Type: {type_text}",
            f"Tera Type: {tera_text}",
            f"Nature: {nature_text}",
            f"Ability: {ability_text}",
            f"Held Item: {held_field}",
            f"Ball: {ball_field}",
            f"Gender: {gender_display}",
        ]
        if AdminGivePokemon.can_gigantamax(species):
            can_gmax = bool(mon.get("can_gigantamax", 0))
            overview_lines.append(f"Can Gigantamax: {'Yes' if can_gmax else 'No'}")

        emb.add_field(name="Overview", value="\n".join(overview_lines)[:1024], inline=False)
        emb.add_field(
            name="Vitals",
            value=(
                f"HP: **{hp_display}** {hp_bar} ({hp_pct}%)\n"
                f"EXP to next: **{exp_next_text}**\n"
                f"Friendship: **{friendship_text}**\n"
                f"Total IVs: **{total_ivs}/186**"
            )[:1024],
            inline=False,
        )
        emb.add_field(name="Battle Stats", value=f"```{stats_line}```", inline=False)
        emb.add_field(name="IVs", value=f"```{ivs_line}```", inline=True)
        emb.add_field(name="EVs", value=f"```{evs_line}```", inline=True)
        emb.add_field(name="Moves", value=moves_text[:1024] or "‚Äî", inline=False)
        emb.set_footer(text=f"Pokemon ID #{int(mon.get('id') or 0)}")

        await interaction.followup.send(embed=emb, files=files, ephemeral=True)

async def setup(bot: commands.Bot):
    await bot.add_cog(MPokeInfo(bot))


async def _dispatch_mypokeinfo_alias(interaction: Interaction, name: str, slot: Optional[int] = None) -> None:
    cog = bot.get_cog("MPokeInfo")
    last_error: Optional[Exception] = None
    if isinstance(cog, MPokeInfo):
        cmd_obj = getattr(cog, "mpokeinfo", None)
        cb = getattr(cmd_obj, "callback", None)
        if callable(cb):
            try:
                await cb(cog, interaction, name, slot)
                return
            except TypeError as e:
                # Retry positional-style callback invocation only when the
                # TypeError looks like a signature mismatch.
                msg = str(e).lower()
                sig_mismatch = (
                    "positional argument" in msg
                    or "unexpected keyword" in msg
                    or "required positional argument" in msg
                    or ("takes" in msg and "given" in msg)
                )
                if sig_mismatch:
                    try:
                        await cb(interaction, name, slot)
                        return
                    except Exception as e2:
                        last_error = e2
                else:
                    last_error = e
            except Exception as e:
                last_error = e
    if last_error is not None:
        print(f"[mypokeinfo alias] dispatch failed: {last_error!r}")
    timeout_hit = isinstance(last_error, (asyncio.TimeoutError, TimeoutError))
    msg = (
        "‚è≥ Database is busy right now. Please try `/mypokeinfo` again in a few seconds."
        if timeout_hit
        else "‚ùå PK info system is not loaded yet. Try again in a moment."
    )
    try:
        if interaction.response.is_done():
            await interaction.followup.send(msg, ephemeral=True)
        else:
            await interaction.response.send_message(msg, ephemeral=True)
    except Exception:
        pass


async def _dispatch_pokeinfo_alias(
    interaction: Interaction,
    name_or_id: str,
    shiny: bool = False,
    gender: Optional[str] = None,
    gen: Optional[int] = None,
) -> None:
    def _typeerror_is_signature_mismatch(exc: TypeError) -> bool:
        m = str(exc or "").lower()
        return (
            "positional argument" in m
            or "unexpected keyword" in m
            or "required positional argument" in m
            or ("takes" in m and "given" in m)
        )

    cmd_obj = None
    try:
        cmd_obj = bot.tree.get_command("pokeinfo")
    except Exception:
        cmd_obj = None
    if cmd_obj is None:
        try:
            for c in bot.tree.walk_commands():
                if getattr(c, "name", "") == "pokeinfo":
                    cmd_obj = c
                    break
        except Exception:
            cmd_obj = None
    if cmd_obj is None:
        cmd_obj = globals().get("pokeinfo")

    cb = getattr(cmd_obj, "callback", None)
    last_error: Optional[Exception] = None
    if callable(cb):
        try:
            await cb(
                interaction,
                name_or_id=name_or_id,
                shiny=bool(shiny),
                gender=gender,
                gen=gen,
            )
            return
        except TypeError as e:
            # Fallback for callback styles that require positional args.
            if _typeerror_is_signature_mismatch(e):
                try:
                    await cb(interaction, name_or_id, bool(shiny), gender, gen)
                    return
                except Exception as e2:
                    last_error = e2
            else:
                last_error = e
        except Exception as e:
            last_error = e

    if last_error is not None:
        low = str(last_error).lower()
        if isinstance(last_error, (asyncio.TimeoutError, TimeoutError)):
            msg = "‚è≥ Pok√©dex is busy right now. Please try `/pkinfo` again in a few seconds."
        elif (
            "no such table" in low
            or "does not exist" in low
            or "undefined table" in low
            or "relation" in low and "does not exist" in low
        ):
            msg = "‚ö†Ô∏è Pok√©dex data is still loading. Please try `/pkinfo` again in a few seconds."
        else:
            msg = "‚ùå Pok√©dex lookup failed. Please try again."
        try:
            if interaction.response.is_done():
                await interaction.followup.send(msg, ephemeral=True)
            else:
                await interaction.response.send_message(msg, ephemeral=True)
        except Exception:
            pass
        print(f"[pkinfo alias] dispatch failed: {last_error!r}")
        return

    if cmd_obj is None:
        try:
            msg = "‚ùå Pok√©dex info command is not loaded yet. Try again in a moment."
            if interaction.response.is_done():
                await interaction.followup.send(msg, ephemeral=True)
            else:
                await interaction.response.send_message(msg, ephemeral=True)
        except Exception:
            pass
        return

    # Command object exists but had no callable callback.
    try:
        msg = "‚ùå Pok√©dex info command is not loaded yet. Try again in a moment."
        if interaction.response.is_done():
            await interaction.followup.send(msg, ephemeral=True)
        else:
            await interaction.response.send_message(msg, ephemeral=True)
    except Exception:
        pass


@bot.tree.command(name="mpokeinfo", description="Legacy alias for /mypokeinfo (team Pok√©mon details).")
@app_commands.describe(
    name="Pok√©mon species (e.g. pikachu)",
    slot="Team slot (1‚Äì6) if you have duplicates",
)
async def mpokeinfo_alias(interaction: Interaction, name: str, slot: Optional[int] = None):
    await _dispatch_mypokeinfo_alias(interaction, name, slot)


@bot.tree.command(name="pkinfo", description="Alias for /pokeinfo (Pok√©dex species info).")
@app_commands.describe(
    name_or_id="Primary query (name or National Dex number).",
    name="Legacy query field (also accepts name or National Dex number).",
    slot="Legacy slot field from old /pkinfo payloads (ignored).",
    shiny="Show shiny sprite (default: off)",
    gender="Force sprite gender (optional)",
    gen="Also show how many moves are legal in this generation (1‚Äì9)",
)
@app_commands.choices(
    gender=[
        app_commands.Choice(name="male", value="male"),
        app_commands.Choice(name="female", value="female"),
    ]
)
async def pkinfo_alias(
    interaction: Interaction,
    name_or_id: Optional[str] = None,
    name: Optional[str] = None,
    slot: Optional[int] = None,
    shiny: bool = False,
    gender: Optional[str] = None,
    gen: Optional[int] = None,
):
    _ = slot  # legacy option retained for backward compatibility with old payloads
    query = str(name_or_id or name or "").strip()
    if not query:
        try:
            if interaction.response.is_done():
                await interaction.followup.send("‚ùå Please provide a Pok√©mon name or Dex number.", ephemeral=True)
            else:
                await interaction.response.send_message("‚ùå Please provide a Pok√©mon name or Dex number.", ephemeral=True)
        except Exception:
            pass
        return
    await _dispatch_pokeinfo_alias(interaction, query, shiny=shiny, gender=gender, gen=gen)


@bot.tree.command(name="pkname", description="Set or clear a nickname for one of your team Pok√©mon.")
@app_commands.describe(
    name="Pok√©mon species (e.g. pikachu)",
    nickname="New nickname (or: clear/none/reset/remove to remove)",
    slot="Team slot (1‚Äì6) if you have duplicates",
)
async def pkname_command(
    interaction: Interaction,
    name: str,
    nickname: app_commands.Range[str, 1, 40],
    slot: Optional[int] = None,
):
    await interaction.response.defer(ephemeral=True)
    uid = str(interaction.user.id)

    async with db.session() as conn:
        mon = await resolve_team_mon(interaction, name, slot, conn=conn)
        if not mon:
            return
        mon_id = int(mon.get("id") or 0)
        if mon_id <= 0:
            return await interaction.followup.send("‚ùå Could not resolve that Pok√©mon.", ephemeral=True)
        species_norm = _daycare_norm_species(mon.get("species"))
        if species_norm == "egg":
            return await interaction.followup.send("‚ùå Eggs cannot be nicknamed.", ephemeral=True)

        species_display = str(mon.get("species") or "Pok√©mon").replace("-", " ").replace("_", " ").title()
        raw_nick = str(nickname or "").strip()
        clear_tokens = {"clear", "none", "reset", "remove", "off", "default"}
        current_nick = await _get_pokemon_nickname(uid, mon_id, conn=conn)

        if raw_nick.lower() in clear_tokens:
            await _set_pokemon_nickname(uid, mon_id, None, conn=conn)
            await conn.commit()
            if current_nick:
                return await interaction.followup.send(
                    f"üî§ Cleared nickname for **{species_display}**.",
                    ephemeral=True,
                )
            return await interaction.followup.send(
                f"‚ÑπÔ∏è **{species_display}** did not have a nickname set.",
                ephemeral=True,
            )

        cleaned = _normalize_pokemon_nickname(raw_nick, max_len=20)
        if not cleaned:
            return await interaction.followup.send("‚ùå Nickname cannot be empty.", ephemeral=True)

        await _set_pokemon_nickname(uid, mon_id, cleaned, conn=conn)
        await conn.commit()

    await interaction.followup.send(
        f"‚úÖ Nickname set: **{species_display}** ‚Üí **{cleaned}**\n"
        f"Used in `/team` and the `/mypokeinfo` name slot.",
        ephemeral=True,
    )

## Friendship :
def _normalize_item_token(s: Any) -> str:
    token = str(s or "").strip().lower()
    token = re.sub(r"[\s\-]+", "_", token)
    token = re.sub(r"[^a-z0-9_]", "", token)
    return token


def _canonical_item_token(s: Any) -> str:
    raw = str(s or "").strip().lower()
    token = _normalize_item_token(raw)
    if not token:
        return ""
    # First use market alias rules so catalog aliases collapse (pokeball -> poke_ball, etc.).
    try:
        resolved = _catalog_resolve_market_key(token)
    except Exception:
        resolved = token
    if isinstance(resolved, str) and resolved:
        token = resolved
    # Collapse known Pok√© Ball legacy aliases.
    if token in {"pokeball", "pok_ball", "poke_ball"}:
        token = "poke_ball"
    # Collapse PP item aliases (pp-max, ppmax -> pp_max, etc.).
    try:
        pp_canon = _canonical_pp_item_id(token)
        if pp_canon:
            token = pp_canon
    except Exception:
        pass
    # Preserve TM/HM-style IDs that intentionally use hyphens in storage.
    if raw and " " not in raw and token == _normalize_item_token(raw):
        if raw.startswith("tm-") or raw.startswith("hm-"):
            return raw
    return token


def _item_alias_tokens(item_id: Any) -> list[str]:
    canonical = _canonical_item_token(item_id)
    if not canonical:
        return []
    aliases: set[str] = {_normalize_item_token(canonical)}
    try:
        for v in _catalog_market_item_variants(canonical):
            aliases.add(_normalize_item_token(v))
    except Exception:
        pass
    if canonical == "poke_ball":
        aliases.update({"poke_ball", "pokeball", "pok_ball"})
    # Include PP aliases so bag/use counts merge old rows.
    try:
        for a in (_PP_ITEM_ALIASES.get(canonical, ()) or ()):
            aliases.add(_normalize_item_token(a))
    except Exception:
        pass
    return sorted(a for a in aliases if a)


def item_id_from_user(s: str) -> str:
    """Normalize user text -> canonical item id."""
    return _canonical_item_token(s)
def pretty_item(item_id: str | None) -> str:
    if not item_id:
        return "None"
    return item_id.replace("_", " ").title()


_PP_ITEM_ALIASES: dict[str, tuple[str, ...]] = {
    "ether": ("ether",),
    "max_ether": ("max_ether", "max-ether", "maxether"),
    "elixir": ("elixir",),
    "max_elixir": ("max_elixir", "max-elixir", "maxelixir"),
    "pp_up": ("pp_up", "pp-up", "ppup"),
    "pp_max": ("pp_max", "pp-max", "ppmax"),
}


def _norm_move_token(s: str | None) -> str:
    return str(s or "").strip().lower().replace("_", "-").replace(" ", "-")


def _pp_move_base(move_id: str, generation: int) -> int:
    try:
        return max(1, int(_base_pp(move_id, generation=generation)))
    except Exception:
        return 20


def _pp_move_global_max(move_id: str, generation: int) -> int:
    try:
        return max(1, int(_max_pp(move_id, generation=generation)))
    except Exception:
        return max(1, _pp_move_base(move_id, generation))


def _pp_parse_int_list(
    raw: Any,
    *,
    count: int,
    defaults: list[int],
    lo: int,
    hi: int,
) -> list[int]:
    vals = raw
    if isinstance(vals, str):
        try:
            vals = json.loads(vals) if vals else []
        except Exception:
            vals = []
    if not isinstance(vals, (list, tuple)):
        vals = []
    out: list[int] = []
    for i in range(int(count)):
        default_i = int(defaults[i]) if i < len(defaults) else int(defaults[-1] if defaults else lo)
        v = vals[i] if i < len(vals) else default_i
        try:
            n = int(v)
        except Exception:
            n = default_i
        out.append(max(int(lo), min(int(hi), int(n))))
    return out


def _canonical_pp_item_id(item_query: str | None) -> str:
    token = _normalize_item_token(str(item_query or ""))
    compact = token.replace("_", "")
    for canon, aliases in _PP_ITEM_ALIASES.items():
        for alias in aliases:
            a = alias.lower().replace("-", "_").strip()
            if token == a or compact == a.replace("_", ""):
                return canon
    return ""


async def _resolve_pp_item_in_bag_conn(conn, owner_id: str, canonical_item_id: str) -> tuple[str, int]:
    aliases = _PP_ITEM_ALIASES.get(str(canonical_item_id or "").strip(), ())
    if not aliases:
        return "", 0
    lowered = [a.lower().replace("-", "_").strip() for a in aliases if a]
    lowered = list(dict.fromkeys([a for a in lowered if a]))
    if not lowered:
        return "", 0
    placeholders = ", ".join("?" for _ in lowered)
    cur = await conn.execute(
        f"SELECT item_id, qty FROM user_items WHERE owner_id=? AND LOWER(REPLACE(item_id, '-', '_')) IN ({placeholders})",
        (str(owner_id), *lowered),
    )
    rows = await cur.fetchall()
    await cur.close()
    best_item_id = ""
    best_qty = 0
    for row in rows or []:
        d = dict(row) if hasattr(row, "keys") else {}
        iid = str(d.get("item_id") or "").strip()
        try:
            qty = int(d.get("qty") or 0)
        except Exception:
            qty = 0
        if qty > best_qty and iid:
            best_item_id = iid
            best_qty = qty
    return best_item_id, best_qty


# Helpers: ISO parsing and cooldown/daily-cap checks using event_log
def _now_utc(): return dt.datetime.now(dt.timezone.utc)
def _parse_iso_z(s: str): return dt.datetime.fromisoformat(s.replace("Z", "+00:00"))

async def _action_window(user_id: str, mon_id: int, action: str, since_hours: int = 24):
    conn = await db.connect()
    try:
        cur = await conn.execute(
            "SELECT payload, created_at FROM event_log WHERE user_id=? AND type=? "
            "ORDER BY id DESC LIMIT 200",
            (user_id, action),
        )
        rows = await cur.fetchall(); await cur.close()
        cutoff = _now_utc() - dt.timedelta(hours=since_hours)
        last_time, count_in_window = None, 0
        for r in rows:
            created = _parse_iso_z(r["created_at"])
            if created < cutoff:
                break
            try:
                payload = json.loads(r["payload"])
            except Exception:
                payload = {}
            if str(payload.get("mon_id")) == str(mon_id):
                count_in_window += 1
                if last_time is None:
                    last_time = created
        return last_time, count_in_window
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _check_limit_and_cooldown(user_id: str, mon_id: int, action: str,
                                    cooldown_seconds: int, daily_cap: int):
    last_time, used_today = await _action_window(user_id, mon_id, action, 24)
    remain = 0
    if last_time:
        elapsed = (_now_utc() - last_time).total_seconds()
        if elapsed < cooldown_seconds:
            remain = int(cooldown_seconds - elapsed)
    ok = (remain == 0) and (used_today < daily_cap)
    return ok, remain, used_today

async def _award_friendship(inter: discord.Interaction, mon_id: int, delta: int,
                            action: str, extra: dict | None = None):
    uid = str(inter.user.id)
    raw_delta = int(delta or 0)
    ball_item_id: Optional[str] = None
    if raw_delta > 0:
        try:
            ball_item_id = await _get_pokemon_ball(uid, mon_id)
        except Exception:
            ball_item_id = None
    applied_delta = _friendship_delta_with_ball_bonus(raw_delta, ball_item_id)
    new_val = await db.bump_friendship(uid, mon_id, applied_delta)
    payload = {"mon_id": mon_id, "delta": applied_delta}
    if applied_delta != raw_delta:
        payload["ball_bonus"] = int(applied_delta - raw_delta)
    if ball_item_id:
        payload["ball"] = _normalize_ball_item_id(ball_item_id)
    if extra: payload.update(extra)
    await db.log_event(uid, action, payload)
    return new_val, applied_delta


# ---------- /pet ----------
@bot.tree.command(name="pet", description="Pet a Pok√©mon in your team.")
@app_commands.describe(name="Pok√©mon name in your team (e.g. pikachu)", slot="If duplicates, which team slot (1‚Äì6)")
async def pet_cmd(inter: discord.Interaction, name: str, slot: int | None = None):
    mon = await resolve_team_mon(inter, name, slot)
    if not mon:
        return

    # Set friendship to max (255)
    await _set_friendship(str(inter.user.id), mon["id"], 255)
    auto = f" (autocorrected to **{mon['_autocorrected_to']}**)" if mon.get("_autocorrected_to") else ""
    await inter.followup.send(f"‚ú® **{mon['species'].title()}** enjoys the pats{auto}! Friendship set to **255** (max).", ephemeral=True)

# ---------- /feed ----------
_FEED_ITEMS = {
    "oran_berry": 2,
    "sitrus_berry": 4,
    "poffin_sweet": 6,
    "poffin_dry": 6,
    "poffin_spicy": 6,
}

@bot.tree.command(name="feed", description="Feed a berry/poffin to a Pok√©mon in your team (15m cd, 10/day).")
@app_commands.describe(
    name="Pok√©mon name in your team (e.g. pikachu)",
    item="Item name (e.g., Oran Berry, Sitrus Berry, Poffin Sweet ‚Ä¶)",
    slot="If duplicates, which team slot (1‚Äì6)"
)
async def feed_cmd(inter: discord.Interaction, name: str, item: str, slot: int | None = None):
    mon = await resolve_team_mon(inter, name, slot)
    if not mon:
        return

    item_id = item_id_from_user(item)  # normalize text -> id
    if item_id not in _FEED_ITEMS:
        return await inter.followup.send(
            "That item can‚Äôt be used for friendship. Try **Oran Berry**, **Sitrus Berry**, or a **Poffin**.",
            ephemeral=True
        )

    ok, remain, used = await _check_limit_and_cooldown(str(inter.user.id), mon["id"], "friend_feed",
                                                       cooldown_seconds=900, daily_cap=10)
    if not ok:
        if used >= 10:
            return await inter.followup.send("You‚Äôve reached today‚Äôs feeding limit for this Pok√©mon (10/day).", ephemeral=True)
        mm, ss = divmod(remain, 60)
        return await inter.followup.send(f"You can feed again in **{mm}m {ss}s**.", ephemeral=True)

    had = await db.take_item(str(inter.user.id), item_id, qty=1)
    if not had:
        return await inter.followup.send(f"You don‚Äôt have a **{pretty_item(item_id)}**.", ephemeral=True)

    gain = _FEED_ITEMS[item_id]
    new_val, applied_gain = await _award_friendship(inter, mon["id"], gain, "friend_feed", {"item": item_id})
    auto = f" (autocorrected to **{mon['_autocorrected_to']}**)" if mon.get("_autocorrected_to") else ""
    gain_suffix = ""
    if applied_gain != gain:
        gain_suffix = f" (including +{applied_gain - gain} Luxury Ball bonus)"
    await inter.followup.send(
        f"üçì **{mon['species'].title()}** ate the {pretty_item(item_id)}{auto}! Friendship **+{applied_gain}**{gain_suffix} ‚Üí **{new_val}**.",
        ephemeral=True
    )

# ---------- /walk ----------
@bot.tree.command(name="walk", description="Walk with a Pok√©mon in your team.")
@app_commands.describe(name="Pok√©mon name in your team (e.g. pikachu)", slot="If duplicates, which team slot (1‚Äì6)")
async def walk_cmd(inter: discord.Interaction, name: str, slot: int | None = None):
    mon = await resolve_team_mon(inter, name, slot)
    if not mon:
        return

    # Set friendship to 0
    await _set_friendship(str(inter.user.id), mon["id"], 0)
    auto = f" (autocorrected to **{mon['_autocorrected_to']}**)" if mon.get("_autocorrected_to") else ""
    await inter.followup.send(
        f"üëü You walked with **{mon['species'].title()}**{auto}. Friendship set to **0**.",
        ephemeral=True
    )


@bot.tree.command(name="useppitem", description="Use Ether/Elixir/PP items on a team Pok√©mon.")
@app_commands.describe(
    name="Pok√©mon name in your team (e.g. pikachu)",
    item="PP item (Ether, Max Ether, Elixir, Max Elixir, PP Up, PP Max)",
    move="Move name (required for Ether, Max Ether, PP Up, PP Max)",
    slot="If duplicates, which team slot (1‚Äì6)",
)
async def useppitem_cmd(
    inter: discord.Interaction,
    name: str,
    item: str,
    move: str | None = None,
    slot: int | None = None,
):
    await inter.response.defer(ephemeral=True, thinking=False)
    mon = await resolve_team_mon(inter, name, slot)
    if not mon:
        return

    uid = str(inter.user.id)
    mon_id = int(mon.get("id") or 0)
    if mon_id <= 0:
        return await inter.followup.send("‚ùå Could not resolve that Pok√©mon.", ephemeral=True)

    canonical = _canonical_pp_item_id(item)
    if not canonical:
        return await inter.followup.send(
            "‚ùå Unsupported PP item. Use: **Ether**, **Max Ether**, **Elixir**, **Max Elixir**, **PP Up**, or **PP Max**.",
            ephemeral=True,
        )

    single_move_item = canonical in {"ether", "max_ether", "pp_up", "pp_max"}
    if single_move_item and not str(move or "").strip():
        return await inter.followup.send(
            "‚ùå That item needs a target move. Example: `/useppitem name:pikachu item:pp up move:thunderbolt`",
            ephemeral=True,
        )

    try:
        user_gen = int(await _user_selected_gen(uid))
    except Exception:
        user_gen = 1

    async with DB_WRITE_LOCK:
        async with db.session() as conn:
            try:
                cur = await conn.execute(
                    "SELECT id, species, moves, moves_pp, moves_pp_min, moves_pp_max FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                    (uid, mon_id),
                )
            except Exception:
                cur = await conn.execute(
                    "SELECT id, species, moves, moves_pp FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                    (uid, mon_id),
                )
            row = await cur.fetchone()
            await cur.close()
            if not row:
                return await inter.followup.send("‚ùå Pok√©mon not found in your team.", ephemeral=True)
            row_d = dict(row) if hasattr(row, "keys") else {}

            bag_item_id, bag_qty = await _resolve_pp_item_in_bag_conn(conn, uid, canonical)
            if bag_qty <= 0 or not bag_item_id:
                pretty = pretty_item(canonical)
                return await inter.followup.send(f"‚ùå You don‚Äôt have **{pretty}** in your bag.", ephemeral=True)

            try:
                moves_raw = row_d.get("moves")
                moves = json.loads(moves_raw) if isinstance(moves_raw, str) else moves_raw
            except Exception:
                moves = []
            if not isinstance(moves, list) or not moves:
                return await inter.followup.send("‚ùå This Pok√©mon has no usable move data.", ephemeral=True)
            move_ids = [str(m).strip().replace("_", "-").replace(" ", "-").lower() for m in moves[:4] if str(m).strip()]
            if not move_ids:
                return await inter.followup.send("‚ùå This Pok√©mon has no usable move data.", ephemeral=True)
            move_names = [m.replace("-", " ").title() for m in move_ids]

            base_pps: list[int] = []
            global_max_pps: list[int] = []
            for mv in move_ids:
                base_pps.append(_pp_move_base(mv, user_gen))
                global_max_pps.append(_pp_move_global_max(mv, user_gen))

            stored_max_pps = _pp_parse_int_list(
                row_d.get("moves_pp_max"),
                count=len(move_ids),
                defaults=base_pps,
                lo=1,
                hi=999,
            )
            for i in range(len(stored_max_pps)):
                stored_max_pps[i] = max(base_pps[i], min(stored_max_pps[i], global_max_pps[i]))

            stored_min_pps = _pp_parse_int_list(
                row_d.get("moves_pp_min"),
                count=len(move_ids),
                defaults=[0] * len(move_ids),
                lo=0,
                hi=999,
            )
            for i in range(len(stored_min_pps)):
                stored_min_pps[i] = max(0, min(stored_min_pps[i], stored_max_pps[i]))

            cur_pps = _pp_parse_int_list(
                row_d.get("moves_pp"),
                count=len(move_ids),
                defaults=stored_max_pps,
                lo=0,
                hi=999,
            )
            for i in range(len(cur_pps)):
                cur_pps[i] = max(stored_min_pps[i], min(cur_pps[i], stored_max_pps[i]))

            target_indices: list[int]
            if single_move_item:
                wanted = _norm_move_token(move)
                idx = -1
                for i, mid in enumerate(move_ids):
                    if _norm_move_token(mid) == wanted or _norm_move_token(mid.replace("-", " ")) == wanted:
                        idx = i
                        break
                if idx < 0:
                    move_list = ", ".join(f"`{m}`" for m in move_names)
                    return await inter.followup.send(
                        f"‚ùå Move not found on this Pok√©mon. Available moves: {move_list}",
                        ephemeral=True,
                    )
                target_indices = [idx]
            else:
                target_indices = list(range(len(move_ids)))

            before_pps = list(cur_pps)
            changed = False
            changed_lines: list[str] = []
            for i in target_indices:
                before = cur_pps[i]
                cap_before = stored_max_pps[i]
                base_cap = base_pps[i]
                global_cap = global_max_pps[i]
                min_cap = stored_min_pps[i]
                cap_after = cap_before
                after = before
                if canonical in {"ether", "elixir"}:
                    after = min(cap_before, before + 10)
                elif canonical in {"max_ether", "max_elixir"}:
                    after = cap_before
                elif canonical == "pp_up":
                    # Increase move PP cap by one PP-Up step, then grant that gain immediately.
                    pp_up_step = max(1, int(base_cap // 5))
                    cap_after = min(global_cap, cap_before + pp_up_step)
                    cap_gain = max(0, cap_after - cap_before)
                    after = min(cap_after, before + cap_gain)
                elif canonical == "pp_max":
                    cap_after = int(global_cap)
                    after = int(cap_after)
                after = max(min_cap, min(after, cap_after))
                if cap_after != cap_before:
                    stored_max_pps[i] = cap_after
                if after > before or cap_after != cap_before:
                    changed = True
                    cur_pps[i] = after
                    changed_lines.append(f"‚Ä¢ **{move_names[i]}**: {before}/{cap_before} ‚Üí {after}/{cap_after}")

            if not changed:
                if canonical in {"pp_up", "pp_max"} and target_indices:
                    i = target_indices[0]
                    return await inter.followup.send(
                        f"‚ÑπÔ∏è **{move_names[i]}** is already at max PP (**{before_pps[i]}/{stored_max_pps[i]}**). "
                        f"**{pretty_item(canonical)}** was not consumed.",
                        ephemeral=True,
                    )
                return await inter.followup.send(
                    f"‚ÑπÔ∏è No PP could be restored. **{pretty_item(canonical)}** was not consumed.",
                    ephemeral=True,
                )

            try:
                await conn.execute(
                    "UPDATE pokemons SET moves_pp=?, moves_pp_min=?, moves_pp_max=? WHERE owner_id=? AND id=?",
                    (
                        json.dumps(cur_pps, ensure_ascii=False),
                        json.dumps(stored_min_pps, ensure_ascii=False),
                        json.dumps(stored_max_pps, ensure_ascii=False),
                        uid,
                        int(row_d.get("id") or mon_id),
                    ),
                )
            except Exception:
                await conn.execute(
                    "UPDATE pokemons SET moves_pp=? WHERE owner_id=? AND id=?",
                    (json.dumps(cur_pps, ensure_ascii=False), uid, int(row_d.get("id") or mon_id)),
                )
            await conn.execute(
                "UPDATE user_items SET qty = GREATEST(0, qty - 1) WHERE owner_id=? AND item_id=? AND qty>=1",
                (uid, bag_item_id),
            )
            await conn.commit()

    try:
        db.invalidate_bag_cache(uid)
        db.invalidate_pokemons_cache(uid)
    except Exception:
        pass

    item_disp = pretty_item(canonical)
    species_disp = str(mon.get("species") or "Pok√©mon").replace("-", " ").title()
    if len(changed_lines) == 1:
        msg = f"‚úÖ Used **{item_disp}** on **{species_disp}**.\n{changed_lines[0]}"
    else:
        msg = f"‚úÖ Used **{item_disp}** on **{species_disp}**.\n" + "\n".join(changed_lines[:4])
    await inter.followup.send(msg, ephemeral=True)


async def _consume_item_for_evolution(owner_id: str, item_id: str) -> bool:
    """
    Consume one item for /evolve.
    Uses db.take_item when available; falls back to the local decrement helper.
    """
    item_key = str(item_id or "").strip().lower()
    if not item_key:
        return False
    take_fn = getattr(db, "take_item", None)
    if callable(take_fn):
        try:
            return bool(await take_fn(owner_id, item_key, qty=1))
        except TypeError:
            try:
                return bool(await take_fn(owner_id, item_key, 1))
            except Exception:
                pass
        except Exception:
            pass
    try:
        return bool(await _decrement_user_item(owner_id, item_key, 1))
    except Exception:
        return False


@bot.tree.command(name="evolve", description="Evolve a team Pok√©mon using level conditions or an evolution item.")
@app_commands.describe(
    name="Pok√©mon name in your team (e.g. eevee)",
    slot="If duplicates, which team slot (1‚Äì6)",
    item="Optional evolution item (e.g. Thunder Stone)",
)
async def evolve_cmd(inter: discord.Interaction, name: str, slot: int | None = None, item: str | None = None):
    try:
        mon = await resolve_team_mon(inter, name, slot)
        if not mon:
            return

        uid = str(inter.user.id)
        mon_id = int(mon["id"])
        auto_mon = f" (autocorrected to **{mon['_autocorrected_to']}**)" if mon.get("_autocorrected_to") else ""

        area_id: Optional[str] = None
        try:
            state = await _get_adventure_state(uid)
            if isinstance(state, dict):
                area_id = str(state.get("area_id") or "").strip() or None
        except Exception:
            area_id = None

        async with db.session() as conn:
            cur = await conn.execute(
                """
                SELECT species, level, friendship, gender, held_item, moves
                FROM pokemons
                WHERE owner_id=? AND id=?
                LIMIT 1
                """,
                (uid, mon_id),
            )
            row = await cur.fetchone()
            await cur.close()
            if not row:
                return await inter.followup.send("‚ùå Pok√©mon not found in your team.", ephemeral=True)

            species_raw = str((row["species"] if hasattr(row, "keys") else row[0]) or "").strip()
            species = _daycare_norm_species(species_raw)
            level_raw = row["level"] if hasattr(row, "keys") else row[1]
            friendship_raw = row["friendship"] if hasattr(row, "keys") else row[2]
            gender = str((row["gender"] if hasattr(row, "keys") else row[3]) or "").strip().lower() or None
            held_item = str((row["held_item"] if hasattr(row, "keys") else row[4]) or "").strip().lower() or None
            moves_raw = row["moves"] if hasattr(row, "keys") else row[5]
            try:
                level = int(level_raw or 1)
            except Exception:
                level = 1
            try:
                friendship = int(friendship_raw) if friendship_raw is not None else None
            except Exception:
                friendship = None

            item_id: Optional[str] = None
            item_disp: Optional[str] = None
            auto_item_note = ""
            evo_target: Optional[str] = None

            if item and str(item).strip():
                item_row, auto_item, suggestions = await _resolve_item_fuzzy(conn, str(item), threshold=0.80)
                if not item_row:
                    if suggestions:
                        return await inter.followup.send(
                            f"‚ùå I couldn't find that item. Did you mean: {', '.join(suggestions)}?",
                            ephemeral=True,
                        )
                    return await inter.followup.send("‚ùå I couldn't find that item.", ephemeral=True)
                item_id = str(item_row.get("id") or "").strip().lower()
                if not item_id:
                    return await inter.followup.send("‚ùå Invalid evolution item.", ephemeral=True)
                item_disp = pretty_item_name(item_row.get("name") or item_id)
                if auto_item:
                    auto_item_note = f" (autocorrected item to **{auto_item}**)"

                qty = await _get_item_qty(uid, item_id, conn=conn)
                if qty <= 0:
                    return await inter.followup.send(
                        f"‚ùå You don‚Äôt have **{item_disp}** in your bag.",
                        ephemeral=True,
                    )
                evo_target = await _get_item_use_evolution(
                    conn,
                    species,
                    item_id,
                    friendship=friendship,
                    gender=gender,
                    moves=moves_raw,
                    held_item=held_item,
                    area_id=area_id,
                )
                if not evo_target:
                    pretty_species = species_raw.replace("-", " ").title()
                    return await inter.followup.send(
                        f"‚ùå **{pretty_species}** can't evolve with **{item_disp}** right now{auto_item_note}.",
                        ephemeral=True,
                    )
            else:
                evo_target = await _get_level_up_evolution(
                    conn,
                    species,
                    level,
                    friendship=friendship,
                    gender=gender,
                    moves=moves_raw,
                    held_item=held_item,
                    area_id=area_id,
                )
                if not evo_target:
                    item_hint = await _get_any_item_evolution_target(conn, species)
                    hint_line = ""
                    if item_hint:
                        hint_line = f" Try using `/evolve` with item **{pretty_item_name(item_hint)}**."
                    pretty_species = species_raw.replace("-", " ").title()
                    return await inter.followup.send(
                        f"‚ùå **{pretty_species}** doesn't meet any evolution conditions right now.{hint_line}",
                        ephemeral=True,
                    )

        consumed_item = False
        if item_id:
            consumed_item = await _consume_item_for_evolution(uid, item_id)
            if not consumed_item:
                return await inter.followup.send("‚ùå You no longer have that item in your bag.", ephemeral=True)

        applied = await _apply_evolution(uid, mon_id, evo_target, level)
        if not applied:
            if consumed_item and item_id:
                try:
                    await db.give_item(uid, item_id, 1)
                except Exception:
                    pass
            return await inter.followup.send("‚ùå Evolution failed. Please try again.", ephemeral=True)

        from_name = species_raw.replace("-", " ").title()
        to_name = str(evo_target).replace("-", " ").title()
        item_note = f" using **{item_disp}**{auto_item_note}" if item_id else ""
        await inter.followup.send(
            f"‚ú® **{from_name}** evolved into **{to_name}**{item_note}{auto_mon}!",
            ephemeral=True,
        )
    except Exception as e:
        import traceback
        traceback.print_exc()
        msg = f"‚ùå Evolution command failed: {type(e).__name__}."
        try:
            if inter.response.is_done():
                await inter.followup.send(msg, ephemeral=True)
            else:
                await inter.response.send_message(msg, ephemeral=True)
        except Exception:
            pass


def _team_species_label(row: dict) -> str:
    nick = str(row.get("nickname") or "").strip()
    if nick and _daycare_norm_species(row.get("species")) != "egg":
        return nick
    species = str(row.get("species") or "Unknown").replace("-", " ").replace("_", " ").title()
    form = str(row.get("form") or "").strip()
    form_norm = form.lower().replace("_", "-").strip()
    species_norm = str(row.get("species") or "").strip().lower().replace("_", "-")
    # Mimikyu's default visual state is the Disguised form; keep the label as plain "Mimikyu".
    if species_norm == "mimikyu" and (
        form_norm in {"disguised", "mimikyu-disguised", "disguised-form", "mimikyu-disguised-form"}
        or "disguised" in form_norm
    ):
        return "Mimikyu"
    if form:
        form_title = form.replace("-", " ").replace("_", " ").title()
        if form_title.lower() not in species.lower():
            species = f"{species} ({form_title})"
    return species


def _team_parse_moves(raw: Any) -> list[str]:
    moves = raw
    if isinstance(moves, str):
        try:
            moves = json.loads(moves)
        except Exception:
            moves = [moves]
    if not isinstance(moves, (list, tuple)):
        return []
    out: list[str] = []
    for m in moves[:4]:
        if isinstance(m, str):
            name = m.strip()
        elif isinstance(m, dict):
            name = str(m.get("name") or "").strip()
        else:
            name = str(m).strip()
        if name:
            out.append(name.replace("-", " ").title())
    return out


def _team_parse_move_ids(raw: Any) -> list[str]:
    moves = raw
    if isinstance(moves, str):
        try:
            moves = json.loads(moves)
        except Exception:
            moves = [moves]
    if not isinstance(moves, (list, tuple)):
        return []
    out: list[str] = []
    for m in moves[:4]:
        if isinstance(m, str):
            name = m.strip()
        elif isinstance(m, dict):
            name = str(m.get("name") or "").strip()
        else:
            name = str(m).strip()
        if not name:
            continue
        out.append(name.replace("_", "-").replace(" ", "-").lower())
    return out


def _team_parse_moves_pp(raw: Any) -> list[int]:
    pps = raw
    if isinstance(pps, str):
        try:
            pps = json.loads(pps) if pps else []
        except Exception:
            pps = []
    if not isinstance(pps, (list, tuple)):
        return []
    out: list[int] = []
    for v in list(pps)[:4]:
        try:
            out.append(max(0, int(v)))
        except Exception:
            out.append(0)
    return out


def _team_pp_cap_for_move(move_id: str, generation: int, stored_max: Any = None) -> int:
    base_cap = _pp_move_base(move_id, generation)
    global_cap = _pp_move_global_max(move_id, generation)
    try:
        stored = int(stored_max)
    except Exception:
        stored = base_cap
    return max(base_cap, min(stored, global_cap))


def _team_hp_values(row: dict) -> tuple[int, int, int]:
    try:
        hp_max = int(row.get("hp") or 1)
    except Exception:
        hp_max = 1
    hp_max = max(1, hp_max)
    try:
        hp_now = int(row.get("hp_now") if row.get("hp_now") is not None else hp_max)
    except Exception:
        hp_now = hp_max
    hp_now = max(0, min(hp_now, hp_max))
    pct = int(round((hp_now / max(1, hp_max)) * 100))
    return hp_now, hp_max, pct


def _team_hp_bar(pct: int, width: int = 10) -> str:
    pct = max(0, min(100, int(pct)))
    filled = int(round((pct / 100.0) * width))
    return "‚ñà" * filled + "‚ñë" * (width - filled)


TEAM_TEMPLATE_PATHS: tuple[Path, ...] = (
    ASSETS_DIR / "ui" / "team-beta.png",
    ASSETS_DIR / "ui" / "team-beta",
    ASSETS_DIR / "ui" / "team-template.png",
    ASSETS_DIR / "ui" / "team_panel_template.png",
    ASSETS_DIR / "team-template.png",
)
TEAM_TEMPLATE_BASE_SIZE: tuple[int, int] = (808, 537)
TEAM_TEMPLATE_STEM_BASE_SIZES: dict[str, tuple[int, int]] = {
    "team-beta": (800, 488),
    "textual-ui": (800, 488),
    "team-template": (808, 537),
    "team_panel_template": (808, 537),
}
TEAM_TRAINER_HEADER_RECT = (42, 34, 212, 84)
TEAM_TRAINER_ART_RECT = (42, 85, 212, 410)
TEAM_TRAINER_FOOTER_RECT = (42, 430, 212, 491)
TEAM_TRAINER_NAME_CENTER_X = 127
TEAM_TRAINER_LABEL_Y = 38
TEAM_TRAINER_NAME_Y = 62
TEAM_REGION_BY_GEN: dict[int, str] = {
    1: "Kanto",
    2: "Johto",
    3: "Hoenn",
    4: "Sinnoh",
    5: "Unova",
    6: "Kalos",
    7: "Alola",
    8: "Galar",
    9: "Paldea",
}
TEAM_SHOWDOWN_CACHE_DIR = ASSETS_DIR / "ui" / "team-anim-cache"
TEAM_SHOWDOWN_STYLE_DIR = "gen5ani"
TEAM_SHOWDOWN_UA = "Mozilla/5.0 (DexEmAll Team Renderer)"
_TEAM_SHOWDOWN_MISS_KEYS: set[str] = set()


def _battle_sync_frame_duration_ms() -> int:
    """Match team/daycare animation cadence to battle renderer default."""
    try:
        fn = globals().get("render_turn_gif")
        if callable(fn):
            sig = inspect.signature(fn)
            p = sig.parameters.get("duration_ms")
            if p is not None and p.default is not inspect._empty:
                return max(40, min(220, int(p.default)))
    except Exception:
        pass
    return 100


TEAM_BATTLE_SYNC_DURATION_MS = _battle_sync_frame_duration_ms()
TEAM_DEFAULT_FRAME_DURATION_MS = TEAM_BATTLE_SYNC_DURATION_MS
TEAM_MIN_FRAME_DURATION_MS = TEAM_BATTLE_SYNC_DURATION_MS
TEAM_MAX_FRAME_DURATION_MS = TEAM_BATTLE_SYNC_DURATION_MS
# Keep enough frames to preserve full loops for longer Showdown GIFs (e.g. Rattata).
TEAM_MAX_SPRITE_FRAMES = 128
TEAM_MAX_COMPOSITE_FRAMES = 128
TEAM_FETCH_SHOWDOWN_FOR_TEAM = False
TEAM_OVERVIEW_CACHE_TTL_SECONDS = 180.0
TEAM_WARM_CACHE_INTERVAL_SECONDS = 120.0
TEAM_SLOT_LAYOUT: tuple[dict[str, tuple[int, int]], ...] = (
    {"box_xy": (236, 93), "box_wh": (177, 197), "sprite_c": (324, 173), "label_xy": (242, 243), "level_right": (402, 243)},
    {"box_xy": (415, 93), "box_wh": (177, 197), "sprite_c": (503, 173), "label_xy": (420, 243), "level_right": (581, 243)},
    {"box_xy": (593, 93), "box_wh": (177, 197), "sprite_c": (681, 173), "label_xy": (598, 243), "level_right": (759, 243)},
    {"box_xy": (236, 294), "box_wh": (177, 197), "sprite_c": (324, 374), "label_xy": (242, 444), "level_right": (402, 444)},
    {"box_xy": (415, 294), "box_wh": (177, 197), "sprite_c": (503, 374), "label_xy": (420, 444), "level_right": (581, 444)},
    {"box_xy": (593, 294), "box_wh": (177, 197), "sprite_c": (681, 374), "label_xy": (598, 444), "level_right": (759, 444)},
)
TEAM_EGG_STAGE_PATHS: tuple[Path, ...] = (
    ASSETS_EGG_STAGE_1_INTACT,
    ASSETS_EGG_STAGE_2_SLIGHT,
    ASSETS_EGG_STAGE_3_CRACKED,
    ASSETS_EGG_STAGE_4_MORE,
    ASSETS_EGG_STAGE_5_HEAVY,
    ASSETS_EGG_STAGE_6_EXTREME,
)
TEAM_EGG_STAGE_LABELS: tuple[str, ...] = (
    "Intact",
    "Slightly cracked",
    "Cracked",
    "More cracked",
    "Heavily cracked",
    "Extremely cracked",
)

_TEAM_OVERVIEW_RENDER_CACHE: dict[str, tuple[float, bytes, str]] = {}
_TEAM_WARM_CACHE_TS: dict[str, float] = {}

MPOKEINFO_RENDER_CACHE_TTL_SECONDS = 120.0
MPOKEINFO_RENDER_CACHE_MAX_ENTRIES = 64
_MPOKEINFO_RENDER_CACHE: dict[str, tuple[float, bytes, str]] = {}

REGISTER_PANEL_RENDER_CACHE_TTL_SECONDS = 120.0
REGISTER_PANEL_RENDER_CACHE_MAX_ENTRIES = 64
_REGISTER_PANEL_RENDER_CACHE: dict[str, tuple[float, bytes, str]] = {}


def _binary_render_cache_get(
    cache: dict[str, tuple[float, bytes, str]],
    key: str,
    *,
    ttl_seconds: float,
) -> tuple[bytes, str] | None:
    entry = cache.get(str(key))
    if not entry:
        return None
    ts, data, ext = entry
    if (float(time.time()) - float(ts)) > float(ttl_seconds):
        cache.pop(str(key), None)
        return None
    if not data:
        cache.pop(str(key), None)
        return None
    return data, ext


def _binary_render_cache_set(
    cache: dict[str, tuple[float, bytes, str]],
    key: str,
    data: bytes,
    ext: str,
    *,
    max_entries: int,
) -> None:
    if not data:
        return
    cache[str(key)] = (float(time.time()), bytes(data), str(ext))
    if len(cache) <= int(max_entries):
        return
    old_keys = sorted(cache.items(), key=lambda kv: kv[1][0])[: max(1, int(max_entries // 2))]
    for k, _ in old_keys:
        cache.pop(k, None)


def _team_region_for_gen(gen: Optional[int]) -> str:
    try:
        g = int(gen or 0)
    except Exception:
        return "Unknown"
    return TEAM_REGION_BY_GEN.get(g, "Unknown")


def _team_species_visual_scale(row: dict) -> float:
    """
    Compute a per-species sprite scale factor for /team overview.
    Uses cached Pok√©dex height when available so larger Pok√©mon render bigger.
    """
    if _team_is_egg_row(row):
        # Keep eggs noticeably smaller so they don't dominate slot circles.
        return 0.68
    if db_cache is None:
        species_norm = _daycare_norm_species(row.get("species"))
        if species_norm == "charmander":
            return 0.74
        if species_norm == "stakataka":
            return 0.86
        return 1.0
    species_raw = str(row.get("species") or "").strip().lower().replace("_", "-")
    if not species_raw:
        return 1.0
    species_norm = _daycare_norm_species(species_raw)
    # Wide/tall forms like Stakataka can clip into the name strip if rendered by
    # generic height scaling, so cap them with a hand-tuned value.
    if species_norm == "charmander":
        return 0.74
    if species_norm == "stakataka":
        return 0.86
    candidates = [
        species_raw,
        species_raw.replace("-", " "),
        _daycare_norm_species(species_raw),
    ]
    height_m: Optional[float] = None
    for key in candidates:
        if not key:
            continue
        try:
            entry = db_cache.get_cached_pokedex(key)
        except Exception:
            entry = None
        if not entry:
            continue
        for hk in ("height_m", "heightMeters", "height_meters", "height", "height_dm"):
            raw_h = entry.get(hk)
            if raw_h in (None, "", 0, "0"):
                continue
            try:
                h = float(raw_h)
            except Exception:
                continue
            # Some datasets store decimeters as integer in "height".
            if hk in ("height", "height_dm") and h > 20.0:
                h = h / 10.0
            if hk in ("height", "height_dm") and h > 8.0:
                h = h / 10.0
            if h > 0:
                height_m = h
                break
        if height_m is not None:
            break
    if height_m is None:
        return 1.0
    h = max(0.2, min(6.0, float(height_m)))
    denom = (math.log1p(6.0) - math.log1p(0.2)) or 1.0
    norm = (math.log1p(h) - math.log1p(0.2)) / denom
    return max(0.78, min(1.34, 0.80 + (0.54 * norm)))


def _team_is_egg_row(row: dict) -> bool:
    return _daycare_norm_species(row.get("species")) == "egg"


def _team_egg_stage(row: dict) -> int:
    if not _team_is_egg_row(row):
        return 0
    max_stage = max(0, len(TEAM_EGG_STAGE_PATHS) - 1)
    try:
        stage = int(row.get("_egg_stage"))
        return max(0, min(max_stage, stage))
    except Exception:
        pass
    try:
        progress = float(row.get("_egg_progress") or 0.0)
        hatch_steps = max(1.0, float(row.get("_egg_hatch_steps") or 0.0))
        ratio = max(0.0, min(1.0, progress / hatch_steps))
    except Exception:
        ratio = 0.0
    if ratio < 0.20:
        return 0
    if ratio < 0.40:
        return 1
    if ratio < 0.60:
        return 2
    if ratio < 0.80:
        return 3
    if ratio < 0.99:
        return 4
    return 5


def _team_egg_progress_pct(row: dict) -> int:
    if not _team_is_egg_row(row):
        return 0
    try:
        progress = float(row.get("_egg_progress") or 0.0)
        hatch_steps = max(1.0, float(row.get("_egg_hatch_steps") or 0.0))
        return max(0, min(100, int(round((progress / hatch_steps) * 100.0))))
    except Exception:
        return 0


def _team_showdown_key_variants(token: str) -> list[str]:
    t = str(token or "").strip().lower()
    if not t:
        return []
    t = t.replace("‚ôÄ", "-f").replace("‚ôÇ", "-m")
    t = t.replace("‚Äô", "").replace("'", "")
    t = t.replace(".", "").replace(":", "").replace("%", "")
    t = t.replace(" ", "-").replace("_", "-")
    while "--" in t:
        t = t.replace("--", "-")
    t = t.strip("-")
    raw = re.sub(r"[^a-z0-9-]", "", t)
    raw = raw.strip("-")
    if not raw:
        return []

    out: list[str] = []
    for k in (
        raw,
        raw.replace("-jr", "jr"),
        raw.replace("mr-", "mr"),
        raw.replace("type-null", "typenull"),
        raw.replace("porygon-z", "porygonz"),
        raw.replace("ho-oh", "hooh"),
        raw.replace("-f", "f").replace("-m", "m"),
        raw.replace("-", ""),
    ):
        k2 = str(k or "").strip("-")
        if k2 and k2 not in out:
            out.append(k2)
    return out


def _team_row_showdown_keys(row: dict) -> list[str]:
    species = _species_folder_name(str(row.get("species") or ""))
    form = _species_folder_name(str(row.get("form") or ""))
    keys_seed: list[str] = []
    if species and form and form not in ("base", "default", "normal"):
        if form.startswith(f"{species}-"):
            keys_seed.append(form)
        else:
            keys_seed.append(f"{species}-{form}")
    if species:
        keys_seed.append(species)
    out: list[str] = []
    for seed in keys_seed:
        for k in _team_showdown_key_variants(seed):
            if k not in out:
                out.append(k)
    return out


def _team_showdown_cache_path(key: str, shiny: bool) -> Path:
    sub = "shiny" if shiny else "normal"
    return TEAM_SHOWDOWN_CACHE_DIR / TEAM_SHOWDOWN_STYLE_DIR / sub / f"{key}.gif"


def _team_download_showdown_gif(key: str, shiny: bool, *, allow_network: bool = True) -> Optional[Path]:
    key = str(key or "").strip().lower()
    if not key:
        return None
    path = _team_showdown_cache_path(key, shiny)
    try:
        if path.exists() and path.is_file() and path.stat().st_size > 0:
            return path
    except Exception:
        pass
    if not allow_network:
        return None

    subdir = "gen5ani-shiny" if shiny else "gen5ani"
    miss_key = f"{subdir}:{key}"
    if miss_key in _TEAM_SHOWDOWN_MISS_KEYS:
        return None

    url = f"https://play.pokemonshowdown.com/sprites/{subdir}/{key}.gif"
    try:
        req = urllib.request.Request(url, headers={"User-Agent": TEAM_SHOWDOWN_UA})
        with urllib.request.urlopen(req, timeout=3.5) as resp:
            data = resp.read()
        if not data or len(data) < 24:
            _TEAM_SHOWDOWN_MISS_KEYS.add(miss_key)
            return None
        if not data.startswith((b"GIF87a", b"GIF89a")):
            _TEAM_SHOWDOWN_MISS_KEYS.add(miss_key)
            return None
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_bytes(data)
        return path
    except Exception:
        _TEAM_SHOWDOWN_MISS_KEYS.add(miss_key)
        return None


def _team_template_path() -> Optional[Path]:
    # Explicit file names first (most reliable).
    for p in TEAM_TEMPLATE_PATHS:
        try:
            if p.exists() and p.is_file() and p.stat().st_size > 0:
                return p
        except Exception:
            continue
    # Fallback: auto-pick any PNG in assets/ui or assets containing "team" in filename.
    for base in (ASSETS_DIR / "ui", ASSETS_DIR):
        try:
            if not base.exists() or not base.is_dir():
                continue
        except Exception:
            continue
        try:
            for p in sorted(base.glob("*.png")):
                stem = p.stem.lower()
                if "team" in stem and "tm" not in stem and p.stat().st_size > 0:
                    return p
        except Exception:
            continue
    return None


def _team_pick_sprite_path(row: dict) -> Optional[Path]:
    if _team_is_egg_row(row):
        stage = _team_egg_stage(row)
        stage = max(0, min(len(TEAM_EGG_STAGE_PATHS) - 1, int(stage)))
        for p in (TEAM_EGG_STAGE_PATHS[stage], ASSETS_DIR / "item_icons" / "mystery_egg.png"):
            try:
                if p.exists() and p.is_file() and p.stat().st_size > 0:
                    return p
            except Exception:
                continue
        return None

    species = _species_folder_name(str(row.get("species") or ""))
    form = _species_folder_name(str(row.get("form") or ""))
    shiny = bool(int(row.get("shiny") or 0))
    is_female = str(row.get("gender") or "").strip().lower() == "female"
    resolved: Optional[Path | str] = None

    def _is_animated_path(p: Path) -> bool:
        suf = str(getattr(p, "suffix", "") or "").strip().lower()
        return suf in {".gif", ".webp", ".apng"}

    # Keep /team sprite source aligned with battle renderer resolution logic,
    # but only accept this early path if it's animated.
    try:
        resolved = _pvp_sprites.find_sprite(
            species,
            gen=5,
            perspective="front",
            shiny=shiny,
            female=is_female,
            prefer_animated=True,
            form=(form or None),
        )
        if resolved is not None:
            rp = Path(resolved)
            if rp.exists() and rp.is_file() and rp.stat().st_size > 0 and _is_animated_path(rp):
                return rp
    except Exception:
        pass

    folders: list[Path] = []
    if species and form:
        form_folder = form if form.startswith(f"{species}-") else f"{species}-{form}"
        folders.append(SPRITES_DIR / form_folder)
    if species:
        folders.append(SPRITES_DIR / species)

    # 1) Try local animated files first.
    animated_candidates: list[str] = []
    if is_female:
        if shiny:
            animated_candidates += ["female-animated-shiny-front.gif"]
        animated_candidates += ["female-animated-front.gif"]
    if shiny:
        animated_candidates += ["animated-shiny-front.gif"]
    animated_candidates += ["animated-front.gif"]

    for folder in folders:
        try:
            if not folder.is_dir():
                continue
        except Exception:
            continue
        for name in animated_candidates:
            p = folder / name
            try:
                if p.exists() and p.is_file() and p.stat().st_size > 0:
                    return p
            except Exception:
                continue

    # 2) Prefer already-cached Showdown animation files.
    for key in _team_row_showdown_keys(row):
        p = _team_download_showdown_gif(key, shiny=shiny, allow_network=False)
        if p is not None:
            return p

    # 3) Optional remote fetch fallback (disabled by default for snappier /team).
    if TEAM_FETCH_SHOWDOWN_FOR_TEAM:
        for key in _team_row_showdown_keys(row):
            p = _team_download_showdown_gif(key, shiny=shiny, allow_network=True)
            if p is not None:
                return p

    # 4) If battle resolver found a static file, keep it as fallback.
    try:
        if resolved is not None:
            rp = Path(resolved)
            if rp.exists() and rp.is_file() and rp.stat().st_size > 0:
                return rp
    except Exception:
        pass

    # 5) Fallback to static local sprites.
    static_candidates: list[str] = []
    if is_female:
        if shiny:
            static_candidates += ["female-shiny-front.png"]
        static_candidates += ["female-front.png"]
    if shiny:
        static_candidates += ["shiny-front.png"]
    static_candidates += ["front.png", "icon.png"]

    for folder in folders:
        try:
            if not folder.is_dir():
                continue
        except Exception:
            continue
        for name in static_candidates:
            p = folder / name
            try:
                if p.exists() and p.is_file() and p.stat().st_size > 0:
                    return p
            except Exception:
                continue
    return None


def _team_font(size: int, *, bold: bool = False):
    if Image is None:
        return None
    try:
        from PIL import ImageFont  # type: ignore
    except Exception:
        return None
    try:
        from pvp.renderer import _get_pokemon_font_path as _renderer_pokemon_font_path  # type: ignore

        path = _renderer_pokemon_font_path()
        if path:
            return ImageFont.truetype(str(path), int(size))
    except Exception:
        pass
    candidates = [
        "pvp/_common/fonts/Pokemon GB.ttf",
        "pvp/_common/fonts/PokemonGb-RAeo.ttf",
        "pvp/_common/fonts/pokemon-gb.ttf",
        "pvp/_common/fonts/pokemongb.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSansMono-Bold.ttf" if bold else "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf",
        "/usr/share/fonts/truetype/jetbrains-mono/JetBrainsMono-Bold.ttf" if bold else "/usr/share/fonts/truetype/jetbrains-mono/JetBrainsMono-Regular.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf" if bold else "/usr/share/fonts/truetype/liberation/LiberationMono-Regular.ttf",
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf" if bold else "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf" if bold else "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
    ]
    for fp in candidates:
        try:
            return ImageFont.truetype(fp, int(size))
        except Exception:
            continue
    try:
        return ImageFont.load_default()
    except Exception:
        return None


def _team_text_width(draw, text: str, font) -> int:
    try:
        box = draw.textbbox((0, 0), text, font=font)
        return max(0, int(box[2] - box[0]))
    except Exception:
        try:
            return int(draw.textlength(text, font=font))
        except Exception:
            return len(text) * 8


def _team_fit_font(draw, text: str, *, max_width: int, start_size: int, min_size: int = 10, bold: bool = False):
    for size in range(int(start_size), int(min_size) - 1, -1):
        f = _team_font(size, bold=bold)
        if f is None:
            continue
        if _team_text_width(draw, text, f) <= int(max_width):
            return f
    return _team_font(min_size, bold=bold)


def _team_load_sprite_frames(
    path: Optional[Path],
    *,
    max_size: tuple[int, int],
    resample,
    allow_upscale: bool = False,
    min_size: tuple[int, int] | None = None,
    frame_limit: int | None = None,
    min_frame_duration_ms: int | None = None,
    max_frame_duration_ms: int | None = None,
) -> tuple[list[Any], int]:
    if path is None or Image is None:
        return [], TEAM_BATTLE_SYNC_DURATION_MS
    try:
        from PIL import ImageSequence  # type: ignore
    except Exception:
        ImageSequence = None  # type: ignore
    try:
        img = Image.open(str(path))
    except Exception:
        return [], TEAM_BATTLE_SYNC_DURATION_MS
    duration = TEAM_BATTLE_SYNC_DURATION_MS
    raw_frames: list[Any] = []
    duration_samples: list[int] = []

    max_w = max(1, int(max_size[0] if max_size else 1))
    max_h = max(1, int(max_size[1] if max_size else 1))
    min_w = max(1, int(min_size[0])) if min_size else 1
    min_h = max(1, int(min_size[1])) if min_size else 1
    max_frames = max(1, int(frame_limit or TEAM_MAX_SPRITE_FRAMES))
    min_dur = max(10, int(min_frame_duration_ms or TEAM_MIN_FRAME_DURATION_MS or TEAM_BATTLE_SYNC_DURATION_MS))
    max_dur = max(min_dur, int(max_frame_duration_ms or TEAM_MAX_FRAME_DURATION_MS or TEAM_BATTLE_SYNC_DURATION_MS))

    def _scale_sprite(src):
        try:
            sw, sh = src.size
        except Exception:
            return src
        if sw <= 0 or sh <= 0:
            return src
        max_scale = min(max_w / float(sw), max_h / float(sh))
        if allow_upscale:
            scale = max_scale
            if min_size is not None:
                min_scale = max(min_w / float(sw), min_h / float(sh))
                scale = min(max_scale, max(min_scale, scale))
        else:
            scale = min(1.0, max_scale)
        scale = max(0.05, float(scale))
        nw = max(1, int(round(sw * scale)))
        nh = max(1, int(round(sh * scale)))
        if nw == sw and nh == sh:
            return src
        try:
            return src.resize((nw, nh), resample)
        except Exception:
            return src

    if ImageSequence is not None and bool(getattr(img, "is_animated", False)):
        try:
            for i, fr in enumerate(ImageSequence.Iterator(img)):
                if i >= max_frames:
                    break
                try:
                    raw_frames.append(fr.copy().convert("RGBA"))
                except Exception:
                    raw_frames.append(fr.convert("RGBA"))
                try:
                    d = int(fr.info.get("duration") or 0)
                except Exception:
                    d = 0
                if d <= 0:
                    try:
                        d = int(img.info.get("duration") or 0)
                    except Exception:
                        d = 0
                if d <= 0:
                    d = TEAM_BATTLE_SYNC_DURATION_MS
                duration_samples.append(max(min_dur, min(max_dur, int(d))))
        except Exception:
            raw_frames = []
    if not raw_frames:
        try:
            raw_frames = [img.convert("RGBA")]
        except Exception:
            raw_frames = []

    if not raw_frames:
        return [], duration

    if duration_samples:
        try:
            duration = int(round(sum(duration_samples) / max(1, len(duration_samples))))
            duration = max(min_dur, min(max_dur, duration))
        except Exception:
            duration = max(min_dur, min(max_dur, TEAM_BATTLE_SYNC_DURATION_MS))

    # Build a stable alpha bounding box across all frames so compositing is
    # visually centered on the Pok√©mon itself (not transparent padding).
    union_bbox: Optional[tuple[int, int, int, int]] = None
    for fr in raw_frames:
        try:
            alpha = fr.split()[-1]
            bb = alpha.getbbox()
        except Exception:
            bb = None
        if bb is None:
            continue
        if union_bbox is None:
            union_bbox = bb
        else:
            union_bbox = (
                min(union_bbox[0], bb[0]),
                min(union_bbox[1], bb[1]),
                max(union_bbox[2], bb[2]),
                max(union_bbox[3], bb[3]),
            )

    frames: list[Any] = []
    for fr in raw_frames:
        sprite = fr
        if union_bbox is not None:
            try:
                cropped = fr.crop(union_bbox)
                if cropped.size[0] > 0 and cropped.size[1] > 0:
                    sprite = cropped
            except Exception:
                sprite = fr
        sprite = _scale_sprite(sprite)
        frames.append(sprite)

    return frames, duration


def _team_overview_cache_key(target_name: str, slots: dict[int, dict | None], *, current_gen: Optional[int] = None) -> str:
    snapshot: list[Any] = []
    for slot in range(1, 7):
        row = slots.get(slot)
        if not row:
            snapshot.append(None)
            continue
        species_norm = _daycare_norm_species(row.get("species"))
        item = {
            "species": species_norm,
            "nickname": str(row.get("nickname") or "").strip(),
            "form": _species_folder_name(str(row.get("form") or "")),
            "shiny": int(bool(row.get("shiny"))),
            "gender": str(row.get("gender") or "").strip().lower(),
            "level": int(row.get("level") or 0),
            "hp_now": int(row.get("hp_now") or 0),
            "hp_max": int(row.get("hp") or 0),
            "locked": int(bool(row.get("is_locked"))),
            "registered": int(bool(row.get("is_registered"))),
        }
        if species_norm == "egg":
            item["egg_progress"] = round(float(row.get("_egg_progress") or 0.0), 3)
            item["egg_hatch_steps"] = round(float(row.get("_egg_hatch_steps") or 0.0), 3)
            item["egg_stage"] = int(_team_egg_stage(row))
        snapshot.append(item)
    raw = json.dumps(
        {
            "target": str(target_name or ""),
            "current_gen": int(current_gen or 0),
            "slots": snapshot,
            "sync_ms": int(TEAM_BATTLE_SYNC_DURATION_MS),
            "sprite_cap": int(TEAM_MAX_SPRITE_FRAMES),
            "composite_cap": int(TEAM_MAX_COMPOSITE_FRAMES),
        },
        ensure_ascii=False,
        sort_keys=True,
        separators=(",", ":"),
    )
    return hashlib.sha1(raw.encode("utf-8")).hexdigest()


def _team_overview_panel_file(
    target_name: str,
    slots: dict[int, dict | None],
    *,
    current_gen: Optional[int] = None,
) -> Optional[discord.File]:
    if Image is None:
        return None
    try:
        from PIL import ImageDraw  # type: ignore
    except Exception:
        return None
    cache_key = _team_overview_cache_key(target_name, slots, current_gen=current_gen)
    now = float(time.time())
    cached = _TEAM_OVERVIEW_RENDER_CACHE.get(cache_key)
    if cached is not None:
        ts, data, ext = cached
        if (now - float(ts)) <= TEAM_OVERVIEW_CACHE_TTL_SECONDS and data:
            return discord.File(fp=BytesIO(data), filename=f"team_panel_{cache_key}.{ext}")
        _TEAM_OVERVIEW_RENDER_CACHE.pop(cache_key, None)
    try:
        try:
            resample = Image.Resampling.NEAREST
        except Exception:
            resample = Image.NEAREST
        template = _team_template_path()
        if template is not None:
            with Image.open(str(template)) as tpl:
                base = tpl.convert("RGBA")
            bw0, bh0 = TEAM_TEMPLATE_STEM_BASE_SIZES.get(template.stem.lower(), TEAM_TEMPLATE_BASE_SIZE)
        else:
            # Fallback: generate a simple empty template if custom one isn't provided yet.
            base = Image.new("RGBA", (808, 537), (92, 56, 106, 255))
            bw0, bh0 = TEAM_TEMPLATE_BASE_SIZE

        bw, bh = base.size
        sx = bw / float(max(1, bw0))
        sy = bh / float(max(1, bh0))
        s = min(sx, sy)

        def _pt(x: int, y: int) -> tuple[int, int]:
            return (int(round(x * sx)), int(round(y * sy)))

        def _layout_scaled(src: dict[str, tuple[int, int]]) -> dict[str, tuple[int, int]]:
            x, y = src["box_xy"]
            w, h = src["box_wh"]
            cx, cy = src["sprite_c"]
            lx, ly = src["label_xy"]
            rx, ry = src["level_right"]
            return {
                "box_xy": _pt(x, y),
                "box_wh": (max(1, int(round(w * sx))), max(1, int(round(h * sy)))),
                "sprite_c": _pt(cx, cy),
                "label_xy": _pt(lx, ly),
                "level_right": _pt(rx, ry),
            }

        def _draw_text_with_outline(
            d,
            xy: tuple[int, int],
            text: str,
            *,
            font,
            fill: tuple[int, int, int, int],
            stroke: tuple[int, int, int, int] = (16, 16, 20, 240),
            stroke_px: int = 1,
        ) -> None:
            t = str(text or "")
            if not t or font is None:
                return
            x, y = int(xy[0]), int(xy[1])
            sw = max(1, int(stroke_px))
            try:
                d.text((x, y), t, font=font, fill=fill, stroke_width=sw, stroke_fill=stroke)
                return
            except Exception:
                pass
            for ox in range(-sw, sw + 1):
                for oy in range(-sw, sw + 1):
                    if ox == 0 and oy == 0:
                        continue
                    d.text((x + ox, y + oy), t, font=font, fill=stroke)
            d.text((x, y), t, font=font, fill=fill)

        def _draw_pixel_shadow_text(
            d,
            xy: tuple[int, int],
            text: str,
            *,
            font,
            fill: tuple[int, int, int, int] = (242, 244, 252, 255),
            shadow: tuple[int, int, int, int] = (0, 0, 0, 220),
            shadow_offset: tuple[int, int] = (1, 1),
        ) -> None:
            t = str(text or "")
            if not t or font is None:
                return
            x, y = int(xy[0]), int(xy[1])
            sx_off, sy_off = int(shadow_offset[0]), int(shadow_offset[1])
            try:
                d.text((x + sx_off, y + sy_off), t, font=font, fill=shadow)
                d.text((x, y), t, font=font, fill=fill)
            except Exception:
                pass

        slot_layout = tuple(_layout_scaled(g) for g in TEAM_SLOT_LAYOUT)

        draw = ImageDraw.Draw(base)

        # Overlay only text/sprites; never repaint template blocks.
        trainer_font = _team_font(max(9, int(round(20 * s))), bold=True)
        name_font = _team_fit_font(
            draw,
            target_name,
            max_width=max(60, int(round(148 * sx))),
            start_size=max(10, int(round(20 * s))),
            min_size=max(6, int(round(8 * s))),
            bold=True,
        )
        if trainer_font:
            tw = _team_text_width(draw, "Trainer", trainer_font)
            cx, ty = _pt(TEAM_TRAINER_NAME_CENTER_X, TEAM_TRAINER_LABEL_Y)
            _draw_text_with_outline(
                draw,
                (cx - tw // 2, ty),
                "Trainer",
                font=trainer_font,
                fill=(245, 246, 252, 255),
                stroke_px=1,
            )
        if name_font:
            nw = _team_text_width(draw, target_name, name_font)
            cx, ny = _pt(TEAM_TRAINER_NAME_CENTER_X, TEAM_TRAINER_NAME_Y)
            _draw_text_with_outline(
                draw,
                (cx - nw // 2, ny),
                target_name,
                font=name_font,
                fill=(228, 234, 252, 255),
                stroke_px=1,
            )

        # Footer: template already contains "Current Region :", overlay only value.
        gen_num = max(1, int(current_gen or 1))
        region_name = _team_region_for_gen(gen_num)
        footer_x = int(round((TEAM_TRAINER_FOOTER_RECT[0] + 96) * sx))
        footer_y = int(round((TEAM_TRAINER_FOOTER_RECT[1] + 8) * sy))
        footer_w = max(32, int(round((TEAM_TRAINER_FOOTER_RECT[2] - TEAM_TRAINER_FOOTER_RECT[0] - 102) * sx)))
        footer_font = _team_fit_font(
            draw,
            region_name,
            max_width=footer_w,
            start_size=max(8, int(round(13 * s))),
            min_size=max(7, int(round(9 * s))),
            bold=False,
        )
        if footer_font is not None:
            _draw_pixel_shadow_text(
                draw,
                (footer_x, footer_y),
                region_name,
                font=footer_font,
                fill=(240, 242, 250, 255),
                shadow=(0, 0, 0, 215),
            )

        # Preload sprite frames (animated front preferred).
        sprite_data: dict[int, dict[str, Any]] = {}
        cycle_lengths: list[int] = []
        base_duration = TEAM_BATTLE_SYNC_DURATION_MS
        for slot in range(1, 7):
            row = slots.get(slot)
            if not row:
                sprite_data[slot] = {"frames": []}
                continue
            path = _team_pick_sprite_path(row)
            geom = slot_layout[slot - 1]
            slot_w, slot_h = geom["box_wh"]
            visual_scale = _team_species_visual_scale(row)
            max_w = max(30, min(max(30, slot_w - max(10, int(round(10 * s)))), int(round(128 * sx * visual_scale))))
            max_h = max(30, min(max(30, slot_h - max(46, int(round(54 * s)))), int(round(124 * sy * visual_scale))))
            sprite_max = (max_w, max_h)
            sprite_min = (max(24, int(round(max_w * 0.72))), max(24, int(round(max_h * 0.72))))
            species_norm = _daycare_norm_species(row.get("species"))
            frame_limit = TEAM_MAX_SPRITE_FRAMES
            min_frame_ms = TEAM_MIN_FRAME_DURATION_MS
            if species_norm == "eevee":
                # Eevee source animations can have longer loops; keep enough frames/time
                # so Discord playback doesn't appear to reset mid-cycle.
                frame_limit = max(frame_limit, 128)
                min_frame_ms = max(min_frame_ms, 95)
            frames, _ = _team_load_sprite_frames(
                path,
                max_size=sprite_max,
                resample=resample,
                allow_upscale=True,
                min_size=sprite_min,
                frame_limit=frame_limit,
                min_frame_duration_ms=min_frame_ms,
            )
            y_off = 0
            try:
                if _daycare_norm_species(row.get("species")) == "stakataka":
                    y_off = -max(2, int(round(12 * sy)))
            except Exception:
                y_off = 0
            sprite_data[slot] = {"frames": frames, "y_off": y_off}
            if len(frames) > 1:
                cycle_lengths.append(len(frames))

        lvl_font_slot = _team_font(max(7, int(round(11 * s))), bold=False)
        lock_badge_font = _team_font(max(6, int(round(8 * s))), bold=True)
        text_prep: dict[int, dict[str, Any]] = {}
        probe_draw = ImageDraw.Draw(base)
        for slot in range(1, 7):
            row = slots.get(slot)
            geom = slot_layout[slot - 1]
            slot_w, _slot_h = geom["box_wh"]
            if not row:
                text_prep[slot] = {"label": "", "font": None, "lvl": "", "lvl_x": geom["level_right"][0], "label_x": geom["label_xy"][0]}
                continue
            if _team_is_egg_row(row):
                label = "Egg"
                lvl = f"{_team_egg_progress_pct(row)}%"
            else:
                label = _team_species_label(row)
                lvl = f"Lv {int(row.get('level') or 1)}"
            label_to_draw = label
            label_font = _team_fit_font(
                probe_draw,
                label_to_draw,
                max_width=max(36, int(round((slot_w - max(42, int(round(52 * s))))))),
                start_size=max(8, int(round(14 * s))),
                min_size=max(6, int(round(9 * s))),
                bold=True,
            )
            lvl_x = geom["level_right"][0]
            lvl_w = 0
            if lvl_font_slot:
                lvl_w = _team_text_width(probe_draw, lvl, lvl_font_slot)
                lvl_x = int(geom["level_right"][0] - lvl_w)
            if label_font:
                label_start_x = int(geom["label_xy"][0])
                min_gap = max(8, int(round(10 * s)))
                label_end_limit = int(lvl_x - min_gap)
                label_max_w = max(20, label_end_limit - label_start_x)
                label_font = _team_fit_font(
                    probe_draw,
                    label_to_draw,
                    max_width=label_max_w,
                    start_size=max(8, int(round(13 * s))),
                    min_size=max(6, int(round(8 * s))),
                    bold=True,
                )
            text_prep[slot] = {
                "label": label_to_draw,
                "font": label_font,
                "lvl": lvl,
                "lvl_x": lvl_x,
                "label_x": geom["label_xy"][0],
            }

        # Draw static text once and composite it over each animation frame.
        text_layer = Image.new("RGBA", base.size, (0, 0, 0, 0))
        text_draw = ImageDraw.Draw(text_layer)
        for slot in range(1, 7):
            geom = slot_layout[slot - 1]
            row = slots.get(slot)
            slot_text = text_prep.get(slot) or {}
            if not row:
                continue
            if bool(row.get("is_locked")):
                bx, by = geom["box_xy"]
                pad = max(2, int(round(3 * s)))
                badge_w = max(10, int(round(13 * s)))
                badge_h = max(9, int(round(11 * s)))
                x0 = int(bx + pad)
                y0 = int(by + pad)
                x1 = int(x0 + badge_w)
                y1 = int(y0 + badge_h)
                try:
                    text_draw.rounded_rectangle(
                        (x0, y0, x1, y1),
                        radius=max(2, int(round(2 * s))),
                        fill=(246, 197, 77, 235),
                        outline=(68, 44, 15, 255),
                        width=1,
                    )
                except Exception:
                    text_draw.rectangle(
                        (x0, y0, x1, y1),
                        fill=(246, 197, 77, 235),
                        outline=(68, 44, 15, 255),
                        width=1,
                    )
                if lock_badge_font is not None:
                    lt = "L"
                    lw = _team_text_width(text_draw, lt, lock_badge_font)
                    try:
                        tb = text_draw.textbbox((0, 0), lt, font=lock_badge_font)
                        lh = max(1, int(tb[3] - tb[1]))
                    except Exception:
                        lh = max(6, int(round(7 * s)))
                    lx = int(x0 + max(1, ((badge_w - lw) // 2)))
                    ly = int(y0 + max(0, ((badge_h - lh) // 2) - 1))
                    _draw_text_with_outline(
                        text_draw,
                        (lx, ly),
                        lt,
                        font=lock_badge_font,
                        fill=(44, 31, 9, 255),
                        stroke=(255, 244, 218, 220),
                        stroke_px=1,
                    )
            if slot_text.get("font") and str(slot_text.get("label") or "").strip():
                label_fill = (240, 242, 250, 255)
                label_shadow = (0, 0, 0, 220)
                if bool(row.get("is_registered")):
                    label_fill = (255, 116, 116, 255)
                    label_shadow = (92, 20, 20, 220)
                elif bool(row.get("shiny")):
                    label_fill = (255, 224, 118, 255)
                    label_shadow = (98, 74, 24, 220)
                _draw_pixel_shadow_text(
                    text_draw,
                    (int(slot_text.get("label_x") or geom["label_xy"][0]), geom["label_xy"][1]),
                    str(slot_text.get("label") or ""),
                    font=slot_text["font"],
                    fill=label_fill,
                    shadow=label_shadow,
                )
            lvl = str(slot_text.get("lvl") or "")
            if lvl and lvl_font_slot:
                _draw_pixel_shadow_text(
                    text_draw,
                    (int(slot_text.get("lvl_x") or geom["level_right"][0]), geom["level_right"][1]),
                    lvl,
                    font=lvl_font_slot,
                    fill=(244, 246, 252, 255),
                    shadow=(0, 0, 0, 215),
                )

        out_frames: list[Any] = []
        frame_count = 1
        max_cycle_len = 1
        if cycle_lengths:
            try:
                max_cycle_len = max(max(1, int(n)) for n in cycle_lengths)
                frame_count = min(TEAM_MAX_COMPOSITE_FRAMES, max_cycle_len)
            except Exception:
                max_cycle_len = max(max(1, int(n)) for n in cycle_lengths)
                frame_count = min(TEAM_MAX_COMPOSITE_FRAMES, max_cycle_len)
        frame_count = max(1, int(frame_count))
        # Preserve battle-equivalent animation speed even when we downsample frames
        # to keep /team rendering responsive.
        duration_scale = float(max_cycle_len) / float(frame_count) if frame_count > 0 else 1.0
        save_duration = max(40, min(500, int(round(base_duration * duration_scale))))
        for fi in range(frame_count):
            frame = base.copy()
            for slot in range(1, 7):
                geom = slot_layout[slot - 1]
                row = slots.get(slot)
                if not row:
                    continue

                data = sprite_data.get(slot) or {}
                frames = data.get("frames") or []
                if frames:
                    if frame_count > 1 and len(frames) > 1:
                        src_i = int((fi * len(frames)) / frame_count) % len(frames)
                    else:
                        src_i = 0
                    sprite = frames[src_i]
                    dx = int(geom["sprite_c"][0] - (sprite.width // 2))
                    dy = int(geom["sprite_c"][1] - (sprite.height // 2) + int(data.get("y_off") or 0))
                    try:
                        frame.alpha_composite(sprite, dest=(dx, dy))
                    except Exception:
                        pass
            frame.alpha_composite(text_layer)
            out_frames.append(frame)

        buf = BytesIO()
        if frame_count > 1:
            out_frames[0].save(
                buf,
                format="GIF",
                save_all=True,
                append_images=out_frames[1:],
                duration=int(save_duration),
                loop=0,
                disposal=2,
            )
            ext = "gif"
        else:
            out_frames[0].save(buf, format="PNG")
            ext = "png"
        data = buf.getvalue()
        _TEAM_OVERVIEW_RENDER_CACHE[cache_key] = (now, data, ext)
        if len(_TEAM_OVERVIEW_RENDER_CACHE) > 96:
            # Keep cache bounded; drop oldest half.
            old_keys = sorted(_TEAM_OVERVIEW_RENDER_CACHE.items(), key=lambda kv: kv[1][0])[:48]
            for k, _v in old_keys:
                _TEAM_OVERVIEW_RENDER_CACHE.pop(k, None)
        return discord.File(fp=BytesIO(data), filename=f"team_panel_{cache_key}.{ext}")
    except Exception:
        return None


class TeamPanelView(discord.ui.View):
    def __init__(
        self,
        author_id: int,
        target_name: str,
        slots: dict[int, dict | None],
        *,
        current_gen: Optional[int] = None,
    ):
        super().__init__(timeout=240)
        self.author_id = int(author_id)
        self.target_name = target_name
        self.slots = dict(slots)
        self.current_gen = max(1, int(current_gen or 1))
        self._build_buttons()

    def _build_buttons(self):
        overview_btn = discord.ui.Button(label="Overview", style=discord.ButtonStyle.primary, custom_id="team:view:overview", row=0)
        overview_btn.callback = self._on_overview
        self.add_item(overview_btn)
        for i in range(1, 7):
            has_mon = bool(self.slots.get(i))
            b = discord.ui.Button(
                label=f"Slot {i}",
                style=discord.ButtonStyle.secondary,
                custom_id=f"team:view:slot:{i}",
                row=1 if i <= 3 else 2,
                disabled=not has_mon,
            )
            b.callback = self._on_slot
            self.add_item(b)

    def _guard(self, itx: discord.Interaction) -> bool:
        return itx.user.id == self.author_id

    async def _overview_payload(self) -> tuple[Optional[discord.Embed], list[discord.File]]:
        # Send the overview as a direct image attachment (no embed) so Discord
        # can display the panel larger while preserving the same buttons.
        files: list[discord.File] = []
        try:
            panel = await asyncio.to_thread(
                _team_overview_panel_file,
                self.target_name,
                self.slots,
                current_gen=self.current_gen,
            )
        except Exception:
            panel = _team_overview_panel_file(self.target_name, self.slots, current_gen=self.current_gen)
        if panel:
            files.append(panel)
            return None, files
        emb = discord.Embed(
            title=f"{self.target_name} ‚Äî Team",
            description="Could not render the team panel right now.",
            color=0x2F3136,
        )
        return emb, files

    def _slot_payload(self, slot: int) -> tuple[discord.Embed, list[discord.File]]:
        row = self.slots.get(int(slot))
        if not row:
            emb = discord.Embed(title=f"{self.target_name} ‚Äî Slot {slot}", description="This slot is empty.", color=0x2F3136)
            return emb, []
        if _team_is_egg_row(row):
            stage = _team_egg_stage(row)
            pct = _team_egg_progress_pct(row)
            emb = discord.Embed(
                title=f"{self.target_name} ‚Äî Slot {slot}",
                description=f"**Egg**\n`{_team_hp_bar(pct, width=14)}` **{pct}%** to hatch",
                color=0xBDA7FF,
            )
            emb.add_field(name="Hatch Stage", value=TEAM_EGG_STAGE_LABELS[stage], inline=True)
            emb.add_field(name="Progress", value=f"{pct}%", inline=True)
            emb.add_field(name="Level", value=str(int(row.get("level") or 0)), inline=True)
            emb.add_field(name="Status", value="In team incubator", inline=True)
            emb.set_footer(text="Eggs crack more as they near hatching.")
            files: list[discord.File] = []
            sprite_path = _team_pick_sprite_path(row)
            if sprite_path is not None:
                try:
                    f = discord.File(sprite_path, filename=sprite_path.name)
                    emb.set_thumbnail(url=f"attachment://{sprite_path.name}")
                    files.append(f)
                except Exception:
                    pass
            return emb, files
        name = _team_species_label(row)
        shiny = bool(int(row.get("shiny") or 0))
        gicon = _gender_icon(row.get("gender")) or "‚Äî"
        hp_now, hp_max, pct = _team_hp_values(row)
        emb = discord.Embed(
            title=f"{self.target_name} ‚Äî Slot {slot}",
            description=f"**{name}**{' ‚ú®' if shiny else ''}\n`{_team_hp_bar(pct, width=14)}` **{hp_now}/{hp_max}** ({pct}%)",
            color=0xF1C40F if shiny else 0x5865F2,
        )
        emb.add_field(name="Level", value=str(int(row.get("level") or 1)), inline=True)
        emb.add_field(name="Gender", value=gicon, inline=True)
        emb.add_field(name="Nature", value=str(row.get("nature") or "Unknown").replace("-", " ").title(), inline=True)
        ability = str(row.get("ability") or "Unknown").replace("-", " ").title()
        emb.add_field(name="Ability", value=ability, inline=True)
        emb.add_field(name="Friendship", value=str(int(row.get("friendship") or 0)), inline=True)
        emb.add_field(name="Lock", value=("üîí Locked" if bool(row.get("is_locked")) else "‚Äî"), inline=True)
        held_item = str(row.get("held_item") or "").strip()
        item_emoji = (row.get("item_emoji") or "").strip()
        if held_item:
            held_disp = pretty_item_name(held_item)
            if _is_displayable_item_emoji(item_emoji):
                held_disp = f"{item_emoji} {held_disp}"
        else:
            held_disp = "None"
        emb.add_field(name="Held Item", value=held_disp, inline=True)
        move_ids = _team_parse_move_ids(row.get("moves"))
        moves = _team_parse_moves(row.get("moves"))
        pps = _team_parse_moves_pp(row.get("moves_pp"))
        max_pps_stored = _team_parse_moves_pp(row.get("moves_pp_max"))
        move_lines: list[str] = []
        for i, move_name in enumerate(moves):
            move_id = move_ids[i] if i < len(move_ids) else move_name.replace(" ", "-").lower()
            max_pp = _team_pp_cap_for_move(
                move_id,
                self.current_gen,
                max_pps_stored[i] if i < len(max_pps_stored) else None,
            )
            cur_pp = pps[i] if i < len(pps) else None
            if cur_pp is not None:
                try:
                    cur_pp = max(0, min(int(cur_pp), int(max_pp)))
                except Exception:
                    cur_pp = None
            cur_txt = str(cur_pp) if cur_pp is not None else "?"
            move_lines.append(f"**{i+1}.** {move_name} ({cur_txt}/{max_pp})")
        emb.add_field(
            name="Moves",
            value="\n".join(move_lines) if move_lines else "‚Äî",
            inline=False,
        )
        emb.set_footer(text=f"Pok√©mon ID #{int(row.get('id') or 0)}")
        files = attach_sprite_to_embed(
            emb,
            species=str(row.get("species") or ""),
            shiny=shiny,
            gender=row.get("gender"),
            form_key=row.get("form"),
        )
        return emb, files

    async def _edit_payload(self, itx: discord.Interaction, emb: Optional[discord.Embed], files: list[discord.File]):
        async def _apply(edit_fn, *, use_files_kw: bool):
            kwargs: dict[str, Any] = {"view": self}
            # Clear any prior embed when switching back to overview attachment view.
            kwargs["embed"] = emb
            if use_files_kw:
                kwargs["files"] = files
            else:
                kwargs["attachments"] = files
            return await edit_fn(**kwargs)

        try:
            await _apply(itx.response.edit_message, use_files_kw=False)
        except TypeError:
            await _apply(itx.response.edit_message, use_files_kw=True)
        except Exception:
            try:
                await _apply(itx.edit_original_response, use_files_kw=False)
            except TypeError:
                await _apply(itx.edit_original_response, use_files_kw=True)
        finally:
            _close_discord_files(files)

    async def _on_overview(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        emb, files = await self._overview_payload()
        await self._edit_payload(itx, emb, files)

    async def _on_slot(self, itx: discord.Interaction):
        if not self._guard(itx):
            return await itx.response.send_message("This isn't for you.", ephemeral=True)
        cid = str((itx.data or {}).get("custom_id") or "")
        try:
            slot = int(cid.rsplit(":", 1)[-1])
        except Exception:
            return await itx.response.send_message("Invalid slot.", ephemeral=True)
        emb, files = self._slot_payload(slot)
        await self._edit_payload(itx, emb, files)


def _daycare_tick_needed(rec: Optional[dict]) -> bool:
    if not isinstance(rec, dict):
        return False
    parents = rec.get("parents")
    if isinstance(parents, (list, tuple)):
        for p in parents[:2]:
            if p is not None and str(p).isdigit():
                return True
    if rec.get("eggs"):
        return True
    if rec.get("incubating"):
        return True
    return False


@bot.tree.command(name="team", description="Show your current team (6 slots).")
@app_commands.describe(user="View another user's team (optional)")
async def team(interaction: discord.Interaction, user: discord.User | None = None):
    # Defer IMMEDIATELY before any database work
    try:
        await interaction.response.defer(ephemeral=False)
    except discord.errors.NotFound:
        print(f"[WARNING] /team command started too late (interaction expired)")
        return
    
    target = user or interaction.user
    uid = str(target.id)

    rows = None
    if db_cache is not None:
        try:
            cached = db_cache.get_cached_pokemons(uid)
            if cached is not None:
                team_mons = [p for p in cached if p.get("team_slot") and 1 <= int(p.get("team_slot") or 0) <= 6]
                team_mons.sort(key=lambda p: (int(p.get("team_slot") or 0), int(p.get("id") or 0)))
                if team_mons:
                    rows = []
                    for p in team_mons:
                        item_emoji = None
                        if p.get("held_item") and db_cache:
                            item_row = db_cache.get_cached_item(str(p["held_item"]))
                            if item_row:
                                item_emoji = (item_row.get("emoji") or "").strip()
                        rows.append({
                            "id": p.get("id"), "species": p.get("species"), "level": p.get("level"),
                            "gender": p.get("gender"), "shiny": p.get("shiny"), "team_slot": p.get("team_slot"),
                            "held_item": p.get("held_item"), "item_emoji": item_emoji,
                            "hp": p.get("hp"), "hp_now": p.get("hp_now"), "moves": p.get("moves"),
                            "moves_pp": p.get("moves_pp"), "moves_pp_max": p.get("moves_pp_max"),
                            "nature": p.get("nature"), "ability": p.get("ability"), "friendship": p.get("friendship"),
                            "form": p.get("form"),
                        })
        except Exception:
            pass
    if rows is None:
        async with db.session() as conn:
            col_flags = await _pg_pokemons_column_flags(conn)
            pp_max_sel = "p.moves_pp_max AS moves_pp_max," if col_flags.get("moves_pp_max", False) else "NULL AS moves_pp_max,"
            cur = await conn.execute("""
            SELECT p.id, p.species, p.level, p.gender, p.shiny, p.team_slot, p.held_item, i.emoji AS item_emoji,
                   p.hp, p.hp_now, p.moves, p.moves_pp, """ + pp_max_sel + """ p.nature, p.ability, p.friendship, p.form
            FROM pokemons p
            LEFT JOIN items i ON i.id = p.held_item
            WHERE p.owner_id = ? AND p.team_slot BETWEEN 1 AND 6
            ORDER BY p.team_slot
            """, (uid,))
            rows = [dict(r) for r in await cur.fetchall()]
            await cur.close()
        # Warm cache asynchronously (don't block /team response).
        try:
            now = float(time.time())
            last_warm = float(_TEAM_WARM_CACHE_TS.get(uid, 0.0))
            if (now - last_warm) >= TEAM_WARM_CACHE_INTERVAL_SECONDS:
                _TEAM_WARM_CACHE_TS[uid] = now
                async def _warm_team_cache() -> None:
                    try:
                        await db.list_pokemons(uid, limit=2000, offset=0)
                    except Exception:
                        pass
                asyncio.create_task(_warm_team_cache())
        except Exception:
            pass

    nickname_map: dict[int, str] = {}
    locked_ids: set[int] = set()
    registered_ids: set[int] = set()
    row_ids: list[int] = []
    for r in rows or []:
        try:
            rid = int((r.get("id") if hasattr(r, "keys") else r[0]) or 0)
        except Exception:
            rid = 0
        if rid > 0:
            row_ids.append(rid)
    if row_ids:
        try:
            async with db.session() as conn:
                nickname_map = await _get_pokemon_nickname_map(uid, row_ids, conn=conn)
                locked_ids = await _get_locked_pokemon_ids(uid, conn=conn)
                registered_ids = await _get_registered_pokemon_ids(uid, row_ids, conn=conn)
        except Exception:
            nickname_map = {}
            locked_ids = set()
            registered_ids = set()

    # Map slots
    slots: dict[int, dict | None] = {i: None for i in range(1, 7)}
    for r in rows:
        row = dict(r) if hasattr(r, "keys") else {
            "id": r[0], "species": r[1], "level": r[2], "gender": r[3],
            "shiny": r[4], "team_slot": r[5], "held_item": r[6],
            "item_emoji": r[7] if len(r) > 7 else None,
            "hp": r[8] if len(r) > 8 else None,
            "hp_now": r[9] if len(r) > 9 else None,
            "moves": r[10] if len(r) > 10 else None,
            "moves_pp": r[11] if len(r) > 11 else None,
            "moves_pp_max": r[12] if len(r) > 12 else None,
            "nature": r[13] if len(r) > 13 else None,
            "ability": r[14] if len(r) > 14 else None,
            "friendship": r[15] if len(r) > 15 else None,
            "form": r[16] if len(r) > 16 else None,
        }
        try:
            rid = int(row.get("id") or 0)
        except Exception:
            rid = 0
        if rid > 0 and rid in nickname_map:
            row["nickname"] = nickname_map[rid]
        row["is_locked"] = bool(rid > 0 and rid in locked_ids)
        row["is_registered"] = bool(rid > 0 and rid in registered_ids)
        try:
            slot_i = int(row["team_slot"])
            if 1 <= slot_i <= 6:
                slots[slot_i] = row
        except Exception:
            continue

    hatch_messages: list[str] = []
    if uid == str(interaction.user.id):
        state: Optional[dict] = None
        try:
            state = await _get_adventure_state(uid)
        except Exception:
            state = None
        if state is not None:
            rec = _daycare_get_record(state, DAYCARE_CITY_ID)
            if _daycare_tick_needed(rec):
                try:
                    changed, hatch_messages = await _daycare_tick(uid, state, command_credit=0.75)
                    if changed:
                        await _save_adventure_state(uid, state)
                except Exception:
                    hatch_messages = []
                rec = _daycare_get_record(state, DAYCARE_CITY_ID)
            incubating = list(rec.get("incubating") or [])
            if incubating:
                empty_slots = [i for i in range(1, 7) if slots.get(i) is None]
                egg_serial = 0
                for slot_i in empty_slots:
                    if egg_serial >= len(incubating):
                        break
                    egg = incubating[egg_serial]
                    egg_serial += 1
                    if not isinstance(egg, dict):
                        continue
                    try:
                        progress = float(egg.get("progress", 0.0) or 0.0)
                        hatch_steps = max(1.0, float(egg.get("hatch_steps", DAYCARE_HATCH_MIN) or DAYCARE_HATCH_MIN))
                    except Exception:
                        progress = 0.0
                        hatch_steps = DAYCARE_HATCH_MIN
                    stage = _team_egg_stage({
                        "species": "egg",
                        "_egg_progress": progress,
                        "_egg_hatch_steps": hatch_steps,
                    })
                    slots[slot_i] = {
                        "id": -1000 - slot_i - egg_serial,
                        "species": "egg",
                        "level": 0,
                        "gender": "genderless",
                        "shiny": 0,
                        "team_slot": slot_i,
                        "held_item": None,
                        "item_emoji": None,
                        "hp": 1,
                        "hp_now": 1,
                        "moves": [],
                        "nature": None,
                        "ability": None,
                        "friendship": 0,
                        "form": None,
                        "_egg_progress": progress,
                        "_egg_hatch_steps": hatch_steps,
                        "_egg_stage": stage,
                    }

    try:
        target_gen = await _user_selected_gen(uid)
    except Exception:
        target_gen = 1

    view = TeamPanelView(interaction.user.id, target.display_name, slots, current_gen=target_gen)
    emb, files = await view._overview_payload()
    try:
        if emb is None:
            await interaction.followup.send(files=files, view=view, ephemeral=True)
        else:
            await interaction.followup.send(embed=emb, files=files, view=view, ephemeral=True)
    finally:
        _close_discord_files(files)
    if hatch_messages and uid == str(interaction.user.id):
        for line in hatch_messages[:3]:
            try:
                await interaction.followup.send(line, ephemeral=True)
            except Exception:
                pass


# =========================
#  /box command + PC box management
# =========================
BOX_DEFAULT_COUNT = 8
BOX_FALLBACK_CAPACITY = 30
BOX_MIN_CAPACITY = 10
BOX_MAX_CAPACITY = 90

# Includes legendary, mythical, ultra beast, and major special legends for sorting.
BOX_LEGENDARY_SPECIES = {
    "articuno", "zapdos", "moltres", "mewtwo", "mew",
    "raikou", "entei", "suicune", "lugia", "ho-oh", "celebi",
    "regirock", "regice", "registeel", "latias", "latios",
    "kyogre", "groudon", "rayquaza", "jirachi", "deoxys",
    "uxie", "mesprit", "azelf", "dialga", "palkia", "heatran",
    "regigigas", "giratina", "cresselia", "phione", "manaphy",
    "darkrai", "shaymin", "arceus",
    "victini", "cobalion", "terrakion", "virizion",
    "tornadus", "thundurus", "landorus", "reshiram", "zekrom", "kyurem",
    "keldeo", "meloetta", "genesect",
    "xerneas", "yveltal", "zygarde", "diancie", "hoopa", "volcanion",
    "type-null", "silvally", "tapu-koko", "tapu-lele", "tapu-bulu", "tapu-fini",
    "cosmog", "cosmoem", "solgaleo", "lunala", "nihilego", "buzzwole", "pheromosa",
    "xurkitree", "celesteela", "kartana", "guzzlord", "necrozma",
    "magearna", "marshadow", "poipole", "naganadel", "stakataka", "blacephalon",
    "zeraora", "meltan", "melmetal",
    "zacian", "zamazenta", "eternatus", "kubfu", "urshifu", "zarude",
    "regieleki", "regidrago", "glastrier", "spectrier", "calyrex",
    "enamorus",
    "wo-chien", "chien-pao", "ting-lu", "chi-yu",
    "koraidon", "miraidon", "walking-wake", "iron-leaves",
    "okidogi", "munkidori", "fezandipiti", "ogerpon", "terapagos",
    "gouging-fire", "raging-bolt", "iron-boulder", "iron-crown",
    "pecharunt",
}


def _box_species_key(species: str | None) -> str:
    return str(species or "").strip().lower().replace("_", "-").replace(" ", "-")


def _box_base_species_key(species: str | None) -> str:
    sp = _box_species_key(species)
    if not sp:
        return ""
    toks = [t for t in sp.split("-") if t]
    while len(toks) > 1 and toks[-1] in {
        "mega", "gmax", "galar", "alola", "hisui", "paldea", "crowned", "therian",
        "incarnate", "origin", "attack", "defense", "speed", "complete", "ice", "shadow",
        "rapid", "single", "dusk", "midnight", "school", "solo",
    }:
        toks.pop()
    return "-".join(toks) if toks else sp


def _box_is_legendary_species(species: str | None) -> bool:
    sp = _box_species_key(species)
    if not sp:
        return False
    if sp in BOX_LEGENDARY_SPECIES:
        return True
    base = _box_base_species_key(sp)
    return bool(base and base in BOX_LEGENDARY_SPECIES)


def _box_total_ivs(row: Mapping[str, Any]) -> int:
    raw = row.get("ivs")
    if raw is None:
        return 0
    data = raw
    if isinstance(raw, str):
        try:
            data = json.loads(raw)
        except Exception:
            return 0
    if not isinstance(data, dict):
        return 0
    keys = ("hp", "atk", "def", "spa", "spd", "spe", "attack", "defense", "special_attack", "special_defense", "speed")
    total = 0
    seen = set()
    for k in keys:
        if k in seen:
            continue
        if k in data:
            try:
                total += int(data.get(k) or 0)
                seen.add(k)
            except Exception:
                pass
    return max(0, total)


def _box_gender_rank(g: str | None) -> int:
    x = str(g or "").strip().lower()
    if x in ("f", "female"):
        return 0
    if x in ("m", "male"):
        return 1
    if x in ("genderless", "none"):
        return 2
    return 3


def _box_parse_sort_methods(raw: str | None) -> list[str]:
    text = str(raw or "").strip().lower()
    if not text:
        return ["level"]
    text = text.replace("total ivs", "total_ivs").replace("totalivs", "total_ivs")
    text = text.replace("/", ",").replace("+", ",").replace("&", ",")
    tokens = [t.strip().replace("-", "_").replace(" ", "_") for t in text.split(",") if t.strip()]
    alias = {
        "iv": "total_ivs",
        "ivs": "total_ivs",
        "total_iv": "total_ivs",
        "lvl": "level",
    }
    out: list[str] = []
    for t in tokens:
        t2 = alias.get(t, t)
        if t2 in {"gender", "total_ivs", "level", "shiny", "legendary"} and t2 not in out:
            out.append(t2)
    return out or ["level"]


async def _box_get_box_count_and_capacity(owner_id: str) -> tuple[int, int]:
    box_count = BOX_DEFAULT_COUNT
    capacity = BOX_FALLBACK_CAPACITY
    async with db.session() as conn:
        # Ensure user_meta exists
        try:
            await conn.execute(
                "INSERT OR IGNORE INTO user_meta (owner_id, box_count) VALUES (?, ?)",
                (owner_id, BOX_DEFAULT_COUNT),
            )
        except Exception:
            pass
        try:
            cur = await conn.execute("SELECT box_count FROM user_meta WHERE owner_id=? LIMIT 1", (owner_id,))
            row = await cur.fetchone()
            await cur.close()
            if row:
                box_count = int((row["box_count"] if hasattr(row, "keys") else row[0]) or BOX_DEFAULT_COUNT)
        except Exception:
            box_count = BOX_DEFAULT_COUNT
        try:
            cur = await conn.execute("SELECT value FROM config WHERE key='box_capacity' LIMIT 1")
            row = await cur.fetchone()
            await cur.close()
            if row:
                capacity = int((row["value"] if hasattr(row, "keys") else row[0]) or BOX_FALLBACK_CAPACITY)
        except Exception:
            capacity = BOX_FALLBACK_CAPACITY
        await conn.commit()
    box_count = max(1, min(64, int(box_count or BOX_DEFAULT_COUNT)))
    capacity = max(BOX_MIN_CAPACITY, min(BOX_MAX_CAPACITY, int(capacity or BOX_FALLBACK_CAPACITY)))
    return box_count, capacity


async def _box_compact_positions_conn(conn: Any, owner_id: str, box_no: int) -> None:
    cur = await conn.execute(
        """
        SELECT id
        FROM pokemons
        WHERE owner_id=? AND team_slot IS NULL AND box_no=?
        ORDER BY box_pos, id
        """,
        (owner_id, int(box_no)),
    )
    rows = await cur.fetchall()
    await cur.close()
    next_pos = 1
    for row in rows:
        mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
        await conn.execute(
            "UPDATE pokemons SET box_pos=? WHERE owner_id=? AND id=?",
            (next_pos, owner_id, mon_id),
        )
        next_pos += 1


async def _box_prepare_storage(owner_id: str) -> None:
    """
    Ensure all PC mons have valid box_no/box_pos.
    Any mon with team_slot NULL and missing/invalid box placement is auto-assigned.
    """
    box_count, capacity = await _box_get_box_count_and_capacity(owner_id)
    daycare_parent_ids = await _daycare_parent_ids_for_owner(owner_id)
    skip_ids = sorted(int(x) for x in daycare_parent_ids if int(x) > 0)
    async with db.session() as conn:
        changed = False
        if skip_ids:
            ph = ",".join("?" for _ in skip_ids)
            cur = await conn.execute(
                f"SELECT COUNT(1) FROM pokemons WHERE owner_id=? AND id IN ({ph}) AND (box_no IS NOT NULL OR box_pos IS NOT NULL)",
                tuple([owner_id] + skip_ids),
            )
            row = await cur.fetchone()
            await cur.close()
            dirty = int((row[0] if row else 0) or 0) > 0
            if dirty:
                await conn.execute(
                    f"UPDATE pokemons SET box_no=NULL, box_pos=NULL WHERE owner_id=? AND id IN ({ph})",
                    tuple([owner_id] + skip_ids),
                )
                changed = True

        q = """
            SELECT id, box_no, box_pos
            FROM pokemons
            WHERE owner_id=? AND team_slot IS NULL
        """
        q_params: list[Any] = [owner_id]
        if skip_ids:
            q += f" AND id NOT IN ({','.join('?' for _ in skip_ids)})"
            q_params.extend(skip_ids)
        q += " ORDER BY id"
        cur = await conn.execute(q, tuple(q_params))
        rows = await cur.fetchall()
        await cur.close()

        used: dict[int, set[int]] = {b: set() for b in range(1, box_count + 1)}
        unplaced: list[int] = []
        for row in rows:
            mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
            box_no = int((row["box_no"] if hasattr(row, "keys") else row[1]) or 0)
            box_pos = int((row["box_pos"] if hasattr(row, "keys") else row[2]) or 0)
            if 1 <= box_no <= box_count and 1 <= box_pos <= capacity and box_pos not in used[box_no]:
                used[box_no].add(box_pos)
            else:
                unplaced.append(mon_id)

        for mon_id in unplaced:
            placed = False
            for b in range(1, box_count + 1):
                for p in range(1, capacity + 1):
                    if p not in used[b]:
                        await conn.execute(
                            "UPDATE pokemons SET box_no=?, box_pos=? WHERE owner_id=? AND id=?",
                            (b, p, owner_id, mon_id),
                        )
                        used[b].add(p)
                        placed = True
                        changed = True
                        break
                if placed:
                    break
            if not placed:
                # If full, auto-expand box_count up to 64 so storage never collides.
                if box_count < 64:
                    box_count += 1
                    used[box_count] = {1}
                    await conn.execute(
                        "UPDATE user_meta SET box_count=? WHERE owner_id=?",
                        (box_count, owner_id),
                    )
                    await conn.execute(
                        "UPDATE pokemons SET box_no=?, box_pos=? WHERE owner_id=? AND id=?",
                        (box_count, 1, owner_id, mon_id),
                    )
                    changed = True

        if changed:
            await conn.commit()
            db.invalidate_pokemons_cache(owner_id)


def _box_icon_path_for_species(species: str) -> Optional[Path]:
    sp = _daycare_norm_species(species)
    if not sp:
        return None
    # Prefer uploaded pokesprite zip extraction (menu-style sprite sheet).
    p = _daycare_extract_pokesprite_box(sp)
    if p is not None:
        try:
            if p.exists() and p.stat().st_size > 0:
                return p
        except Exception:
            pass
    for folder in _daycare_sprite_folder_candidates(sp):
        for root in (BOX_SPRITES_DIR, LEGACY_SPRITES_DIR):
            for fname in ("box.png", "icon.png"):
                cand = root / folder / fname
                try:
                    if cand.exists() and cand.stat().st_size > 0:
                        return cand
                except Exception:
                    pass
    return None


def _box_background_paths() -> list[Path]:
    """Locate available box background art files (sprites bundle first, then assets)."""
    roots = (BOX_SPRITES_BACKGROUNDS_DIR, ASSETS_BOX_BACKGROUNDS_DIR)
    out: list[Path] = []
    seen: set[str] = set()
    for fname in BOX_BACKGROUND_FILENAMES:
        for root in roots:
            p = root / fname
            try:
                if p.exists() and p.is_file() and p.stat().st_size > 0:
                    key = str(p.resolve())
                    if key not in seen:
                        seen.add(key)
                        out.append(p)
            except Exception:
                continue
    # Also allow additional custom PNG backgrounds in either root.
    for root in roots:
        try:
            if not root.exists() or not root.is_dir():
                continue
        except Exception:
            continue
        for p in sorted(root.glob("*.png")):
            try:
                if not p.is_file() or p.stat().st_size <= 0:
                    continue
                key = str(p.resolve())
            except Exception:
                continue
            if key not in seen:
                seen.add(key)
                out.append(p)
    return out


def _box_load_background_image(box_no: int, size: tuple[int, int]) -> Optional[Any]:
    if Image is None:
        return None
    cands = _box_background_paths()
    if not cands:
        return None
    try:
        idx = (max(1, int(box_no)) - 1) % len(cands)
    except Exception:
        idx = 0
    bg_path = cands[idx]
    try:
        try:
            resample = Image.Resampling.LANCZOS
        except Exception:
            resample = Image.BICUBIC
        bg = Image.open(str(bg_path)).convert("RGBA")
        target_w = max(1, int(size[0]))
        target_h = max(1, int(size[1]))
        if bg.size != (target_w, target_h):
            bg = bg.resize((target_w, target_h), resample=resample)
        return bg
    except Exception:
        return None


def _box_panel_file(
    owner_id: str,
    box_no: int,
    box_count: int,
    box_capacity: int,
    mons: list[dict],
    team_rows: Optional[list[dict]] = None,
) -> Optional[discord.File]:
    if Image is None:
        return None
    try:
        from PIL import ImageDraw, ImageFont  # type: ignore
    except Exception:
        return None

    cols = 6
    rows = max(1, math.ceil(max(1, int(box_capacity)) / cols))
    cell_w, cell_h = 112, 76
    gap_x, gap_y = 10, 10
    margin = 18
    header_h = 86
    side_w = 214
    grid_w = cols * cell_w + (cols - 1) * gap_x
    grid_h = rows * cell_h + (rows - 1) * gap_y
    W = margin * 3 + grid_w + side_w
    H = header_h + margin * 2 + grid_h + margin

    base = Image.new("RGBA", (W, H), (30, 33, 67, 255))
    draw = ImageDraw.Draw(base)
    try:
        font = ImageFont.load_default()
    except Exception:
        font = None

    # Outer shell + header bar (closer to in-game/myuu style).
    draw.rounded_rectangle((8, 8, W - 8, H - 8), radius=18, fill=(31, 58, 101, 255), outline=(173, 212, 250, 255), width=3)
    draw.rounded_rectangle((margin, 18, W - margin, header_h), radius=12, fill=(48, 52, 66, 255), outline=(100, 110, 140, 255), width=2)
    owner_tail = owner_id[-8:] if len(owner_id) > 8 else owner_id
    draw.text((margin + 12, 36), "Box", fill=(242, 195, 62, 255), font=font)
    draw.text((margin + 54, 36), f"Trainer {owner_tail}", fill=(255, 182, 62, 255), font=font)
    subtitle = f"{box_no}/{box_count}   Capacity {box_capacity}"
    draw.text((margin + 12, 56), subtitle, fill=(196, 210, 232, 255), font=font)

    grid_x = margin
    grid_y = header_h + margin
    draw.rounded_rectangle(
        (grid_x - 10, grid_y - 10, grid_x + grid_w + 10, grid_y + grid_h + 10),
        radius=12,
        fill=(221, 236, 198, 255),
        outline=(188, 165, 88, 255),
        width=2,
    )
    bg_img = _box_load_background_image(int(box_no), (grid_w, grid_h))
    if bg_img is not None:
        try:
            base.alpha_composite(bg_img, dest=(grid_x, grid_y))
        except Exception:
            pass
    else:
        # Fallback grassy tone if no themed backgrounds are available.
        draw.rectangle((grid_x, grid_y, grid_x + grid_w, grid_y + grid_h), fill=(213, 230, 174, 255))
    # Soften contrast while preserving the artwork.
    try:
        tint = Image.new("RGBA", (grid_w, grid_h), (255, 255, 255, 32))
        base.alpha_composite(tint, dest=(grid_x, grid_y))
    except Exception:
        pass

    by_pos: dict[int, dict] = {}
    for row in mons:
        try:
            p = int(row.get("box_pos") or 0)
            if p > 0 and p not in by_pos:
                by_pos[p] = row
        except Exception:
            continue

    # Game-like grid guides: top column numbers + left row letters.
    row_labels = ["a", "b", "c", "d", "e"]
    for c in range(cols):
        cx = grid_x + c * (cell_w + gap_x) + (cell_w // 2)
        draw.text((cx - 4, grid_y - 16), str(c + 1), fill=(18, 42, 66, 240), font=font)
    for r in range(min(rows, len(row_labels))):
        ry = grid_y + r * (cell_h + gap_y) + (cell_h // 2)
        draw.text((grid_x - 16, ry - 4), row_labels[r], fill=(18, 42, 66, 240), font=font)

    for pos in range(1, int(box_capacity) + 1):
        idx = pos - 1
        r = idx // cols
        c = idx % cols
        x0 = grid_x + c * (cell_w + gap_x)
        y0 = grid_y + r * (cell_h + gap_y)
        x1 = x0 + cell_w
        y1 = y0 + cell_h
        # Keep slots unfilled so background art is fully visible.
        draw.rounded_rectangle((x0, y0, x1, y1), radius=9, fill=None, outline=(86, 120, 146, 188), width=1)
        draw.text((x0 + 6, y0 + 5), f"{pos:02d}", fill=(32, 66, 95, 220), font=font)

        mon = by_pos.get(pos)
        if not mon:
            continue

        species = str(mon.get("species") or "Unknown")
        level = int(mon.get("level") or 1)
        shiny = bool(int(mon.get("shiny") or 0))
        icon_path = _box_icon_path_for_species(species)
        if icon_path:
            try:
                ico = Image.open(str(icon_path))
                if str(icon_path.suffix).lower() == ".gif":
                    try:
                        ico.seek(0)
                    except Exception:
                        pass
                ico = ico.convert("RGBA")
                try:
                    res = Image.Resampling.NEAREST
                except Exception:
                    res = Image.NEAREST
                ico.thumbnail((50, 50), resample=res)
                px = x0 + 6
                py = y0 + 16
                base.alpha_composite(ico, (px, py))
            except Exception:
                pass
        name = species.replace("-", " ").title()
        if len(name) > 11:
            name = name[:10] + "‚Ä¶"
        # Soft text shadow for readability over detailed backgrounds.
        draw.text((x0 + 55, y0 + 24), f"{'‚òÖ ' if shiny else ''}{name}", fill=(10, 22, 33, 180), font=font)
        draw.text((x0 + 54, y0 + 23), f"{'‚òÖ ' if shiny else ''}{name}", fill=(230, 241, 250, 255), font=font)
        draw.text((x0 + 55, y0 + 41), f"Lv {level}", fill=(10, 22, 33, 170), font=font)
        draw.text((x0 + 54, y0 + 40), f"Lv {level}", fill=(206, 224, 240, 255), font=font)
        held = str(mon.get("held_item") or "").strip()
        if held:
            held_txt = pretty_item_name(held)
            if len(held_txt) > 10:
                held_txt = held_txt[:9] + "‚Ä¶"
            draw.text((x0 + 55, y0 + 57), held_txt, fill=(10, 22, 33, 160), font=font)
            draw.text((x0 + 54, y0 + 56), held_txt, fill=(176, 233, 194, 255), font=font)

    # Right-side team strip (Myuu-style utility panel).
    team_rows = team_rows or []
    team_by_slot: dict[int, dict] = {}
    for row in team_rows:
        try:
            s = int(row.get("team_slot") or 0)
            if 1 <= s <= 6 and s not in team_by_slot:
                team_by_slot[s] = row
        except Exception:
            continue
    side_x = grid_x + grid_w + margin
    side_y = grid_y
    side_h = grid_h
    draw.rounded_rectangle(
        (side_x, side_y, side_x + side_w, side_y + side_h),
        radius=12,
        fill=(59, 61, 69, 255),
        outline=(142, 146, 160, 255),
        width=2,
    )
    draw.text((side_x + 72, side_y + 10), "TEAM", fill=(214, 220, 232, 255), font=font)

    slot_h = max(50, int((side_h - 52 - (5 * 8)) / 6))
    for slot in range(1, 7):
        y0 = side_y + 32 + (slot - 1) * (slot_h + 8)
        y1 = y0 + slot_h
        draw.rounded_rectangle(
            (side_x + 10, y0, side_x + side_w - 10, y1),
            radius=8,
            fill=(72, 76, 90, 255),
            outline=(160, 165, 177, 255),
            width=2,
        )
        draw.text((side_x + 16, y0 + 5), f"{slot}", fill=(205, 212, 226, 255), font=font)
        trow = team_by_slot.get(slot)
        if not trow:
            draw.text((side_x + 34, y0 + 18), "Empty", fill=(163, 171, 186, 255), font=font)
            continue
        sp = str(trow.get("species") or "Unknown")
        lv = int(trow.get("level") or 1)
        icon_path = _box_icon_path_for_species(sp)
        if icon_path:
            try:
                ico = Image.open(str(icon_path))
                if str(icon_path.suffix).lower() == ".gif":
                    try:
                        ico.seek(0)
                    except Exception:
                        pass
                ico = ico.convert("RGBA")
                try:
                    res = Image.Resampling.NEAREST
                except Exception:
                    res = Image.NEAREST
                ico.thumbnail((34, 34), resample=res)
                base.alpha_composite(ico, (side_x + 34, y0 + 9))
            except Exception:
                pass
        nm = sp.replace("-", " ").title()
        if len(nm) > 10:
            nm = nm[:9] + "‚Ä¶"
        draw.text((side_x + 74, y0 + 12), nm, fill=(228, 232, 240, 255), font=font)
        draw.text((side_x + 74, y0 + 27), f"Lv {lv}", fill=(182, 193, 212, 255), font=font)

    buf = BytesIO()
    base.save(buf, format="PNG", optimize=True)
    buf.seek(0)
    return discord.File(buf, filename="box-panel.png")


async def _box_render_payload(owner_id: str, box_no: int) -> tuple[discord.Embed, list[discord.File], int, int]:
    await _box_prepare_storage(owner_id)
    box_count, box_capacity = await _box_get_box_count_and_capacity(owner_id)
    box_no = max(1, min(int(box_no), int(box_count)))
    async with db.session() as conn:
        cur = await conn.execute(
            """
            SELECT id, species, level, shiny, gender, held_item, box_no, box_pos, ivs
            FROM pokemons
            WHERE owner_id=? AND team_slot IS NULL AND box_no=?
            ORDER BY box_pos, id
            """,
            (owner_id, box_no),
        )
        mons = [dict(r) for r in await cur.fetchall()]
        await cur.close()
        cur = await conn.execute(
            """
            SELECT id, species, level, shiny, team_slot
            FROM pokemons
            WHERE owner_id=? AND team_slot BETWEEN 1 AND 6
            ORDER BY team_slot, id
            """,
            (owner_id,),
        )
        team_rows = [dict(r) for r in await cur.fetchall()]
        await cur.close()
        cur = await conn.execute(
            """
            SELECT COUNT(1)
            FROM pokemons
            WHERE owner_id=? AND team_slot IS NULL AND box_no BETWEEN 1 AND ?
            """,
            (owner_id, int(box_count)),
        )
        count_row = await cur.fetchone()
        await cur.close()
        total_pc = int((count_row[0] if count_row else 0) or 0)

    emb = discord.Embed(
        title=f"PC Box {box_no}/{box_count}",
        description=(
            "Manage your boxed Pok√©mon with the buttons below.\n"
            "Actions: **Box Swap (Team <-> Box)**, **Box Release**, **Box Move**, **Box Sort**, **Box Take**, **Box PK**"
        ),
        color=0x5865F2,
    )
    emb.add_field(name="Filled Slots", value=f"{len(mons)}/{box_capacity}", inline=True)
    emb.add_field(name="Total PC Mons", value=str(total_pc), inline=True)
    emb.add_field(name="Sort Keys", value="gender ‚Ä¢ total_ivs ‚Ä¢ level ‚Ä¢ shiny ‚Ä¢ legendary", inline=False)
    f = _box_panel_file(owner_id, box_no, box_count, box_capacity, mons, team_rows)
    files: list[discord.File] = []
    if f is not None:
        emb.set_image(url=f"attachment://box-panel.png")
        files.append(f)
    return emb, files, box_no, box_count


def _close_files(files: list[discord.File]) -> None:
    for f in files or []:
        try:
            f.close()
        except Exception:
            pass


def _parse_box_int(v: str | None) -> Optional[int]:
    try:
        n = int(str(v or "").strip())
        return n
    except Exception:
        return None


def _normalize_pokemon_nickname(raw: str | None, *, max_len: int = 20) -> str:
    txt = str(raw or "").replace("\n", " ").replace("\r", " ").strip()
    txt = re.sub(r"\s+", " ", txt)
    txt = txt.strip()
    if not txt:
        return ""
    return txt[: max(1, int(max_len))]


async def _ensure_pokemon_nicknames_table(conn: Any | None = None) -> None:
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await conn.execute(
            """
            CREATE TABLE IF NOT EXISTS pokemon_nicknames (
                owner_id TEXT NOT NULL,
                mon_id INTEGER NOT NULL,
                nickname TEXT NOT NULL,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (owner_id, mon_id)
            )
            """
        )
        if own_conn:
            await conn.commit()
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _get_pokemon_nickname(owner_id: str, mon_id: int, *, conn: Any | None = None) -> Optional[str]:
    if not owner_id or int(mon_id or 0) <= 0:
        return None
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await _ensure_pokemon_nicknames_table(conn)
        cur = await conn.execute(
            "SELECT nickname FROM pokemon_nicknames WHERE owner_id=? AND mon_id=? LIMIT 1",
            (str(owner_id), int(mon_id)),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return None
        raw = row["nickname"] if hasattr(row, "keys") else row[0]
        nick = _normalize_pokemon_nickname(raw, max_len=20)
        return nick or None
    except Exception:
        return None
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _get_pokemon_nickname_map(owner_id: str, mon_ids: Sequence[int], *, conn: Any | None = None) -> dict[int, str]:
    if not owner_id:
        return {}
    ids_clean: list[int] = []
    seen: set[int] = set()
    for mid in mon_ids or []:
        try:
            v = int(mid or 0)
        except Exception:
            continue
        if v <= 0 or v in seen:
            continue
        seen.add(v)
        ids_clean.append(v)
    if not ids_clean:
        return {}
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await _ensure_pokemon_nicknames_table(conn)
        placeholders = ", ".join("?" for _ in ids_clean)
        cur = await conn.execute(
            f"SELECT mon_id, nickname FROM pokemon_nicknames WHERE owner_id=? AND mon_id IN ({placeholders})",
            (str(owner_id), *ids_clean),
        )
        rows = await cur.fetchall()
        await cur.close()
        out: dict[int, str] = {}
        for r in rows or []:
            try:
                mid = int((r["mon_id"] if hasattr(r, "keys") else r[0]) or 0)
            except Exception:
                continue
            nick_raw = (r["nickname"] if hasattr(r, "keys") else r[1]) if r is not None else ""
            nick = _normalize_pokemon_nickname(nick_raw, max_len=20)
            if mid > 0 and nick:
                out[mid] = nick
        return out
    except Exception:
        return {}
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _set_pokemon_nickname(owner_id: str, mon_id: int, nickname: str | None, *, conn: Any | None = None) -> None:
    if not owner_id or int(mon_id or 0) <= 0:
        return
    nick = _normalize_pokemon_nickname(nickname, max_len=20)
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await _ensure_pokemon_nicknames_table(conn)
        if nick:
            await conn.execute(
                """
                INSERT INTO pokemon_nicknames (owner_id, mon_id, nickname)
                VALUES (?, ?, ?)
                ON CONFLICT (owner_id, mon_id) DO UPDATE SET
                    nickname = EXCLUDED.nickname,
                    updated_at = CURRENT_TIMESTAMP
                """,
                (str(owner_id), int(mon_id), nick),
            )
        else:
            await conn.execute(
                "DELETE FROM pokemon_nicknames WHERE owner_id=? AND mon_id=?",
                (str(owner_id), int(mon_id)),
            )
        if own_conn:
            await conn.commit()
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _ensure_pokemon_locks_table(conn: Any | None = None) -> None:
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await conn.execute(
            """
            CREATE TABLE IF NOT EXISTS pokemon_locks (
                owner_id TEXT NOT NULL,
                mon_id INTEGER NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (owner_id, mon_id)
            )
            """
        )
        if own_conn:
            await conn.commit()
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _is_pokemon_locked(owner_id: str, mon_id: int, *, conn: Any | None = None) -> bool:
    if not owner_id or int(mon_id or 0) <= 0:
        return False
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await _ensure_pokemon_locks_table(conn)
        cur = await conn.execute(
            "SELECT 1 FROM pokemon_locks WHERE owner_id=? AND mon_id=? LIMIT 1",
            (str(owner_id), int(mon_id)),
        )
        row = await cur.fetchone()
        await cur.close()
        return bool(row)
    except Exception:
        return False
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _set_pokemon_locked(owner_id: str, mon_id: int, locked: bool, *, conn: Any | None = None) -> None:
    if not owner_id or int(mon_id or 0) <= 0:
        return
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await _ensure_pokemon_locks_table(conn)
        if bool(locked):
            await conn.execute(
                "INSERT INTO pokemon_locks (owner_id, mon_id) VALUES (?, ?) ON CONFLICT (owner_id, mon_id) DO NOTHING",
                (str(owner_id), int(mon_id)),
            )
        else:
            await conn.execute(
                "DELETE FROM pokemon_locks WHERE owner_id=? AND mon_id=?",
                (str(owner_id), int(mon_id)),
            )
        if own_conn:
            await conn.commit()
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _get_locked_pokemon_ids(owner_id: str, *, conn: Any | None = None) -> set[int]:
    if not owner_id:
        return set()
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        await _ensure_pokemon_locks_table(conn)
        cur = await conn.execute(
            "SELECT mon_id FROM pokemon_locks WHERE owner_id=?",
            (str(owner_id),),
        )
        rows = await cur.fetchall()
        await cur.close()
        out: set[int] = set()
        for r in rows or []:
            try:
                mid = int((r["mon_id"] if hasattr(r, "keys") else r[0]) or 0)
            except Exception:
                mid = 0
            if mid > 0:
                out.add(mid)
        return out
    except Exception:
        return set()
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _get_registered_pokemon_ids(owner_id: str, mon_ids: Sequence[int], *, conn: Any | None = None) -> set[int]:
    if not owner_id:
        return set()
    ids_clean: list[int] = []
    seen: set[int] = set()
    for mid in mon_ids or []:
        try:
            i = int(mid or 0)
        except Exception:
            continue
        if i <= 0 or i in seen:
            continue
        seen.add(i)
        ids_clean.append(i)
    if not ids_clean:
        return set()
    own_conn = conn is None
    if own_conn:
        conn = await db.connect()
    try:
        try:
            await register_stats.ensure_schema(conn)
        except Exception:
            pass
        placeholders = ", ".join("?" for _ in ids_clean)
        cur = await conn.execute(
            f"SELECT mon_id FROM registered_mons WHERE owner_id=? AND mon_id IN ({placeholders})",
            (str(owner_id), *ids_clean),
        )
        rows = await cur.fetchall()
        await cur.close()
        out: set[int] = set()
        for r in rows or []:
            try:
                mid = int((r["mon_id"] if hasattr(r, "keys") else r[0]) or 0)
            except Exception:
                mid = 0
            if mid > 0:
                out.add(mid)
        return out
    except Exception:
        return set()
    finally:
        if own_conn and conn is not None:
            try:
                await conn.close()
            except Exception:
                pass


async def _box_swap_positions(owner_id: str, box_no: int, team_slot: int, box_pos: int) -> tuple[bool, str]:
    """
    Swap/move between one team slot and one box slot:
      - both occupied: swap
      - only team occupied: move team mon into box slot
      - only box occupied: move box mon into team slot
    """
    if not (1 <= int(team_slot) <= 6):
        return False, "Team slot must be between 1 and 6."
    box_count, box_capacity = await _box_get_box_count_and_capacity(owner_id)
    if not (1 <= int(box_no) <= int(box_count)):
        return False, f"Box number must be between 1 and {box_count}."
    if not (1 <= int(box_pos) <= int(box_capacity)):
        return False, f"Box slot must be between 1 and {box_capacity}."
    async with db.session() as conn:
        team_non_egg_count = await _team_non_egg_count(owner_id, conn=conn)
        cur = await conn.execute(
            "SELECT id, species FROM pokemons WHERE owner_id=? AND team_slot=? LIMIT 1",
            (owner_id, int(team_slot)),
        )
        team_row = await cur.fetchone()
        await cur.close()
        cur = await conn.execute(
            "SELECT id, species FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=? LIMIT 1",
            (owner_id, int(box_no), int(box_pos)),
        )
        box_row = await cur.fetchone()
        await cur.close()

        if not team_row and not box_row:
            return False, "Both the selected team slot and box slot are empty."

        if team_row and box_row:
            team_id = int(team_row["id"] if hasattr(team_row, "keys") else team_row[0])
            team_species = str(team_row["species"] if hasattr(team_row, "keys") else team_row[1])
            box_id = int(box_row["id"] if hasattr(box_row, "keys") else box_row[0])
            box_species = str(box_row["species"] if hasattr(box_row, "keys") else box_row[1])
            team_sp = _daycare_norm_species(team_species)
            box_sp = _daycare_norm_species(box_species)

            if team_sp != "egg" and box_sp == "egg" and int(team_non_egg_count) <= 1:
                return False, "You must keep at least one non-egg Pok√©mon in your team."
            await conn.execute(
                "UPDATE pokemons SET team_slot=NULL, box_no=?, box_pos=? WHERE owner_id=? AND id=?",
                (int(box_no), int(box_pos), owner_id, team_id),
            )
            await conn.execute(
                "UPDATE pokemons SET team_slot=?, box_no=NULL, box_pos=NULL WHERE owner_id=? AND id=?",
                (int(team_slot), owner_id, box_id),
            )
            await conn.commit()
            db.invalidate_pokemons_cache(owner_id)
            return True, (
                f"Swapped **{team_species.replace('-', ' ').title()}** (Team {team_slot}) "
                f"with **{box_species.replace('-', ' ').title()}** (Box {box_no}, Slot {box_pos})."
            )

        if team_row and not box_row:
            cur = await conn.execute(
                "SELECT species FROM pokemons WHERE owner_id=? AND id=? LIMIT 1",
                (owner_id, int(team_row["id"] if hasattr(team_row, "keys") else team_row[0])),
            )
            trow = await cur.fetchone()
            await cur.close()
            team_sp = _daycare_norm_species((trow["species"] if trow and hasattr(trow, "keys") else (trow[0] if trow else "")) or "")
            if team_sp != "egg" and int(team_non_egg_count) <= 1:
                return False, "You must keep at least one non-egg Pok√©mon in your team."

            team_id = int(team_row["id"] if hasattr(team_row, "keys") else team_row[0])
            team_species = str(team_row["species"] if hasattr(team_row, "keys") else team_row[1])
            await conn.execute(
                "UPDATE pokemons SET team_slot=NULL, box_no=?, box_pos=? WHERE owner_id=? AND id=?",
                (int(box_no), int(box_pos), owner_id, team_id),
            )
            await conn.commit()
            db.invalidate_pokemons_cache(owner_id)
            await _compact_team_slots(owner_id)
            return True, (
                f"Moved **{team_species.replace('-', ' ').title()}** from Team {team_slot} "
                f"to Box {box_no}, Slot {box_pos}."
            )

        box_id = int(box_row["id"] if hasattr(box_row, "keys") else box_row[0])
        box_species = str(box_row["species"] if hasattr(box_row, "keys") else box_row[1])
        box_sp = _daycare_norm_species(box_species)
        if box_sp == "egg" and int(team_non_egg_count) <= 0:
            return False, "You must keep at least one non-egg Pok√©mon in your team."
        await conn.execute(
            "UPDATE pokemons SET team_slot=?, box_no=NULL, box_pos=NULL WHERE owner_id=? AND id=?",
            (int(team_slot), owner_id, box_id),
        )
        await conn.commit()
    db.invalidate_pokemons_cache(owner_id)
    return True, f"Moved **{box_species.replace('-', ' ').title()}** from Box {box_no}, Slot {box_pos} to Team {team_slot}."


async def _box_move_mon(owner_id: str, src_box: int, src_pos: int, dst_box: int, dst_pos: Optional[int]) -> tuple[bool, str]:
    if int(src_box) == int(dst_box):
        return False, "Box Move only moves Pok√©mon to a different box."
    box_count, box_capacity = await _box_get_box_count_and_capacity(owner_id)
    if not (1 <= int(dst_box) <= box_count):
        return False, f"Destination box must be between 1 and {box_count}."
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT id, species FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=? LIMIT 1",
            (owner_id, int(src_box), int(src_pos)),
        )
        src = await cur.fetchone()
        await cur.close()
        if not src:
            return False, "No Pok√©mon found in that source slot."
        mon_id = int(src["id"] if hasattr(src, "keys") else src[0])
        species = str(src["species"] if hasattr(src, "keys") else src[1])

        if dst_pos is None:
            cur = await conn.execute(
                "SELECT box_pos FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=?",
                (owner_id, int(dst_box)),
            )
            used = {int((r["box_pos"] if hasattr(r, "keys") else r[0]) or 0) for r in await cur.fetchall()}
            await cur.close()
            pick = None
            for p in range(1, box_capacity + 1):
                if p not in used:
                    pick = p
                    break
            if pick is None:
                return False, f"Box {dst_box} is full."
            dst_pos = pick
        else:
            if not (1 <= int(dst_pos) <= box_capacity):
                return False, f"Destination position must be between 1 and {box_capacity}."
            cur = await conn.execute(
                "SELECT 1 FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=? LIMIT 1",
                (owner_id, int(dst_box), int(dst_pos)),
            )
            occupied = await cur.fetchone()
            await cur.close()
            if occupied:
                return False, "Destination position is already occupied."

        await conn.execute(
            "UPDATE pokemons SET box_no=?, box_pos=? WHERE owner_id=? AND id=?",
            (int(dst_box), int(dst_pos), owner_id, mon_id),
        )
        await _box_compact_positions_conn(conn, owner_id, int(src_box))
        await conn.commit()
    db.invalidate_pokemons_cache(owner_id)
    return True, f"Moved **{species.replace('-', ' ').title()}** to Box **{dst_box}**, Slot **{dst_pos}**."


async def _box_release_mon(owner_id: str, box_no: int, box_pos: int) -> tuple[bool, str]:
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT id, species, held_item FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=? LIMIT 1",
            (owner_id, int(box_no), int(box_pos)),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return False, "No Pok√©mon found in that box slot."
        mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
        species = str(row["species"] if hasattr(row, "keys") else row[1])
        held_item = str((row["held_item"] if hasattr(row, "keys") else row[2]) or "").strip()
        if await _is_pokemon_locked(owner_id, mon_id, conn=conn):
            return (
                False,
                f"**{species.replace('-', ' ').title()}** is locked. "
                f"Use `/boxpklock box_no:{int(box_no)} pos:{int(box_pos)} lock:false` first.",
            )

        await conn.execute("DELETE FROM pokemons WHERE owner_id=? AND id=?", (owner_id, mon_id))
        await conn.execute("DELETE FROM pokemon_locks WHERE owner_id=? AND mon_id=?", (owner_id, mon_id))
        try:
            await _ensure_pokemon_nicknames_table(conn)
            await conn.execute("DELETE FROM pokemon_nicknames WHERE owner_id=? AND mon_id=?", (owner_id, mon_id))
        except Exception:
            pass
        await _box_compact_positions_conn(conn, owner_id, int(box_no))
        await conn.commit()
    db.invalidate_pokemons_cache(owner_id)
    extra = ""
    if held_item:
        try:
            await db.give_item(owner_id, held_item, 1)
            extra = f" Returned held item **{pretty_item_name(held_item)}** to your bag."
        except Exception:
            pass
    return True, f"Released **{species.replace('-', ' ').title()}** from Box {box_no}, Slot {box_pos}.{extra}"


async def _box_take_item(owner_id: str, box_no: int, box_pos: int) -> tuple[bool, str]:
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT id, species, held_item FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=? LIMIT 1",
            (owner_id, int(box_no), int(box_pos)),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return False, "No Pok√©mon found in that box slot."
        mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
        species = str(row["species"] if hasattr(row, "keys") else row[1])
        held_item = str((row["held_item"] if hasattr(row, "keys") else row[2]) or "").strip()
        if not held_item:
            return False, f"**{species.replace('-', ' ').title()}** is not holding an item."

        await conn.execute("UPDATE pokemons SET held_item=NULL WHERE owner_id=? AND id=?", (owner_id, mon_id))
        await conn.commit()
    db.invalidate_pokemons_cache(owner_id)
    try:
        await db.give_item(owner_id, held_item, 1)
    except Exception:
        pass
    return True, f"Took **{pretty_item_name(held_item)}** from **{species.replace('-', ' ').title()}** and placed it in your bag."


async def _box_sort(owner_id: str, box_no: int, raw_methods: str | None) -> tuple[bool, str]:
    methods = _box_parse_sort_methods(raw_methods)
    async with db.session() as conn:
        cur = await conn.execute(
            """
            SELECT id, species, level, gender, shiny, ivs, box_pos
            FROM pokemons
            WHERE owner_id=? AND team_slot IS NULL AND box_no=?
            ORDER BY box_pos, id
            """,
            (owner_id, int(box_no)),
        )
        rows = [dict(r) for r in await cur.fetchall()]
        await cur.close()
        if not rows:
            return False, "This box is empty."

        def sort_key(row: dict) -> tuple:
            keys: list[Any] = []
            for m in methods:
                if m == "gender":
                    keys.append(_box_gender_rank(row.get("gender")))
                elif m == "total_ivs":
                    keys.append(-_box_total_ivs(row))
                elif m == "level":
                    keys.append(-int(row.get("level") or 0))
                elif m == "shiny":
                    keys.append(-int(row.get("shiny") or 0))
                elif m == "legendary":
                    keys.append(0 if _box_is_legendary_species(row.get("species")) else 1)
            keys.append(int(row.get("box_pos") or 9999))
            keys.append(int(row.get("id") or 0))
            return tuple(keys)

        rows_sorted = sorted(rows, key=sort_key)
        for i, row in enumerate(rows_sorted, start=1):
            await conn.execute(
                "UPDATE pokemons SET box_pos=? WHERE owner_id=? AND id=?",
                (i, owner_id, int(row.get("id") or 0)),
            )
        await conn.commit()
    db.invalidate_pokemons_cache(owner_id)
    return True, f"Sorted Box {box_no} by **{', '.join(methods)}**."


def _parse_box_csv_slots(raw: str) -> list[int]:
    text = str(raw or "").strip()
    if not text:
        return []
    out: list[int] = []
    for part in text.replace(";", ",").split(","):
        p = str(part or "").strip()
        if not p:
            continue
        v = _parse_box_int(p)
        if not v:
            return []
        out.append(int(v))
    return out


async def _box_swap_many(owner_id: str, box_no: int, team_slots: list[int], box_positions: list[int]) -> tuple[bool, str]:
    if not team_slots or not box_positions:
        return False, "Enter at least one team slot and one box slot."
    if len(team_slots) != len(box_positions):
        return False, "Team slot list and box slot list must have the same number of entries."
    lines: list[str] = []
    any_ok = False
    for idx, (ts, bp) in enumerate(zip(team_slots, box_positions), start=1):
        ok, msg = await _box_swap_positions(owner_id, int(box_no), int(ts), int(bp))
        any_ok = any_ok or ok
        lines.append(f"{'‚úÖ' if ok else '‚ùå'} Pair {idx} (Team {ts} ‚Üî Box {bp}): {msg}")
    return any_ok, "\n".join(lines)


async def _box_release_many(owner_id: str, box_no: int, positions: list[int]) -> tuple[bool, str]:
    if not positions:
        return False, "Enter at least one box slot to release."
    # Release in descending slot order so compaction doesn't shift upcoming targets.
    unique_order: list[int] = []
    seen: set[int] = set()
    for p in positions:
        if int(p) in seen:
            continue
        seen.add(int(p))
        unique_order.append(int(p))
    results: dict[int, tuple[bool, str]] = {}
    for p in sorted(unique_order, reverse=True):
        results[p] = await _box_release_mon(owner_id, int(box_no), int(p))
    lines: list[str] = []
    any_ok = False
    for p in unique_order:
        ok, msg = results.get(int(p), (False, "Unknown error."))
        any_ok = any_ok or ok
        lines.append(f"{'‚úÖ' if ok else '‚ùå'} Slot {p}: {msg}")
    return any_ok, "\n".join(lines)


class BoxSwapModal(ui.Modal, title="Box Swap (Team <-> Box)"):
    team_slot = ui.TextInput(label="Team slot(s)", placeholder="e.g. 1,5,6", required=True, max_length=64)
    box_pos = ui.TextInput(label="Box slot position(s)", placeholder="e.g. 12,4,17", required=True, max_length=128)

    def __init__(self, owner_id: str, box_no: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.box_no = int(box_no)

    async def on_submit(self, interaction: Interaction):
        if str(interaction.user.id) != self.owner_id:
            return await interaction.response.send_message("this isn't for you", ephemeral=True)
        team_slots = _parse_box_csv_slots(str(self.team_slot.value))
        box_positions = _parse_box_csv_slots(str(self.box_pos.value))
        if not team_slots or not box_positions:
            return await interaction.response.send_message("Please enter valid team slot(s) and box slot(s).", ephemeral=True)
        if any(not (1 <= int(ts) <= 6) for ts in team_slots):
            return await interaction.response.send_message("Each team slot must be between 1 and 6.", ephemeral=True)
        ok, msg = await _box_swap_many(self.owner_id, self.box_no, team_slots, box_positions)
        await interaction.response.send_message(("‚úÖ " if ok else "‚ùå ") + msg + "\nUse **Refresh** on your box panel to update.", ephemeral=True)


class BoxReleaseModal(ui.Modal, title="Box Release"):
    pos = ui.TextInput(label="Slot position(s) to release", placeholder="e.g. 5,9,13", required=True, max_length=128)

    def __init__(self, owner_id: str, box_no: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.box_no = int(box_no)

    async def on_submit(self, interaction: Interaction):
        if str(interaction.user.id) != self.owner_id:
            return await interaction.response.send_message("this isn't for you", ephemeral=True)
        positions = _parse_box_csv_slots(str(self.pos.value))
        if not positions:
            return await interaction.response.send_message("Please enter valid slot number(s).", ephemeral=True)
        ok, msg = await _box_release_many(self.owner_id, self.box_no, positions)
        await interaction.response.send_message(("‚úÖ " if ok else "‚ùå ") + msg + "\nUse **Refresh** on your box panel to update.", ephemeral=True)


class BoxMoveModal(ui.Modal, title="Box Move"):
    src_pos = ui.TextInput(label="Source slot position", placeholder="e.g. 4", required=True, max_length=3)
    dst_box = ui.TextInput(label="Destination box number", placeholder="e.g. 2", required=True, max_length=3)
    dst_pos = ui.TextInput(label="Destination slot (optional)", placeholder="blank = first free", required=False, max_length=3)

    def __init__(self, owner_id: str, box_no: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.box_no = int(box_no)

    async def on_submit(self, interaction: Interaction):
        if str(interaction.user.id) != self.owner_id:
            return await interaction.response.send_message("this isn't for you", ephemeral=True)
        s = _parse_box_int(str(self.src_pos.value))
        b = _parse_box_int(str(self.dst_box.value))
        p = _parse_box_int(str(self.dst_pos.value)) if str(self.dst_pos.value or "").strip() else None
        if not s or not b:
            return await interaction.response.send_message("Please enter valid source slot and destination box.", ephemeral=True)
        ok, msg = await _box_move_mon(self.owner_id, self.box_no, s, b, p)
        await interaction.response.send_message(("‚úÖ " if ok else "‚ùå ") + msg + "\nUse **Refresh** on your box panel to update.", ephemeral=True)


class BoxSortModal(ui.Modal, title="Box Sort"):
    methods = ui.TextInput(
        label="Sort methods",
        placeholder="level, total_ivs, gender, shiny, legendary",
        required=True,
        max_length=80,
    )

    def __init__(self, owner_id: str, box_no: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.box_no = int(box_no)

    async def on_submit(self, interaction: Interaction):
        if str(interaction.user.id) != self.owner_id:
            return await interaction.response.send_message("this isn't for you", ephemeral=True)
        ok, msg = await _box_sort(self.owner_id, self.box_no, str(self.methods.value))
        await interaction.response.send_message(("‚úÖ " if ok else "‚ùå ") + msg + "\nUse **Refresh** on your box panel to update.", ephemeral=True)


class BoxTakeModal(ui.Modal, title="Box Take Item"):
    pos = ui.TextInput(label="Slot position to take item from", placeholder="e.g. 7", required=True, max_length=3)

    def __init__(self, owner_id: str, box_no: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.box_no = int(box_no)

    async def on_submit(self, interaction: Interaction):
        if str(interaction.user.id) != self.owner_id:
            return await interaction.response.send_message("this isn't for you", ephemeral=True)
        p = _parse_box_int(str(self.pos.value))
        if not p:
            return await interaction.response.send_message("Please enter a valid slot number.", ephemeral=True)
        ok, msg = await _box_take_item(self.owner_id, self.box_no, p)
        await interaction.response.send_message(("‚úÖ " if ok else "‚ùå ") + msg + "\nUse **Refresh** on your box panel to update.", ephemeral=True)


async def _box_mon_info_payload(owner_id: str, box_no: int, box_pos: int) -> tuple[bool, str | discord.Embed]:
    async with db.session() as conn:
        cur = await conn.execute(
            """
            SELECT id, species, level, gender, nature, ability, shiny, held_item, friendship, ivs, evs, moves
            FROM pokemons
            WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=?
            LIMIT 1
            """,
            (owner_id, int(box_no), int(box_pos)),
        )
        row = await cur.fetchone()
        await cur.close()
    if not row:
        return False, "No Pok√©mon found in that box slot."

    d = dict(row) if hasattr(row, "keys") else {
        "id": row[0],
        "species": row[1],
        "level": row[2],
        "gender": row[3],
        "nature": row[4],
        "ability": row[5],
        "shiny": row[6],
        "held_item": row[7],
        "friendship": row[8],
        "ivs": row[9],
        "evs": row[10],
        "moves": row[11],
    }
    species = str(d.get("species") or "Unknown").replace("-", " ").title()
    mon_id = int(d.get("id") or 0)
    is_locked = False
    if mon_id > 0:
        try:
            is_locked = await _is_pokemon_locked(owner_id, mon_id)
        except Exception:
            is_locked = False
    shiny = bool(d.get("shiny"))
    title = f"{'üîí ' if is_locked else ''}{'‚ú® ' if shiny else ''}{species} ‚Äî Box {box_no}, Slot {box_pos}"
    emb = discord.Embed(title=title, color=(0xF1C40F if shiny else 0x5865F2))
    emb.add_field(name="Level", value=str(int(d.get("level") or 1)), inline=True)
    emb.add_field(name="Gender", value=str(d.get("gender") or "Unknown").title(), inline=True)
    emb.add_field(name="Nature", value=str(d.get("nature") or "Hardy").title(), inline=True)
    emb.add_field(name="Ability", value=str(d.get("ability") or "Unknown").replace("-", " ").title(), inline=True)
    emb.add_field(name="Friendship", value=str(int(d.get("friendship") or 0)), inline=True)
    emb.add_field(name="Lock", value=("üîí Locked" if is_locked else "‚Äî"), inline=True)
    held = str(d.get("held_item") or "").strip()
    emb.add_field(name="Held Item", value=(pretty_item_name(held) if held else "None"), inline=True)
    try:
        emb.add_field(name="Total IVs", value=str(_box_total_ivs(d)), inline=True)
    except Exception:
        emb.add_field(name="Total IVs", value="0", inline=True)
    moves = _team_parse_moves(d.get("moves"))
    emb.add_field(
        name="Moves",
        value="\n".join(f"‚Ä¢ {m.replace('-', ' ').title()}" for m in moves[:4]) if moves else "None",
        inline=False,
    )
    return True, emb


class BoxPkModal(ui.Modal, title="Box PK Info"):
    pos = ui.TextInput(label="Slot position", placeholder="e.g. 7", required=True, max_length=3)

    def __init__(self, owner_id: str, box_no: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.box_no = int(box_no)

    async def on_submit(self, interaction: Interaction):
        if str(interaction.user.id) != self.owner_id:
            return await interaction.response.send_message("this isn't for you", ephemeral=True)
        p = _parse_box_int(str(self.pos.value))
        if not p:
            return await interaction.response.send_message("Please enter a valid slot number.", ephemeral=True)
        ok, payload = await _box_mon_info_payload(self.owner_id, self.box_no, int(p))
        if not ok:
            return await interaction.response.send_message(f"‚ùå {payload}", ephemeral=True)
        await interaction.response.send_message(embed=payload, ephemeral=True)


class BoxMainView(discord.ui.View):
    def __init__(self, owner_discord_id: int, owner_id: str, box_no: int, box_count: int):
        super().__init__(timeout=300)
        self.owner_discord_id = int(owner_discord_id)
        self.owner_id = owner_id
        self.box_no = int(box_no)
        self.box_count = int(box_count)
        self.prev_button.disabled = self.box_no <= 1
        self.next_button.disabled = self.box_no >= self.box_count

    async def interaction_check(self, itx: Interaction) -> bool:
        if int(itx.user.id) != self.owner_discord_id:
            await itx.response.send_message("this isn't for you", ephemeral=True)
            return False
        return True

    async def _rerender(self, itx: Interaction, new_box_no: int):
        emb, files, box_no, box_count = await _box_render_payload(self.owner_id, new_box_no)
        new_view = BoxMainView(self.owner_discord_id, self.owner_id, box_no, box_count)
        try:
            await itx.response.edit_message(embed=emb, attachments=files, view=new_view)
        except TypeError:
            await itx.response.edit_message(embed=emb, files=files, view=new_view)
        finally:
            _close_files(files)

    @ui.button(label="‚óÄ Prev", style=discord.ButtonStyle.secondary, row=0)
    async def prev_button(self, itx: Interaction, _btn: ui.Button):
        await self._rerender(itx, max(1, self.box_no - 1))

    @ui.button(label="Next ‚ñ∂", style=discord.ButtonStyle.secondary, row=0)
    async def next_button(self, itx: Interaction, _btn: ui.Button):
        await self._rerender(itx, min(self.box_count, self.box_no + 1))

    @ui.button(label="Refresh", style=discord.ButtonStyle.secondary, row=0)
    async def refresh_button(self, itx: Interaction, _btn: ui.Button):
        await self._rerender(itx, self.box_no)

    @ui.button(label="Box Swap", style=discord.ButtonStyle.primary, row=1)
    async def swap_button(self, itx: Interaction, _btn: ui.Button):
        await itx.response.send_modal(BoxSwapModal(self.owner_id, self.box_no))

    @ui.button(label="Box Move", style=discord.ButtonStyle.primary, row=1)
    async def move_button(self, itx: Interaction, _btn: ui.Button):
        await itx.response.send_modal(BoxMoveModal(self.owner_id, self.box_no))

    @ui.button(label="Box Sort", style=discord.ButtonStyle.primary, row=1)
    async def sort_button(self, itx: Interaction, _btn: ui.Button):
        await itx.response.send_modal(BoxSortModal(self.owner_id, self.box_no))

    @ui.button(label="Box Release", style=discord.ButtonStyle.danger, row=2)
    async def release_button(self, itx: Interaction, _btn: ui.Button):
        await itx.response.send_modal(BoxReleaseModal(self.owner_id, self.box_no))

    @ui.button(label="Box Take", style=discord.ButtonStyle.success, row=2)
    async def take_button(self, itx: Interaction, _btn: ui.Button):
        await itx.response.send_modal(BoxTakeModal(self.owner_id, self.box_no))

    @ui.button(label="Box PK", style=discord.ButtonStyle.secondary, row=2)
    async def boxpk_button(self, itx: Interaction, _btn: ui.Button):
        await itx.response.send_modal(BoxPkModal(self.owner_id, self.box_no))


@bot.tree.command(name="box", description="Open your PC boxes and manage stored Pok√©mon.")
@app_commands.describe(box_no="Box number to open (default 1)")
async def box_command(interaction: discord.Interaction, box_no: app_commands.Range[int, 1, 64] = 1):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    emb, files, box_no, box_count = await _box_render_payload(uid, int(box_no))
    view = BoxMainView(interaction.user.id, uid, box_no, box_count)
    try:
        await interaction.followup.send(embed=emb, files=files, view=view, ephemeral=False)
    finally:
        _close_files(files)


async def _validate_box_and_slot(
    owner_id: str,
    box_no: int,
    *,
    slot: Optional[int] = None,
) -> tuple[bool, str, int, int]:
    await _box_prepare_storage(owner_id)
    box_count, box_capacity = await _box_get_box_count_and_capacity(owner_id)
    if not (1 <= int(box_no) <= int(box_count)):
        return False, f"Box number must be between 1 and {box_count}.", box_count, box_capacity
    if slot is not None and not (1 <= int(slot) <= int(box_capacity)):
        return False, f"Slot must be between 1 and {box_capacity}.", box_count, box_capacity
    return True, "", box_count, box_capacity


@bot.tree.command(name="boxswap", description="Swap/move between team and box slots (supports comma lists).")
@app_commands.describe(box_no="Box number", team_slots="Team slots (e.g. 1,5,6)", box_positions="Box slots (e.g. 12,4,17)")
async def boxswap_command(
    interaction: discord.Interaction,
    box_no: app_commands.Range[int, 1, 64],
    team_slots: str,
    box_positions: str,
):
    await interaction.response.defer(ephemeral=True)
    owner_id = str(interaction.user.id)
    team_list = _parse_box_csv_slots(team_slots)
    box_list = _parse_box_csv_slots(box_positions)
    if not team_list or not box_list:
        return await interaction.followup.send("‚ùå Provide valid team and box slot list(s), separated by commas.", ephemeral=True)
    if any(not (1 <= int(ts) <= 6) for ts in team_list):
        return await interaction.followup.send("‚ùå Team slots must be between 1 and 6.", ephemeral=True)
    ok, msg, _count, cap = await _validate_box_and_slot(owner_id, int(box_no))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    if any(not (1 <= int(bp) <= int(cap)) for bp in box_list):
        return await interaction.followup.send(f"‚ùå Box positions must be between 1 and {cap}.", ephemeral=True)
    changed, out = await _box_swap_many(owner_id, int(box_no), team_list, box_list)
    await interaction.followup.send(("‚úÖ " if changed else "‚ùå ") + out, ephemeral=True)


@bot.tree.command(name="boxmove", description="Move a boxed Pok√©mon to a different box.")
@app_commands.describe(
    src_box="Source box number",
    src_pos="Source slot position",
    dst_box="Destination box number",
    dst_pos="Destination slot (leave empty for first free)",
)
async def boxmove_command(
    interaction: discord.Interaction,
    src_box: app_commands.Range[int, 1, 64],
    src_pos: app_commands.Range[int, 1, 180],
    dst_box: app_commands.Range[int, 1, 64],
    dst_pos: Optional[int] = None,
):
    await interaction.response.defer(ephemeral=True)
    owner_id = str(interaction.user.id)
    ok, msg, _count, _cap = await _validate_box_and_slot(owner_id, int(src_box), slot=int(src_pos))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    ok, msg, _count, cap = await _validate_box_and_slot(owner_id, int(dst_box))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    if dst_pos is not None and not (1 <= int(dst_pos) <= int(cap)):
        return await interaction.followup.send(f"‚ùå Destination slot must be between 1 and {cap}.", ephemeral=True)
    changed, out = await _box_move_mon(owner_id, int(src_box), int(src_pos), int(dst_box), int(dst_pos) if dst_pos is not None else None)
    await interaction.followup.send(("‚úÖ " if changed else "‚ùå ") + out, ephemeral=True)


@bot.tree.command(name="boxrelease", description="Release one or more Pok√©mon from your box (comma list supported).")
@app_commands.describe(box_no="Box number", positions="Slot positions to release (e.g. 5,9,13)")
async def boxrelease_command(
    interaction: discord.Interaction,
    box_no: app_commands.Range[int, 1, 64],
    positions: str,
):
    await interaction.response.defer(ephemeral=True)
    owner_id = str(interaction.user.id)
    pos_list = _parse_box_csv_slots(positions)
    if not pos_list:
        return await interaction.followup.send("‚ùå Provide valid box slot position(s), separated by commas.", ephemeral=True)
    ok, msg, _count, cap = await _validate_box_and_slot(owner_id, int(box_no))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    if any(not (1 <= int(p) <= int(cap)) for p in pos_list):
        return await interaction.followup.send(f"‚ùå Box positions must be between 1 and {cap}.", ephemeral=True)
    changed, out = await _box_release_many(owner_id, int(box_no), pos_list)
    await interaction.followup.send(("‚úÖ " if changed else "‚ùå ") + out, ephemeral=True)


@bot.tree.command(name="boxsort", description="Sort one box by your chosen keys.")
@app_commands.describe(box_no="Box number", methods="Comma-separated keys: gender,total_ivs,level,shiny,legendary")
async def boxsort_command(
    interaction: discord.Interaction,
    box_no: app_commands.Range[int, 1, 64],
    methods: str,
):
    await interaction.response.defer(ephemeral=True)
    owner_id = str(interaction.user.id)
    ok, msg, _count, _cap = await _validate_box_and_slot(owner_id, int(box_no))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    changed, out = await _box_sort(owner_id, int(box_no), methods)
    await interaction.followup.send(("‚úÖ " if changed else "‚ùå ") + out, ephemeral=True)


@bot.tree.command(name="boxtake", description="Take a held item from a boxed Pok√©mon.")
@app_commands.describe(box_no="Box number", pos="Slot position")
async def boxtake_command(
    interaction: discord.Interaction,
    box_no: app_commands.Range[int, 1, 64],
    pos: app_commands.Range[int, 1, 180],
):
    await interaction.response.defer(ephemeral=True)
    owner_id = str(interaction.user.id)
    ok, msg, _count, _cap = await _validate_box_and_slot(owner_id, int(box_no), slot=int(pos))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    changed, out = await _box_take_item(owner_id, int(box_no), int(pos))
    await interaction.followup.send(("‚úÖ " if changed else "‚ùå ") + out, ephemeral=True)


@bot.tree.command(name="boxpk", description="View mypokeinfo-style details for a boxed Pok√©mon.")
@app_commands.describe(box_no="Box number", pos="Slot position")
async def boxpk_command(
    interaction: discord.Interaction,
    box_no: app_commands.Range[int, 1, 64],
    pos: app_commands.Range[int, 1, 180],
):
    await interaction.response.defer(ephemeral=True)
    owner_id = str(interaction.user.id)
    ok, msg, _count, _cap = await _validate_box_and_slot(owner_id, int(box_no), slot=int(pos))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)
    ok, payload = await _box_mon_info_payload(owner_id, int(box_no), int(pos))
    if not ok:
        return await interaction.followup.send(f"‚ùå {payload}", ephemeral=True)
    await interaction.followup.send(embed=payload, ephemeral=True)


async def _create_pokemon_from_parsed(
    owner_id: str,
    parsed: ParsedPokemon,
    species_entry: dict,
    base_stats: dict
) -> tuple[int, list[str]]:
    """Create a Pok√©mon from a parsed Showdown format entry.
    
    Returns:
        Tuple of (mon_id, warnings) where warnings is a list of warning messages.
    """
    warnings = []
    # Normalize base stats to long keys
    base_stats_long = normalize_base_stats(base_stats)
    
    # Get IVs and EVs (default to 31 IVs, 0 EVs if not specified)
    ivs = parsed.ivs.copy()
    evs = parsed.evs.copy()
    
    # Ensure all stat keys are present
    for stat in ["hp", "attack", "defense", "special_attack", "special_defense", "speed"]:
        if stat not in ivs:
            ivs[stat] = 31
        if stat not in evs:
            evs[stat] = 0
    
    # Get nature (default to random if not specified)
    nature = parsed.nature or "hardy"
    
    # Calculate final stats
    final_stats = calc_all_stats(base_stats_long, ivs, evs, parsed.level, nature)
    
    # Get and validate ability
    # First, try to get form-specific abilities if form is specified
    abilities_raw = species_entry.get("abilities") or []
    
    # Check for form-specific abilities
    if parsed.form:
        species_id = species_entry.get("id")
        if species_id:
            try:
                async with db.session() as conn:
                    form_normalized = parsed.form.lower().strip()
                    species_normalized = parsed.species.lower().strip()
                    form_keys_to_try = [
                        form_normalized,
                        f"{species_normalized}-{form_normalized}",
                        form_normalized.replace("-", ""),
                        form_normalized.replace("_", "-"),
                        f"{form_normalized}-form",
                        f"{form_normalized}-forme"
                    ]
                    form_abilities = None
                    for form_key in form_keys_to_try:
                        form_row = await _safe_pokedex_forms_fetchone(
                            conn,
                            "SELECT abilities FROM pokedex_forms WHERE species_id = ? AND LOWER(form_key) = LOWER(?)",
                            (species_id, form_key),
                        )
                        if form_row and form_row.get("abilities"):
                            form_abilities = form_row.get("abilities")
                            break
                    if form_abilities:
                        abilities_raw = form_abilities
            except Exception:
                pass

    regs, hides = parse_abilities(abilities_raw)
    all_valid_abilities = regs + hides
    # Normalize all valid abilities for comparison
    valid_abilities_normalized = {a.lower().replace(" ", "-").replace("_", "-") for a in all_valid_abilities}
    
    ability = parsed.ability
    
    if ability:
        # Normalize the parsed ability for comparison
        ability_normalized = ability.lower().replace(" ", "-").replace("_", "-")
        if ability_normalized not in valid_abilities_normalized:
            # Invalid ability - fall back to first valid ability
            original_ability = ability
            ability = regs[0] if regs else (hides[0] if hides else None)
            if ability:
                ability = ability.lower().replace(" ", "-")
            warnings.append(f"‚ö†Ô∏è {parsed.species} cannot have ability '{original_ability}'. Using '{ability}' instead.")
        else:
            # Valid ability - normalize it
            ability = ability_normalized
    else:
        # No ability specified - get default from species
        ability = regs[0] if regs else (hides[0] if hides else None)
        if ability:
            ability = ability.lower().replace(" ", "-")
    
    # Get gender (default to random if not specified)
    gender = parsed.gender
    if not gender:
        gender_ratio = species_entry.get("gender_ratio") or {}
        if isinstance(gender_ratio, str):
            try:
                gender_ratio = json.loads(gender_ratio)
            except Exception:
                gender_ratio = {}
        if gender_ratio.get("genderless"):
            gender = "genderless"
        else:
            # Roll gender based on ratio
            male = gender_ratio.get("male", 50)
            if random.randint(1, 100) <= male:
                gender = "male"
            else:
                gender = "female"
    
    # Create the Pok√©mon (cloud DB)
    mon_id = await db.add_pokemon_with_stats(
        owner_id=owner_id,
        species=parsed.species,
        level=parsed.level,
        final_stats=final_stats,
        ivs=ivs,
        evs=evs,
        nature=nature,
        ability=ability,
        gender=gender,
        form=parsed.form,
        tera_type=parsed.tera_type
    )

    # Set exp/exp_group from pokedex, shiny, held_item ‚Äî one session for cloud DB
    try:
        async with db.session() as conn:
            exp_group = await _get_exp_group_for_species(conn, parsed.species)
            initial_exp = await _get_exp_total_for_level(conn, exp_group, parsed.level)
            await conn.execute(
                "UPDATE pokemons SET exp=?, exp_group=? WHERE owner_id=? AND id=?",
                (initial_exp, exp_group, owner_id, mon_id),
            )
            if parsed.shiny:
                await conn.execute(
                    "UPDATE pokemons SET shiny=1 WHERE owner_id=? AND id=?",
                    (owner_id, mon_id),
                )
            if parsed.item:
                item_id = parsed.item.lower().replace(" ", "-")
                try:
                    await conn.execute(
                        "UPDATE pokemons SET held_item=? WHERE owner_id=? AND id=?",
                        (item_id, owner_id, mon_id),
                    )
                except Exception:
                    pass
            await conn.commit()
            db.invalidate_pokemons_cache(owner_id)
    except Exception:
        pass

    try:
        if parsed.moves:
            await db.set_pokemon_moves(owner_id, mon_id, parsed.moves)
        
        # Set friendship (default to max 255 if not specified)
        # Use getattr to safely handle missing friendship attribute
        friendship_value = getattr(parsed, 'friendship', None)
        if friendship_value is None:
            friendship_value = 255  # Default to max friendship
        await _set_friendship(owner_id, mon_id, friendship_value)
    except Exception as e:
        # Log but don't fail the import
        print(f"[Import] Error setting additional properties: {e}")
    
    return mon_id, warnings


@bot.tree.command(name="import_team", description="Import a team from Pok√©mon Showdown format.")
@app_commands.describe(
    team_text="The team in Showdown format (paste the entire team export)"
)
async def import_team(interaction: discord.Interaction, team_text: str):
    """Import a team from Pok√©mon Showdown format."""
    await interaction.response.defer(ephemeral=False)
    
    uid = str(interaction.user.id)
    
    try:
        # Parse the team
        parsed_team = parse_showdown_team(team_text)
        
        if not parsed_team:
            await interaction.followup.send("‚ùå No valid Pok√©mon found in the team text. Please check the format.", ephemeral=True)
            return
        
        if len(parsed_team) > 6:
            await interaction.followup.send(f"‚ùå Team has {len(parsed_team)} Pok√©mon. Maximum is 6.", ephemeral=True)
            return

        # Clear existing team (remove all Pokemon from team slots) ‚Äî use session for cloud DB
        async with db.session() as conn:
            await conn.execute(
                "UPDATE pokemons SET team_slot = NULL WHERE owner_id=? AND team_slot BETWEEN 1 AND 6",
                (uid,)
            )
            await conn.commit()
            db.invalidate_pokemons_cache(uid)

        species_lookups = [(p, p.species.lower().replace(" ", "-"), p.species.lower()) for p in parsed_team]
        all_coros = []
        for _, n, f in species_lookups:
            all_coros.append(db.get_pokedex_by_name(n))
            all_coros.append(db.get_pokedex_by_name(f))
        species_results = await asyncio.gather(*all_coros)
        
        created = []
        errors = []
        warnings = []
        for i, (parsed, norm, fallback) in enumerate(species_lookups):
            try:
                species_entry = species_results[2 * i] or species_results[2 * i + 1]
                if not species_entry:
                    errors.append(f"{parsed.species}: not found in Pok√©dex")
                    continue
                parsed.species = species_entry.get("name", norm)
                base_stats = species_entry.get("stats") or {}
                if isinstance(base_stats, str):
                    try:
                        base_stats = json.loads(base_stats)
                    except Exception:
                        base_stats = {}
                mon_id, mon_warnings = await _create_pokemon_from_parsed(uid, parsed, species_entry, base_stats)
                slot = i + 1
                await db.set_team_slot(uid, mon_id, slot)
                created.append(f"{parsed.species} (slot {slot})")
                if mon_warnings:
                    warnings.extend(mon_warnings)
            except Exception as e:
                errors.append(f"{parsed.species}: {str(e)}")
        
        response_parts = []
        if created:
            response_parts.append(f"‚úÖ Successfully imported {len(created)} Pok√©mon:\n" + "\n".join(f"  ‚Ä¢ {name}" for name in created))
        if warnings:
            response_parts.append(f"‚ö†Ô∏è Warnings ({len(warnings)}):\n" + "\n".join(f"  ‚Ä¢ {w}" for w in warnings))
        if errors:
            response_parts.append(f"‚ùå Errors ({len(errors)}):\n" + "\n".join(f"  ‚Ä¢ {err}" for err in errors))
        
        await interaction.followup.send("\n\n".join(response_parts), ephemeral=True)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error importing team: {str(e)}", ephemeral=True)


@bot.tree.command(name="save_preset", description="Save your current team as a preset.")
@app_commands.describe(
    preset_name="Name for this preset"
)
async def save_preset(interaction: discord.Interaction, preset_name: str):
    """Save the current team as a preset."""
    await interaction.response.defer(ephemeral=False)
    
    uid = str(interaction.user.id)
    
    try:
        # Get current team ‚Äî use session for cloud DB
        async with db.session() as conn:
            cur = await conn.execute("""
                SELECT species, level, hp, atk, def, spa, spd, spe, ivs, evs, nature, ability,
                       gender, held_item, moves, form, tera_type, shiny, friendship
                FROM pokemons
                WHERE owner_id=? AND team_slot BETWEEN 1 AND 6
                ORDER BY team_slot
            """, (uid,))
            rows = await cur.fetchall()
            await cur.close()

        if not rows:
            await interaction.followup.send("‚ùå You don't have any Pok√©mon in your team to save.", ephemeral=True)
            return
        
        # Convert team to Showdown format
        team_lines = []
        for row in rows:
            r = dict(row)
            species = r["species"]
            if r.get("form"):
                species = f"{species}-{r['form']}"
            
            line = species
            if r.get("held_item"):
                line += f" @ {r['held_item']}"
            team_lines.append(line)
            
            if r.get("ability"):
                team_lines.append(f"Ability: {r['ability']}")
            
            team_lines.append(f"Level: {r['level']}")
            
            # EVs
            evs = json.loads(r["evs"]) if isinstance(r["evs"], str) else r["evs"]
            ev_parts = []
            for stat, val in evs.items():
                if val > 0:
                    stat_abbrev = {
                        "hp": "HP", "attack": "Atk", "defense": "Def",
                        "special_attack": "SpA", "special_defense": "SpD", "speed": "Spe"
                    }.get(stat, stat.title())
                    ev_parts.append(f"{val} {stat_abbrev}")
            if ev_parts:
                team_lines.append(f"EVs: {' / '.join(ev_parts)}")
            
            # Nature
            if r.get("nature"):
                team_lines.append(f"{r['nature'].title()} Nature")
            
            # IVs (only if not all 31)
            ivs = json.loads(r["ivs"]) if isinstance(r["ivs"], str) else r["ivs"]
            iv_parts = []
            for stat, val in ivs.items():
                if val != 31:
                    stat_abbrev = {
                        "hp": "HP", "attack": "Atk", "defense": "Def",
                        "special_attack": "SpA", "special_defense": "SpD", "speed": "Spe"
                    }.get(stat, stat.title())
                    iv_parts.append(f"{val} {stat_abbrev}")
            if iv_parts:
                team_lines.append(f"IVs: {' / '.join(iv_parts)}")
            
            # Moves
            moves = json.loads(r["moves"]) if isinstance(r["moves"], str) else r["moves"]
            for move in moves:
                if move:
                    team_lines.append(f"- {move}")
            
            # Friendship (custom field, not in standard Showdown format)
            if r.get("friendship") is not None:
                team_lines.append(f"Friendship: {r['friendship']}")
            
            team_lines.append("")  # Blank line between Pok√©mon
        
        team_text = "\n".join(team_lines).strip()
        
        # Save preset
        await db.save_team_preset(uid, preset_name, team_text)
        
        await interaction.followup.send(f"‚úÖ Team saved as preset '{preset_name}'!", ephemeral=True)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error saving preset: {str(e)}", ephemeral=True)


@bot.tree.command(name="load_preset", description="Load a saved team preset.")
@app_commands.describe(
    preset_name="Name of the preset to load"
)
async def load_preset(interaction: discord.Interaction, preset_name: str):
    """Load a saved team preset."""
    await interaction.response.defer(ephemeral=False)
    
    uid = str(interaction.user.id)
    
    try:
        # Get preset
        team_text = await db.get_team_preset(uid, preset_name)
        if not team_text:
            await interaction.followup.send(f"‚ùå Preset '{preset_name}' not found.", ephemeral=True)
            return
        
        # Use the same import logic as import_team
        parsed_team = parse_showdown_team(team_text)
        
        if not parsed_team:
            await interaction.followup.send("‚ùå Preset contains no valid Pok√©mon.", ephemeral=True)
            return
        
        if len(parsed_team) > 6:
            await interaction.followup.send(f"‚ùå Preset has {len(parsed_team)} Pok√©mon. Maximum is 6.", ephemeral=True)
            return

        # Clear existing team (remove all Pokemon from team slots) ‚Äî use session for cloud DB
        async with db.session() as conn:
            await conn.execute(
                "UPDATE pokemons SET team_slot = NULL WHERE owner_id=? AND team_slot BETWEEN 1 AND 6",
                (uid,)
            )
            await conn.commit()
            db.invalidate_pokemons_cache(uid)

        species_lookups = [(p, p.species.lower().replace(" ", "-"), p.species.lower()) for p in parsed_team]
        all_coros = []
        for _, n, f in species_lookups:
            all_coros.append(db.get_pokedex_by_name(n))
            all_coros.append(db.get_pokedex_by_name(f))
        species_results = await asyncio.gather(*all_coros)
        
        created = []
        errors = []
        warnings = []
        for i, (parsed, norm, fallback) in enumerate(species_lookups):
            try:
                species_entry = species_results[2 * i] or species_results[2 * i + 1]
                if not species_entry:
                    errors.append(f"{parsed.species}: not found in Pok√©dex")
                    continue
                parsed.species = species_entry.get("name", norm)
                base_stats = species_entry.get("stats") or {}
                if isinstance(base_stats, str):
                    try:
                        base_stats = json.loads(base_stats)
                    except Exception:
                        base_stats = {}
                mon_id, mon_warnings = await _create_pokemon_from_parsed(uid, parsed, species_entry, base_stats)
                slot = i + 1
                await db.set_team_slot(uid, mon_id, slot)
                created.append(f"{parsed.species} (slot {slot})")
                if mon_warnings:
                    warnings.extend(mon_warnings)
            except Exception as e:
                errors.append(f"{parsed.species}: {str(e)}")
        
        response_parts = []
        if created:
            response_parts.append(f"‚úÖ Successfully loaded preset '{preset_name}' ({len(created)} Pok√©mon):\n" + "\n".join(f"  ‚Ä¢ {name}" for name in created))
        if warnings:
            response_parts.append(f"‚ö†Ô∏è Warnings ({len(warnings)}):\n" + "\n".join(f"  ‚Ä¢ {w}" for w in warnings))
        if errors:
            response_parts.append(f"‚ùå Errors ({len(errors)}):\n" + "\n".join(f"  ‚Ä¢ {err}" for err in errors))
        
        await interaction.followup.send("\n\n".join(response_parts), ephemeral=True)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error loading preset: {str(e)}", ephemeral=True)


@bot.tree.command(name="list_presets", description="List your saved team presets.")
async def list_presets(interaction: discord.Interaction):
    """List all saved team presets."""
    await interaction.response.defer(ephemeral=False)
    
    uid = str(interaction.user.id)
    
    try:
        presets = await db.list_team_presets(uid)
        
        if not presets:
            await interaction.followup.send("‚ùå You don't have any saved presets. Use `/save_preset` to save your current team.", ephemeral=True)
            return
        
        embed = discord.Embed(title="Your Team Presets", color=0x2b2d31)
        preset_list = []
        for preset in presets:
            name = preset["preset_name"]
            created = preset.get("created_at", "Unknown")
            preset_list.append(f"‚Ä¢ **{name}** (saved {created})")
        
        embed.description = "\n".join(preset_list)
        embed.set_footer(text=f"Total: {len(presets)} preset(s)")
        
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error listing presets: {str(e)}", ephemeral=True)


@bot.tree.command(name="delete_preset", description="Delete a saved team preset.")
@app_commands.describe(
    preset_name="Name of the preset to delete"
)
async def delete_preset(interaction: discord.Interaction, preset_name: str):
    """Delete a saved team preset."""
    await interaction.response.defer(ephemeral=False)
    
    uid = str(interaction.user.id)
    
    try:
        deleted = await db.delete_team_preset(uid, preset_name)
        
        if deleted:
            await interaction.followup.send(f"‚úÖ Preset '{preset_name}' deleted.", ephemeral=True)
        else:
            await interaction.followup.send(f"‚ùå Preset '{preset_name}' not found.", ephemeral=True)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error deleting preset: {str(e)}", ephemeral=True)


@bot.tree.command(name="preset_team", description="Import a preset team.")
@app_commands.describe(
    preset_name="The name of the preset team to import (gen1_ou, gen2_ou, gen3_ou)"
)
async def preset_team(interaction: discord.Interaction, preset_name: str):
    """Import a preset team (legacy global presets)."""
    await interaction.response.defer(ephemeral=False)
    
    uid = str(interaction.user.id)
    
    try:
        # First check if it's a user preset
        user_preset = await db.get_team_preset(uid, preset_name)
        if user_preset:
            # Load user preset
            parsed_team = parse_showdown_team(user_preset)
        else:
            # Try global preset
            preset = get_preset_team(preset_name)
            if not preset:
                await interaction.followup.send(f"‚ùå Preset team '{preset_name}' not found. Use `/list_presets` to see your saved presets.", ephemeral=True)
                return
            
            # Convert global preset to Showdown format for parsing
            preset_lines = []
            for pokemon_data in preset:
                preset_lines.append(f"{pokemon_data['species']} @ {pokemon_data.get('item', '')}" if pokemon_data.get('item') else pokemon_data['species'])
                if pokemon_data.get('ability'):
                    preset_lines.append(f"Ability: {pokemon_data['ability']}")
                preset_lines.append(f"Level: {pokemon_data.get('level', 100)}")
                evs = pokemon_data.get('evs', {})
                ev_parts = [f"{v} {k.title()}" for k, v in evs.items() if v > 0]
                if ev_parts:
                    preset_lines.append(f"EVs: {' / '.join(ev_parts)}")
                if pokemon_data.get('nature'):
                    preset_lines.append(f"{pokemon_data['nature'].title()} Nature")
                for move in pokemon_data.get('moves', []):
                    preset_lines.append(f"- {move}")
                preset_lines.append("")
            
            preset_text = "\n".join(preset_lines).strip()
            parsed_team = parse_showdown_team(preset_text)
        
        if not parsed_team:
            await interaction.followup.send("‚ùå Preset contains no valid Pok√©mon.", ephemeral=True)
            return
        
        if len(parsed_team) > 6:
            await interaction.followup.send(f"‚ùå Preset team has {len(parsed_team)} Pok√©mon. Maximum is 6.", ephemeral=True)
            return
        
        # Check available team slots
        conn = await db.connect()
        try:
            cur = await conn.execute(
                "SELECT COUNT(*) as count FROM pokemons WHERE owner_id=? AND team_slot BETWEEN 1 AND 6",
                (uid,)
            )
            row = await cur.fetchone()
            await cur.close()
            current_team_size = row["count"] if row else 0
        finally:
            try:
                await conn.close()
            except Exception:
                pass

        available_slots = 6 - current_team_size

        if len(parsed_team) > available_slots:
            await interaction.followup.send(
                f"‚ùå Not enough team slots available. You have {available_slots} free slot(s), but the preset team has {len(parsed_team)} Pok√©mon.",
                ephemeral=True
            )
            return
        
        # Process each Pok√©mon
        created = []
        errors = []
        warnings = []
        
        for i, parsed in enumerate(parsed_team):
            try:
                # Get species data from local database only (no PokeAPI)
                # Normalize species name: convert spaces to hyphens for database lookup
                # (e.g., "Tapu Bulu" -> "tapu-bulu")
                species_name_normalized = parsed.species.lower().replace(" ", "-")
                species_entry = await db.get_pokedex_by_name(species_name_normalized)
                
                # If not found, also try the original lowercase version (for backwards compatibility)
                if not species_entry:
                    species_entry = await db.get_pokedex_by_name(parsed.species.lower())
                
                if not species_entry:
                    errors.append(f"{parsed.species}: not found in Pok√©dex")
                    continue
                
                # Update parsed.species to use the normalized name from database
                parsed.species = species_entry.get("name", species_name_normalized)
                
                # Get base stats
                base_stats = species_entry.get("stats") or {}
                if isinstance(base_stats, str):
                    try:
                        base_stats = json.loads(base_stats)
                    except Exception:
                        base_stats = {}
                
                # Create the Pok√©mon
                mon_id, mon_warnings = await _create_pokemon_from_parsed(uid, parsed, species_entry, base_stats)
                
                # Add to team (find next free slot)
                slot = await db.next_free_team_slot(uid)
                if slot:
                    await db.set_team_slot(uid, mon_id, slot)
                    created.append(f"{parsed.species} (slot {slot})")
                else:
                    errors.append(f"{parsed.species} (no team slot available)")
                
                # Collect any warnings
                if mon_warnings:
                    warnings.extend(mon_warnings)
                    
            except Exception as e:
                errors.append(f"{parsed.species}: {str(e)}")
        
        # Build response
        response_parts = []
        if created:
            response_parts.append(f"‚úÖ Successfully imported preset team '{preset_name}' ({len(created)} Pok√©mon):\n" + "\n".join(f"  ‚Ä¢ {name}" for name in created))
        if warnings:
            response_parts.append(f"‚ö†Ô∏è Warnings ({len(warnings)}):\n" + "\n".join(f"  ‚Ä¢ {w}" for w in warnings))
        if errors:
            response_parts.append(f"‚ùå Errors ({len(errors)}):\n" + "\n".join(f"  ‚Ä¢ {err}" for err in errors))
        
        await interaction.followup.send("\n\n".join(response_parts), ephemeral=True)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error importing preset team: {str(e)}", ephemeral=True)


## BAG
# --- Bag view and item helpers ---
import discord
from discord import ui, Interaction, Embed, SelectOption
from discord.ext import commands
from discord import app_commands


class BagView(ui.View):
    def __init__(self, owner_id: int, page: int, max_pages: int):
        super().__init__(timeout=120)
        self.owner_id = owner_id
        self.page = page
        self.max_pages = max_pages

        # Buttons
        self.prev_btn = ui.Button(label="Prev", style=discord.ButtonStyle.secondary, disabled=(page <= 1))
        self.next_btn = ui.Button(label="Next", style=discord.ButtonStyle.secondary, disabled=(page >= max_pages))
        self.add_item(self.prev_btn)
        self.add_item(self.next_btn)

        # Jump select
        options = [SelectOption(label=f"Page {i}", value=str(i), default=(i == page))
                   for i in range(1, max_pages + 1)]
        self.page_select = ui.Select(placeholder="Jump to‚Ä¶", options=options, min_values=1, max_values=1)
        self.add_item(self.page_select)

        # Bind callbacks
        self.prev_btn.callback = self.on_prev
        self.next_btn.callback = self.on_next
        self.page_select.callback = self.on_jump

    async def _refresh(self, interaction: Interaction, new_page: int):
        # Shared connection (WAL + busy_timeout) to reduce connection churn under load
        conn = await db.connect()
        try:
            items, max_pages, total_distinct = await db.get_inventory_page(conn, self.owner_id, new_page)

            self.page = new_page
            self.max_pages = max_pages

            # Update controls
            self.prev_btn.disabled = (self.page <= 1)
            self.next_btn.disabled = (self.page >= self.max_pages)
            self.page_select.options = [
                SelectOption(label=f"Page {i}", value=str(i), default=(i == self.page))
                for i in range(1, self.max_pages + 1)
            ]

            embed, files = build_bag_embed(self.owner_id, items, self.page, self.max_pages, total_distinct)
            try:
                await interaction.response.edit_message(embed=embed, view=self, attachments=files)
            finally:
                _close_discord_files(files)
        finally:
            try:
                await conn.close()
            except Exception:
                pass

    async def on_prev(self, interaction: Interaction):
        if interaction.user.id != self.owner_id:
            return await interaction.response.send_message("This isn‚Äôt your bag.", ephemeral=True)
        await self._refresh(interaction, max(1, self.page - 1))

    async def on_next(self, interaction: Interaction):
        if interaction.user.id != self.owner_id:
            return await interaction.response.send_message("This isn‚Äôt your bag.", ephemeral=True)
        await self._refresh(interaction, min(self.max_pages, self.page + 1))

    async def on_jump(self, interaction: Interaction):
        if interaction.user.id != self.owner_id:
            return await interaction.response.send_message("This isn‚Äôt your bag.", ephemeral=True)
        choice = int(self.page_select.values[0])
        await self._refresh(interaction, choice)

def format_item_line(row: dict) -> str:
    qty = row["qty"]
    name = pretty_item_name(row.get("name") or row["item_id"])

    if row.get("emoji"):  # already contains <:name:id>
        return f"{row['emoji']} **{name}** √ó{qty}"

    return f"**{name}** √ó{qty}"

def build_bag_embed(owner_id: int, items: list[dict], page: int, max_pages: int, total_distinct: int):
    e = discord.Embed(title=f"Bag ‚Äî Page {page}/{max_pages}", color=0x2b2d31)

    if not items:
        e.description = "_This page is empty._"
    else:
        lines = [format_item_line(it) for it in items]
        e.description = "\n".join(lines)

    e.set_footer(text=f"Distinct items: {total_distinct} ‚Ä¢ Pages owned: {max_pages}")

    # üëá Use the same item icon logic for the bag
    att_url, att_file = item_icon_file("bag")
    files = []
    if att_file:
        e.set_thumbnail(url=att_url)
        files.append(att_file)

    return e, files


async def _build_bag_embed_for_battle(owner_id: int | str, page: int = 1):
    """Build the same bag embed as /bag for in-battle use. Returns (embed, files)."""
    async with db.session() as conn:
        items, max_pages, total_distinct = await db.get_inventory_page(conn, str(owner_id), page)
    page = max(1, min(page, max_pages))
    return build_bag_embed(int(owner_id) if isinstance(owner_id, str) else owner_id, items, page, max_pages, total_distinct)




class BagCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    async def _decorate_items_with_usage(self, owner_id: int | str, items: list) -> list:
        """
        Mutates rows so that row['qty'] becomes 'free/total' (string) for display.
        'free' = total - how many are currently held by your Pok√©mon.
        Runs _count_item_in_use in parallel for all items.
        """
        uid = str(owner_id)
        merged_by_item: dict[str, dict[str, Any]] = {}
        order_idx = 0
        rows_data = []
        for r in items:
            asdict = dict(r) if hasattr(r, "keys") else {
                "id": r[0] if len(r) > 0 else None,
                "name": r[1] if len(r) > 1 else None,
                "qty": r[2] if len(r) > 2 else 0,
            }
            raw_item_id = (asdict.get("id") or asdict.get("item_id") or asdict.get("name") or "").strip()
            item_id = _canonical_item_token(raw_item_id) or raw_item_id
            total = int((asdict.get("qty") or 0) or 0)
            bucket = merged_by_item.get(item_id)
            if bucket is None:
                row_copy = dict(asdict)
                row_copy["id"] = item_id
                row_copy["item_id"] = item_id
                row_copy["_order"] = order_idx
                order_idx += 1
                merged_by_item[item_id] = row_copy
                bucket = row_copy
            bucket["qty"] = int(bucket.get("qty") or 0) + total

        merged_rows = sorted(
            merged_by_item.values(),
            key=lambda d: (int(d.get("_order", 0)), str(d.get("name") or d.get("item_id") or "")),
        )
        for asdict in merged_rows:
            item_id = str(asdict.get("item_id") or asdict.get("id") or "").strip()
            total = int((asdict.get("qty") or 0) or 0)
            rows_data.append((asdict, item_id, total))
        async def _zero():
            return 0
        coros = [_count_item_in_use(uid, iid) if iid else _zero() for _, iid, _ in rows_data]
        used_list = await asyncio.gather(*coros)
        out = []
        for (asdict, _, total), used in zip(rows_data, used_list):
            used = int(used) if isinstance(used, (int, float)) else 0
            free = max(0, total - used)
            asdict["qty"] = f"{free}/{total}"
            asdict.pop("_order", None)
            out.append(asdict)
        return out

    @app_commands.command(name="bag", description="View your items (6 pages by default).")
    async def bag(self, interaction: Interaction, page: int = 1):
        await interaction.response.defer(ephemeral=False)
        owner_id = interaction.user.id
        conn = await db.connect()
        try:
            items, max_pages, total_distinct = await db.get_inventory_page(conn, owner_id, page)

            # keep page within bounds
            page = max(1, min(page, max_pages))
            view = BagView(owner_id, page=page, max_pages=max_pages)

            # ---- NEW: decorate items so qty shows "free/total" ----
            items = await self._decorate_items_with_usage(owner_id, items)

            embed, files = build_bag_embed(owner_id, items, view.page, view.max_pages, total_distinct)
            try:
                await interaction.followup.send(embed=embed, view=view, files=files, ephemeral=True)
            finally:
                _close_discord_files(files)
        finally:
            try:
                await conn.close()
            except Exception:
                pass
# =========================
#  equipment
# =========================
GEAR_SLOTS = ("mega", "z", "dmax", "tera")
_equipment_ensured = False

def _gear_slot_for_item_id(s: str | None) -> str | None:
    if not s:
        return None
    t = str(s).strip().lower().replace(" ", "_").replace("-", "_")
    if t.endswith("ite") or "mega_bracelet" in t or "mega_ring" in t or "key_stone" in t:
        return "mega"
    if t.endswith("_z") or "z_ring" in t or "z_power_ring" in t:
        return "z"
    if "dynamax" in t or "max_band" in t or t.startswith("max_"):
        return "dmax"
    if "tera_orb" in t or "terastal_orb" in t:
        return "tera"
    return None

async def _ensure_equipment_table(*, _skip_if_done: bool = True):
    global _equipment_ensured
    if _skip_if_done and _equipment_ensured:
        return
    conn = await db.connect()
    try:
        await conn.execute("""
            CREATE TABLE IF NOT EXISTS user_equipment (
                owner_id      TEXT PRIMARY KEY,
                mega_gear     TEXT,
                z_gear        TEXT,
                dmax_gear     TEXT,
                tera_gear     TEXT,
                mega_unlocked INTEGER NOT NULL DEFAULT 0
            )
        """)
        # idempotent migration: add mega_unlocked if older table exists
        if getattr(db, "DB_IS_POSTGRES", False):
            cur = await conn.execute(
                "SELECT column_name FROM information_schema.columns WHERE table_schema='public' AND table_name=?",
                ("user_equipment",),
            )
            cols = {r[0] for r in await cur.fetchall()}
            await cur.close()
        else:
            cur = await conn.execute("PRAGMA table_info(user_equipment)")
            cols = {r[1] for r in await cur.fetchall()}
            await cur.close()
        if "mega_unlocked" not in cols:
            await conn.execute("ALTER TABLE user_equipment ADD COLUMN mega_unlocked INTEGER NOT NULL DEFAULT 0")
        await conn.commit()
        _equipment_ensured = True
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _set_gear(owner_id: str, slot: str, item_id: str | None, *, skip_ensure: bool = False):
    if not skip_ensure:
        await _ensure_equipment_table()
    conn = await db.connect()
    try:
        await conn.execute("INSERT OR IGNORE INTO user_equipment (owner_id) VALUES (?)", (owner_id,))
        col = f"{slot}_gear"
        await conn.execute(f"UPDATE user_equipment SET {col}=? WHERE owner_id=?", (item_id, owner_id))
        await conn.commit()
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _set_mega_unlocked(owner_id: str, unlocked: bool, *, skip_ensure: bool = False):
    if not skip_ensure:
        await _ensure_equipment_table()
    conn = await db.connect()
    try:
        await conn.execute("UPDATE user_equipment SET mega_unlocked=? WHERE owner_id=?", (1 if unlocked else 0, owner_id))
        await conn.commit()
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _get_all_gear(owner_id: str, *, skip_ensure: bool = False) -> dict:
    if not skip_ensure:
        await _ensure_equipment_table()
    conn = await db.connect()
    try:
        cur = await conn.execute("""
            SELECT mega_gear, z_gear, dmax_gear, tera_gear, mega_unlocked
            FROM user_equipment
            WHERE owner_id=?
        """, (owner_id,))
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return {"mega": None, "z": None, "dmax": None, "tera": None, "mega_unlocked": 0}
        asdict = dict(row) if hasattr(row, "keys") else {
            "mega_gear": row[0], "z_gear": row[1], "dmax_gear": row[2], "tera_gear": row[3], "mega_unlocked": row[4]
        }
        return {
            "mega": asdict.get("mega_gear"),
            "z": asdict.get("z_gear"),
            "dmax": asdict.get("dmax_gear"),
            "tera": asdict.get("tera_gear"),
            "mega_unlocked": int(asdict.get("mega_unlocked") or 0),
        }
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _item_emoji_and_name(q: str | None) -> tuple[str, str]:
    if not q:
        return "", "‚Äî"
    conn = await db.connect()
    try:
        row = await _fetch_item_by_query(conn, q)
        if row:
            emoji_raw = (row.get("emoji") or "").strip()
            emoji = emoji_raw if _is_displayable_item_emoji(emoji_raw) else ""
            name = pretty_item_name(row.get("name") or row.get("id") or q)
            return emoji, name
        return "", pretty_item_name(q)
    finally:
        try:
            await conn.close()
        except Exception:
            pass

def _slot_human(slot: str) -> str:
    return {
        "mega": "Mega Bracelet / Key Stone",
        "z": "Z-Ring",
        "dmax": "Dynamax Band",
        "tera": "Tera Orb",
    }.get(slot, slot)

def _slot_active_for_gen(slot: str, gen: int, gear: dict) -> bool:
    """
    Mega is special per your rule:
      - requires: mega_unlocked == 1  AND  gen <= 7
      - once unlocked (you got the bracelet in Gen6), it's usable back in Gen1‚Äì7
      - never usable in Gen8+
    Other gimmicks: strict single-gen
    """
    if slot == "mega":
        return gear.get("mega") and gear.get("mega_unlocked", 0) == 1 and _rules.mega_allowed_in_gen(gen)
    if slot == "z":
        return gear.get("z") and gen == 7
    if slot == "dmax":
        return gear.get("dmax") and gen == 8
    if slot == "tera":
        return gear.get("tera") and gen == 9
    return False

async def _user_has_item(owner_id: str, item_id: str) -> int:
    """
    Return the quantity of item_id in the user's bag.
    Used to require owning gear before equipping it.
    """
    conn = await db.connect()
    try:
        cur = await conn.execute(
            "SELECT qty FROM user_items WHERE owner_id=? AND item_id=?",
            (owner_id, item_id),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return 0
        # support either Row or tuple
        qty = row["qty"] if hasattr(row, "keys") else row[0]
        try:
            return int(qty or 0)
        except Exception:
            return 0
    finally:
        try:
            await conn.close()
        except Exception:
            pass

@bot.tree.command(
    name="equipgear",
    description="Equip trainer gear (Mega/Z/Dyna/Tera). Wrong-gen inactive; Mega unlocks in Gen6."
)
@app_commands.describe(item="Item id or name (e.g., mega bracelet, z-ring, dynamax band, tera orb)")
async def equipgear(interaction: discord.Interaction, item: str):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    await _ensure_equipment_table()

    # Resolve to a known item in DB (must be in your bag)
    conn = await db.connect()
    try:
        row = await _fetch_item_by_query(conn, item)
        if not row:
            return await interaction.followup.send(
            "‚ùå I don‚Äôt recognize that item. Import it first or use its exact id/name.",
            ephemeral=True
        )
        item_id = (row.get("id") or "").strip()
        if not item_id:
            return await interaction.followup.send("‚ùå Invalid item.", ephemeral=True)

        # Require ownership in bag
        qty = await _user_has_item(uid, item_id)
        if qty <= 0:
            emoji = row.get("emoji") or ""
            disp  = pretty_item_name(row.get("name") or row.get("id") or item)
            return await interaction.followup.send(
                f"‚ùå You don‚Äôt have {(emoji + ' ') if emoji else ''}**{disp}** in your bag.",
                ephemeral=True
            )

        # Determine gear slot
        slot = _gear_slot_for_item_id(item_id)
        if not slot:
            return await interaction.followup.send(
                "‚ùå That item isn‚Äôt valid trainer gear (Mega/Z/Dynamax/Tera).",
                ephemeral=True
            )

        # If already equipped with the same item, don't consume again
        current = await _get_all_gear(uid, skip_ensure=True)
        already_equipped_same = (str(current.get(slot) or "").lower() == item_id.lower())
        if already_equipped_same:
                emoji_raw = (row.get("emoji") or "").strip()
                emoji = emoji_raw if _is_displayable_item_emoji(emoji_raw) else ""
                disp  = pretty_item_name(row.get("name") or row.get("id") or item_id)
                user_gen = await _user_selected_gen(uid)
                emb = discord.Embed(
                    title=f"Trainer Gear for {interaction.user.display_name} (Gen {user_gen})",
                    description=f"‚ÑπÔ∏è You already have {(emoji + ' ') if emoji else ''}**{disp}** equipped. Nothing consumed.",
                    color=0x2b2d31
                )
                slot_values = [current.get(sl) for sl in GEAR_SLOTS]
                ei = await asyncio.gather(*[_item_emoji_and_name(q) for q in slot_values])
                for sl, (e, d) in zip(GEAR_SLOTS, ei):
                    active = _slot_active_for_gen(sl, user_gen, current)
                    status = "ACTIVE ‚úÖ" if active else ("inactive ‚ö™" if current.get(sl) else "empty ‚Äî")
                    emb.add_field(name=_slot_human(sl), value=f"{(e + ' ') if e else ''}{d} ¬∑ {status}", inline=False)
                return await interaction.followup.send(embed=emb, ephemeral=True)

        # Consume 1x from bag
        ok = await _decrement_user_item(uid, item_id, 1)
        if not ok:
            return await interaction.followup.send("‚ùå You no longer have one to equip.", ephemeral=True)

        # Save gear selection (ensure already done above)
        await _set_gear(uid, slot, item_id, skip_ensure=True)

        # Auto-unlock Megas if equipping bracelet/ring/keystone while in Gen ‚â• 6
        user_gen = await _user_selected_gen(uid)
        if slot == "mega" and user_gen >= 6:
            await _set_mega_unlocked(uid, True, skip_ensure=True)

        # Build status embed
        gear = await _get_all_gear(uid, skip_ensure=True)
        emoji_raw = (row.get("emoji") or "").strip()
        emoji = emoji_raw if _is_displayable_item_emoji(emoji_raw) else ""
        disp  = pretty_item_name(row.get("name") or row.get("id") or item_id)
        emb = discord.Embed(
            title=f"Trainer Gear for {interaction.user.display_name} (Gen {user_gen})",
            description=f"Consumed **1√ó** {(emoji + ' ') if emoji else ''}**{disp}** from your bag.\n"
                        "Wrong-gen gear stays equipped but inactive. Mega unlocks in Gen6; then usable in Gen1‚Äì7.",
            color=0x2b2d31
        )
        slot_values = [gear.get(sl) for sl in GEAR_SLOTS]
        ei = await asyncio.gather(*[_item_emoji_and_name(q) for q in slot_values])
        for sl, (e, d) in zip(GEAR_SLOTS, ei):
            active = _slot_active_for_gen(sl, user_gen, gear)
            status = "ACTIVE ‚úÖ" if active else ("inactive ‚ö™" if gear.get(sl) else "empty ‚Äî")
            emb.add_field(name=_slot_human(sl), value=f"{(e + ' ') if e else ''}{d} ¬∑ {status}", inline=False)

        await interaction.followup.send(embed=emb, ephemeral=True)
    finally:
        try:
            await conn.close()
        except Exception:
            pass
@bot.tree.command(
    name="mygear",
    description="Show your trainer gear and whether it‚Äôs active this gen."
)
async def mygear(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    await _ensure_equipment_table()
    user_gen = await _user_selected_gen(uid)
    gear = await _get_all_gear(uid, skip_ensure=True)

    emb = discord.Embed(
        title=f"Trainer Gear for {interaction.user.display_name} (Gen {user_gen})",
        color=0x2b2d31
    )
    emb.set_footer(text="Mega unlocks in Gen6; usable in Gen1‚Äì7. Z=Gen7, Dyna=Gen8, Tera=Gen9.")
    slot_values = [gear.get(sl) for sl in GEAR_SLOTS]
    ei = await asyncio.gather(*[_item_emoji_and_name(q) for q in slot_values])
    for sl, (emoji, disp) in zip(GEAR_SLOTS, ei):
        active = _slot_active_for_gen(sl, user_gen, gear)
        gid = gear.get(sl)
        status = "ACTIVE ‚úÖ" if active else ("inactive ‚ö™" if gid else "empty ‚Äî")
        emb.add_field(
            name=_slot_human(sl),
            value=f"{(emoji + ' ') if emoji else ''}{disp} ¬∑ {status}",
            inline=False
        )
    await interaction.followup.send(embed=emb, ephemeral=True)
# =========================
#  fetching emojis
# =========================
EMOJI_CODE_RE = re.compile(r"<a?:([A-Za-z0-9_]+):(\d+)>")

def _norm(s: str) -> str:
    """Normalize names to compare emoji names to item ids/names."""
    return (
        str(s or "")
        .lower()
        .replace("√©", "e")
        .replace("&", "and")
        .replace("‚Äô", "'")
        .replace("'", "")
        .replace("‚Äô", "")
        .replace(".", "")
        .replace(" ", "-")
        .replace("_", "-")
    )

async def _open_db():
    # Reuse the shared WAL connection for consistency and fewer FDs
    return await db.connect()


class EmojiLinkCog(commands.Cog):
    """Tools to link your server's custom emojis to items (DB: items.emoji)."""

    EMOJI_CODE_RE = re.compile(r"<a?:([A-Za-z0-9_]+):(\d+)>")

    # ---------- helpers ----------
    @staticmethod
    def _norm(s: str) -> str:
        return (
            str(s or "")
            .lower()
            .replace("√©", "e")
            .replace("&", "and")
            .replace("‚Äô", "")
            .replace("'", "")
            .replace(".", "")
            .replace(" ", "-")
            .replace("_", "-")
        )

    @staticmethod
    async def _open_db():
        return await db.connect()

    async def _resolve_item_fuzzy_local(self, conn, query: str):
        """
        Fallback fuzzy resolver if your project doesn't expose _resolve_item_fuzzy.
        Returns (row_dict, autocorrect_to, suggestions)
        """
        q = self._norm(query)
        like = f"%{q.replace('-', '%')}%"
        # pull a small candidate set
        sql = """
        SELECT id, name FROM items
        WHERE LOWER(id) LIKE ? OR LOWER(name) LIKE ?
        LIMIT 50
        """
        cur = await conn.execute(sql, (like, like))
        rows = await cur.fetchall()
        await cur.close()

        if not rows:
            return None, None, []

        # simple score: exact id, exact name, startswith, contains
        def score(r):
            rid = self._norm(r["id"])
            rnm = self._norm(r["name"] or "")
            if rid == q or rnm == q: return (0, len(rid))
            if rid.startswith(q) or rnm.startswith(q): return (1, len(rid))
            if q in rid or q in rnm: return (2, len(rid))
            # distant match
            return (3, len(rid))

        rows.sort(key=score)
        best = rows[0]
        # suggestions (pretty)
        sugg = []
        for r in rows[:10]:
            nm = r["name"] or r["id"]
            sugg.append(nm)
        # fetch full row
        cur = await conn.execute("SELECT * FROM items WHERE id = ?", (best["id"],))
        full = await cur.fetchone()
        await cur.close()
        return (dict(full) if full else None,
                (best["name"] or best["id"]),
                sugg[1:])

    async def _resolve_item_any(self, conn, query: str):
        """
        Use your project's _resolve_item_fuzzy(conn, query) if available,
        otherwise fallback to the local resolver above.
        """
        try:
            # if your project defines this helper at module level, use it
            row, autocorrect_to, suggestions = await _resolve_item_fuzzy(conn, query)  # type: ignore
            return row, autocorrect_to, suggestions
        except Exception:
            return await self._resolve_item_fuzzy_local(conn, query)
    # ---------- end helpers ----------

    def __init__(self, bot: commands.Bot):
        self.bot = bot

    # ========== /emoji_autolink ==========
    @app_commands.command(
        name="emoji_autolink",
        description="Auto-link server custom emojis to items by name/id."
    )
    @app_commands.describe(
        dry_run="If true, only show what would change (no DB writes)."
    )
    async def emoji_autolink(self, interaction: discord.Interaction, dry_run: bool = True):
        if not interaction.guild:
            return await interaction.response.send_message("Run this in a server.", ephemeral=True)

        await interaction.response.defer(ephemeral=True, thinking=True)

        # normalized emoji name -> full code
        emoji_map = {self._norm(e.name): f"<:{e.name}:{e.id}>" for e in interaction.guild.emojis}

        matched = already = 0
        missing = []
        to_update = []

        conn = await self._open_db()
        try:
            cur = await conn.execute("SELECT id, name, COALESCE(emoji,'') AS emoji FROM items")
            rows = await cur.fetchall()
            await cur.close()

            for r in rows:
                item_id = r["id"]
                item_name = r["name"]
                current = (r["emoji"] or "").strip()

                if current:
                    already += 1
                    continue

                keys = [
                    self._norm(item_id),
                    self._norm(item_name),
                    self._norm(item_name).replace("-", ""),
                ]
                found = next((emoji_map[k] for k in keys if k in emoji_map), None)

                if found:
                    to_update.append((found, item_id))
                    matched += 1
                else:
                    missing.append(item_name or item_id)

            if not dry_run and to_update:
                await conn.executemany("UPDATE items SET emoji = ? WHERE id = ?", to_update)
                await conn.commit()
        finally:
            await conn.close()

        lines = [
            f"Matched: **{matched}**",
            f"Already had emoji: **{already}**",
            f"Unmatched: **{len(missing)}**",
            "(dry run ‚Äî no changes saved)" if dry_run else "(saved to DB)",
        ]
        if missing:
            lines.append("Examples not found: " + ", ".join(missing[:12]))
        await interaction.followup.send("\n".join(lines), ephemeral=True)

    # ========== /set_item_emoji (FUZZY) ==========
    @app_commands.command(
        name="set_item_emoji",
        description="Set or override the custom emoji for an item (fuzzy item search)."
    )
    @app_commands.describe(
        item="Item id or name (e.g. 'poke ball', 'choice scarf')",
        emoji="Paste <:name:id> or type :name: (I'll resolve it)"
    )
    async def set_item_emoji(self, interaction: discord.Interaction, item: str, emoji: str):
        if not interaction.guild:
            return await interaction.response.send_message("Run this in a server.", ephemeral=True)

        await interaction.response.defer(ephemeral=False)

        # resolve item fuzzily
        conn = await self._open_db()
        try:
            row, autocorrect_to, suggestions = await self._resolve_item_any(conn, item)
        finally:
            await conn.close()

        if not row:
            if suggestions:
                return await interaction.followup.send(
                    "‚ùå Item not found. Did you mean: " + ", ".join(suggestions) + " ?",
                    ephemeral=True
                )
            return await interaction.followup.send("‚ùå Item not found.", ephemeral=True)

        item_id = row["id"]
        pretty_name = row.get("name") or item_id

        # normalize emoji input to <:name:id>
        code = emoji.strip()
        if code.startswith(":") and code.endswith(":"):
            short = code.strip(":")
            em = discord.utils.get(interaction.guild.emojis, name=short)
            if not em:
                return await interaction.followup.send(
                    f"Emoji `:{short}:` not found in this server.",
                    ephemeral=True
                )
            code = f"<:{em.name}:{em.id}>"

        if not self.EMOJI_CODE_RE.fullmatch(code):
            return await interaction.followup.send(
                "Please paste a custom emoji like `<:name:id>` or `:name:`.",
                ephemeral=True
            )

        conn = await self._open_db()
        try:
            await conn.execute("UPDATE items SET emoji = ? WHERE id = ?", (code, item_id))
            await conn.commit()
        finally:
            await conn.close()

        suffix = f" (autocorrected to {autocorrect_to})" if autocorrect_to else ""
        await interaction.followup.send(
            f"‚úÖ Set emoji for **{pretty_name}** ‚Üí {code}{suffix}",
            ephemeral=True
        )

    # ---------- autocomplete for 'item' ----------
    @set_item_emoji.autocomplete("item")
    async def set_item_emoji_autocomplete(
        self,
        interaction: discord.Interaction,
        current: str
    ) -> list[app_commands.Choice[str]]:
        q = (current or "").strip().lower()
        like = f"%{q}%"
        sql = """
        SELECT id, name FROM items
        WHERE LOWER(id) LIKE ? OR LOWER(name) LIKE ?
        ORDER BY
            CASE WHEN LOWER(id) = ? OR LOWER(name) = ? THEN 0
                 WHEN LOWER(id) LIKE ? OR LOWER(name) LIKE ? THEN 1
                 ELSE 2
            END,
            id
        LIMIT 25
        """
        choices: list[app_commands.Choice[str]] = []
        conn = await self._open_db()
        try:
            cur = await conn.execute(sql, (like, like, q, q, like, like))
            rows = await cur.fetchall()
            await cur.close()
        finally:
            await conn.close()

        for r in rows:
            _id = r["id"]
            _name = r["name"]
            label = f"{_name} ({_id})" if _name and _name.lower() != _id else _id
            choices.append(app_commands.Choice(name=label, value=_id))
        return choices
async def setup(bot: commands.Bot):
    await bot.add_cog(EmojiLinkCog(bot))
# =========================
#  import pokemons and rules
# =========================

@bot.tree.command(name="dexcache", description="Cache a Pok√©mon from PokeAPI into SQLite")
@app_commands.describe(name_or_id="e.g., bulbasaur or 1")
async def dexcache(interaction: discord.Interaction, name_or_id: str):
    await interaction.response.defer(ephemeral=True, thinking=True)

    key = name_or_id.strip().lower()
    existing = await (db.get_pokedex_by_id(int(key)) if key.isdigit()
                      else db.get_pokedex_by_name(key))

    if existing:
        return await interaction.followup.send(
            f"‚úÖ Pok√©mon already registered: **#{existing['id']} {existing['name'].title()}**.",
            ephemeral=True
        )

    entry = await ensure_species_and_learnsets(key)
    await interaction.followup.send(
        f"üì• Cached **#{entry['id']} {entry['name'].title()}** (Gen {entry['introduced_in']}).",
        ephemeral=True
    )

@bot.tree.command(name="legalmoves", description="List legal moves for a species at a generation")
async def legalmoves_cmd(interaction: discord.Interaction, species_id: int, gen: int):
    await interaction.response.defer(thinking=True, ephemeral=True)
    rows = await legal_moves(species_id, gen)
    txt = "\n".join(f"- {r['name']} [{r['method']}] lv{r['level_learned'] or '-'}" for r in rows[:40]) or "No moves."
    await interaction.followup.send(txt, ephemeral=True)
def _j(v, default):
    if isinstance(v, str):
        try:
            return json.loads(v)
        except Exception:
            return default
    return v if v is not None else default

def _r(row, key, default=None):
    """Safe getter for row-like (dict or Record)."""
    try:
        v = row[key]
        return default if v is None else v
    except Exception:
        return default

# helper so abilities can be dicts or strings, and to detect hidden ability
def _split_abilities(abilities_list):
    """
    Returns (regular_abilities, hidden_abilities) as lists of names.
    Accepts:
      - ["overgrow","chlorophyll"]
      - [{"name":"overgrow"},{"ability":{"name":"chlorophyll"},"is_hidden":true}]
      - [{"ability":{"name":"overgrow"},"slot":1}, {"ability":{"name":"chlorophyll"},"slot":3}]
    """
    regs, hides = [], []
    for a in abilities_list or []:
        if isinstance(a, str):
            regs.append(a)
            continue
        if isinstance(a, dict):
            name = a.get("name") or (a.get("ability") or {}).get("name") or ""
            is_hidden = bool(a.get("is_hidden") or a.get("hidden") or (a.get("slot") == 3))
            if name:
                (hides if is_hidden else regs).append(name)
    return regs, hides

_FORM_ALIASES = {
    "alola": "alola", "alolan": "alola",
    "galar": "galar", "galarian": "galar",
    "hisui": "hisui", "hisuian": "hisui",
    "paldea": "paldea", "paldean": "paldea",
}

def _norm_token(s: str) -> str:
    return re.sub(r"[^a-z0-9-]+", "-", (s or "").strip().lower()).strip("-")

def normalize_form_key(form_key: Optional[str]) -> Optional[str]:
    if not form_key:
        return None
    key = _norm_token(form_key)
    parts = [p for p in key.split("-") if p]
    if not parts:
        return None
    parts[0] = _FORM_ALIASES.get(parts[0], parts[0])  # alolan -> alola, etc.
    return "-".join(parts)

def parse_form_from_name(input_name: str) -> Tuple[str, Optional[str]]:
    """
    Flexible parser:
      'alolan raichu' -> ('raichu','alola')
      'raichu alola' -> ('raichu','alola')
      'tauros paldea aqua breed' -> ('tauros','paldea-aqua-breed')
    """
    txt = _norm_token(input_name)
    toks = txt.split("-")
    idx = next((i for i,t in enumerate(toks) if t in _FORM_ALIASES), None)
    if idx is None:
        return input_name.strip(), None
    head = toks[idx]
    tail = "-".join(toks[idx+1:]) if (idx+1) < len(toks) else ""
    fkey = normalize_form_key(f"{head}-{tail}".strip("-"))
    species_tokens = toks[:idx] or toks[idx+1:]
    species = " ".join(species_tokens).replace("-", " ").strip() or input_name
    return species, fkey

# ---------- FUZZY name -> species row (uses your _fuzzy_best) ----------
async def fuzzy_species_row(con, name: str):
    """
    Try exact by name; if not found, use your _fuzzy_best() to find the closest species.
    Returns (row, suggestions_or_empty_list) where row may be None.
    """
    q = (name or "").strip().lower()
    row = await _safe_optional_fetchone(
        con,
        "SELECT * FROM pokedex WHERE LOWER(name)=?",
        (q,),
        tables=("pokedex",),
    )
    if row:
        return row, []

    all_rows = await _safe_optional_fetchall(
        con,
        "SELECT id, name FROM pokedex",
        (),
        tables=("pokedex",),
    )
    if not all_rows:
        return None, []
    choices = [r["name"] for r in all_rows]
    best, ratio, suggestions = _fuzzy_best(q, choices)  # <-- your corrector
    if not best or ratio < 0.82:
        return None, suggestions
    row = await _safe_optional_fetchone(
        con,
        "SELECT * FROM pokedex WHERE LOWER(name)=?",
        (best.lower(),),
        tables=("pokedex",),
    )
    return row, [] if row else suggestions

# ---------- Sprite helpers (form-aware + fuzzy folder) ----------
try:
    SPRITES_DIR  # type: ignore
except NameError:
    # Fallback in case you don‚Äôt have a global set elsewhere
    SPRITES_DIR = Path(__file__).resolve().parent / "sprites"

def _species_folder_name(species: str) -> str:
    s = str(species or "").strip().lower()
    return s.replace(" ", "-").replace("_", "-")

def _candidate_filenames(shiny: bool = False, gender: Optional[str] = None) -> List[str]:
    # Same exact priority as your bot
    g = str(gender or "").strip().lower()
    female = g in {"female", "f", "‚ôÄ"}
    cand: List[str] = []
    if female:
        if shiny:
            cand += ["female-animated-shiny-front.gif", "female-shiny-front.png"]
        cand += ["female-animated-front.gif", "female-front.png"]
    if shiny:
        cand += ["animated-shiny-front.gif", "shiny-front.png"]
    cand += ["animated-front.gif", "front.png", "icon.png"]
    return cand

def _form_folder_candidates(species: str, form_key: str) -> list[Path]:
    """
    Generate folder candidates using both hyphen and space styles:
      - "<species>-<form-key>"
      - "<species> <form key with spaces>"
      - "<species> <form-key>" (keeps hyphens in tail)
    """
    # Special handling for Missing n0 forms
    sp_norm = str(species or "").strip().lower()
    if (sp_norm == "missing n0" or sp_norm == "missing-n0") and form_key in ["n1", "n2", "n3", "n4", "n5"]:
        return [SPRITES_DIR / f"missing-n0-{form_key}"]
    
    sdir = _species_folder_name(species)
    fkey = normalize_form_key(form_key) or ""
    if not fkey:
        return []
    hyphen_join = SPRITES_DIR / f"{sdir}-{fkey}"
    space_tail  = " ".join(fkey.split("-"))
    space_join  = SPRITES_DIR / f"{sdir} {space_tail}"
    mixed_join  = SPRITES_DIR / f"{sdir} {fkey}"
    return [hyphen_join, space_join, mixed_join]

def _fuzzy_pick_existing_folder(species: str, form_key: str) -> Optional[Path]:
    """
    If exact form folders aren't found, fuzzy-pick the closest folder
    among those starting with '<species>' (space or hyphen).
    """
    sdir = _species_folder_name(species)
    fkey = normalize_form_key(form_key) or ""
    if not fkey:
        return None
    try:
        basenames = [d.name for d in SPRITES_DIR.iterdir()
                     if d.is_dir() and (d.name.startswith(sdir + " ") or d.name.startswith(sdir + "-"))]
    except Exception:
        basenames = []
    ideal1 = f"{sdir}-{fkey}"
    ideal2 = f"{sdir} " + " ".join(fkey.split("-"))
    best1, r1, _ = _fuzzy_best(ideal1, basenames)
    best2, r2, _ = _fuzzy_best(ideal2, basenames)
    best = best1 if r1 >= r2 else best2
    ratio = max(r1, r2)
    if best and ratio >= 0.80:
        p = SPRITES_DIR / best
        return p if p.exists() else None
    return None

def form_aware_species_dirs(species: str, form_key: Optional[str]) -> list[Path]:
    """
    Search order:
      1) exact form folders (if any)
      2) fuzzy-picked form folder
      3) base species folder
    """
    dirs: list[Path] = []
    if form_key:
        for cand in _form_folder_candidates(species, form_key):
            if cand.is_dir():
                dirs.append(cand)
        if not dirs:
            fuzzy = _fuzzy_pick_existing_folder(species, form_key)
            if fuzzy:
                dirs.append(fuzzy)
    dirs.append(SPRITES_DIR / _species_folder_name(species))
    # dedupe preserving order
    out, seen = [], set()
    for d in dirs:
        if d not in seen:
            out.append(d); seen.add(d)
    return out


def _discord_sprite_file(path: Path):
    """
    Build a Discord file for a sprite path.
    For animated GIFs, re-encode frame-by-frame with clamped durations so
    loop timing is stable (fixes some delta/disposal artifacts and fast resets).
    """
    from discord import File  # local import to avoid module-order issues
    try:
        if not path.exists() or not path.is_file() or path.stat().st_size <= 0:
            return None
    except Exception:
        return None

    if str(path.suffix or "").lower() != ".gif" or Image is None:
        try:
            return File(path, filename=path.name)
        except Exception:
            return None

    try:
        from PIL import ImageSequence  # type: ignore
    except Exception:
        return None

    try:
        frames: list[Any] = []
        durations: list[int] = []
        with Image.open(str(path)) as src:
            if not bool(getattr(src, "is_animated", False)):
                return None
            max_frames = min(160, max(1, int(getattr(src, "n_frames", 1) or 1)))
            for i, fr in enumerate(ImageSequence.Iterator(src)):
                if i >= max_frames:
                    break
                try:
                    frames.append(fr.copy().convert("RGBA"))
                except Exception:
                    frames.append(fr.convert("RGBA"))
                try:
                    d = int(fr.info.get("duration") or 0)
                except Exception:
                    d = 0
                if d <= 0:
                    try:
                        d = int(src.info.get("duration") or 0)
                    except Exception:
                        d = 0
                if d <= 0:
                    d = 95
                durations.append(max(70, min(220, d)))
        if len(frames) <= 1:
            return None
        out = BytesIO()
        frames[0].save(
            out,
            format="GIF",
            save_all=True,
            append_images=frames[1:],
            duration=durations or 95,
            loop=0,
            disposal=2,
        )
        out.seek(0)
        return File(fp=out, filename=path.name)
    except Exception:
        return None


def pokemon_sprite_attachment(
    species: str,
    *,
    shiny: bool = False,
    gender: Optional[str] = None,
    form_key: Optional[str] = None,
):
    """
    Returns (attachment_url, discord.File) or (None, None).
    Looks in form folders first (hyphen/space + fuzzy), then base species.
    """
    for folder in form_aware_species_dirs(species, form_key):
        for fname in _candidate_filenames(shiny=shiny, gender=gender):
            p = folder / fname
            try:
                if p.exists() and p.stat().st_size > 0:
                    f = _discord_sprite_file(p)
                    if f is not None:
                        return f"attachment://{f.filename}", f
            except Exception:
                pass
    return None, None

def attach_sprite_to_embed(
    emb,
    *,
    species: str,
    shiny: bool,
    gender: Optional[str],
    form_key: Optional[str] = None,
):
    files = []
    # If form_key already contains the species name (e.g., "kyurem-white"), 
    # pass it as species directly with form_key=None
    if form_key and form_key.startswith(f"{species}-"):
        url, file = pokemon_sprite_attachment(form_key, shiny=shiny, gender=gender, form_key=None)
    else:
        url, file = pokemon_sprite_attachment(species, shiny=shiny, gender=gender, form_key=form_key)
    if file:
        emb.set_thumbnail(url=url)
        files.append(file)
    return files
def _normalize_stats_keys(d: dict | None) -> dict:
    """
    Convert PokeAPI-style keys to your short keys.
      attack -> atk
      defense -> def
      special-attack -> spa
      special-defense -> spd
      speed -> spe
    Leaves hp as hp. Also tolerates spaces/variants.
    """
    if not isinstance(d, dict):
        return {}
    out = {}
    for k, v in d.items():
        if k is None:
            continue
        kk = str(k).strip().lower().replace(" ", "-")
        if   kk in ("attack",):                                 out["atk"] = v
        elif kk in ("defense",):                                out["def"] = v
        elif kk in ("special-attack","special_attack","sp-attack","spatk","spa"): out["spa"] = v
        elif kk in ("special-defense","special_defense","sp-defense","spdef","spd"): out["spd"] = v
        elif kk in ("speed","spe"):                           out["spe"] = v
        else:                              out[kk] = v  # keeps 'hp' etc.
    return out
# ---------- /pokeinfo (full fields, form-aware, fuzzy-aware) ----------
# === Helper function to generate pokeinfo embed ===
async def generate_pokeinfo_embed(
    species_id: int, 
    species_name: str,
    form_key: Optional[str],
    shiny: bool,
    gender: Optional[str],
    gen: Optional[int]
) -> tuple[discord.Embed, List[discord.File]]:
    """Generate embed and files for a Pok√©mon species/form"""
    
    # Get base row
    con = await db_connect()
    try:
        cur = await con.execute("SELECT * FROM pokedex WHERE id=?", (species_id,))
        base_row = await cur.fetchone()
        await cur.close()
    finally:
        await con.close()
    
    if not base_row:
        raise ValueError(f"Species ID {species_id} not found")
    
    # Get form row if needed
    form_row = None
    if form_key:
        con = await db_connect()
        try:
            form_row = await _safe_pokedex_forms_fetchone(
                con,
                "SELECT * FROM pokedex_forms WHERE species_id=? AND form_key=?",
                (species_id, form_key),
            )

            # Fallback: if not found in pokedex_forms, try mega_evolution overrides
            if not form_row:
                mrow = await _safe_optional_fetchone(
                    con,
                    """
                    SELECT stats, types, abilities
                    FROM mega_evolution
                    WHERE base_species_id = ? AND mega_form = ?
                    """,
                    (species_id, form_key),
                    tables=("mega_evolution",),
                )
                if mrow:
                    mrow = dict(mrow)
                    form_row = {
                        "stats": mrow.get("stats"),
                        "types": mrow.get("types"),
                        "abilities": mrow.get("abilities"),
                        "display_name": form_key.replace(str(_r(base_row, "name")) + "-", "").replace("-", " ").title()
                    }
        finally:
            await con.close()
    
    # Get learnset counts
    con = await db_connect()
    try:
        cur = await con.execute("SELECT COUNT(*) AS c FROM learnsets WHERE species_id=?", (species_id,))
        total_learn = (await cur.fetchone())["c"]
        await cur.close()

        cur = await con.execute("""
            SELECT generation, COUNT(*) AS c
            FROM learnsets
            WHERE species_id=?
            GROUP BY generation
            ORDER BY generation
        """, (species_id,))
        per_gen_rows = await cur.fetchall()
        await cur.close()
    finally:
        await con.close()
    
    # Unpack + apply overrides
    def j_or(row, key, default):
        return _j(_r(row, key), default)
    
    stats        = j_or(base_row, "stats", {})
    types        = j_or(base_row, "types", [])
    abilities    = j_or(base_row, "abilities", [])
    egg_groups   = j_or(base_row, "egg_groups", [])
    ev_yield     = j_or(base_row, "ev_yield", {})
    gender_ratio = j_or(base_row, "gender_ratio", {})
    flavor       = _r(base_row, "flavor", "")
    color        = _r(base_row, "color", "")
    
    base_experience = _r(base_row, "base_experience")
    height_m        = _r(base_row, "height_m")
    weight_kg       = _r(base_row, "weight_kg")
    
    if form_row:
        # Prefer form values when present; otherwise keep base
        stats           = j_or(form_row, "stats", stats) or stats
        types           = j_or(form_row, "types", types) or types
        abilities       = j_or(form_row, "abilities", abilities) or abilities
        v = _r(form_row, "base_experience"); base_experience = base_experience if v in (None, "") else v
        v = _r(form_row, "height_m");        height_m        = height_m        if v in (None, "") else v
        v = _r(form_row, "weight_kg");       weight_kg       = weight_kg       if v in (None, "") else v
        v = _r(form_row, "flavor");          flavor          = flavor          if v in (None, "") else v
        v = _r(form_row, "color");           color           = color           if v in (None, "") else v
    
    # Normalize stats keys
    stats = _normalize_stats_keys(stats)
    ev_yield = _normalize_stats_keys(ev_yield)
    
    # Build embed
    title_name = _r(base_row, "name", "").title()
    if form_row and _r(form_row, "display_name"):
        title_name = f"{title_name} ‚Äî {_r(form_row, 'display_name')}"
    title = f"{title_name}  (#{_r(base_row, 'id')})"
    
    emb = discord.Embed(title=title, description=flavor)
    
    types_txt = ", ".join((t["name"] if isinstance(t, dict) else str(t)).replace("-", " ").title() for t in types) or "‚Äî"
    emb.add_field(name="Types", value=types_txt, inline=True)
    emb.add_field(name="Gen", value=str(_r(base_row, "introduced_in", "‚Äî")), inline=True)
    emb.add_field(name="Base Exp", value=str(base_experience if base_experience is not None else "‚Äî"), inline=True)
    
    S = lambda k: stats.get(k, "?")
    stats_txt = (
        f"HP {S('hp')} | Atk {S('atk')} | Def {S('def')}\n"
        f"SpA {S('spa')} | SpD {S('spd')} | Spe {S('spe')}"
    )
    emb.add_field(name="Base Stats", value=stats_txt, inline=False)
    
    size_txt = f"{height_m} m, {weight_kg} kg" if (height_m is not None and weight_kg is not None) else "‚Äî"
    emb.add_field(name="Size", value=size_txt, inline=True)
    emb.add_field(name="Capture Rate", value=str(_r(base_row, "capture_rate", "‚Äî")), inline=True)
    emb.add_field(
        name="Base Friendship",
        value=str(_r(base_row, "base_friendship", _r(base_row, "base_happiness", "‚Äî"))),
        inline=True
    )
    
    egg_txt = ", ".join((x["name"] if isinstance(x, dict) else str(x)).replace("-", " ").title() for x in egg_groups) or "‚Äî"
    growth = str(_r(base_row, "growth_rate", "‚Äî")).replace("-", " ").title()
    emb.add_field(name="Egg Groups", value=egg_txt, inline=True)
    emb.add_field(name="Growth Rate", value=growth, inline=True)
    
    regs, hides = _split_abilities(abilities)
    abil_txt   = ", ".join(a.replace("-", " ").title() for a in regs) or "‚Äî"
    hidden_txt = ", ".join(a.replace("-", " ").title() for a in hides) or "‚Äî"
    ev_txt     = ", ".join(f"{k.upper()} {v}" for k, v in (ev_yield.items() if isinstance(ev_yield, dict) else []) if int(v or 0) > 0) or "‚Äî"
    
    if isinstance(gender_ratio, dict):
        male = int(round(100 * (gender_ratio.get("male", 0) or 0)))
        female = int(round(100 * (gender_ratio.get("female", 0) or 0)))
        gender_txt = (f"‚ôÇ {male}% / ‚ôÄ {female}%" if (male or female)
                      else ("Genderless" if (gender_ratio.get("genderless") or 0) else "‚Äî"))
    else:
        gender_txt = "‚Äî"
    
    emb.add_field(name="Abilities", value=abil_txt, inline=False)
    emb.add_field(name="Hidden Ability", value=hidden_txt, inline=True)
    emb.add_field(name="EV Yield", value=ev_txt, inline=True)
    emb.add_field(name="Gender Ratio", value=gender_txt, inline=True)
    
    color_genus = f"{str(color).title()} ¬∑ {str(_r(base_row, 'genus', '‚Äî'))}"
    emb.add_field(name="Color ¬∑ Genus", value=color_genus, inline=True)
    emb.add_field(name="Evolution", value=_r(base_row, "evolution", "‚Äî"), inline=False)
    
    per_gen = ", ".join(f"G{r['generation']}:{r['c']}" for r in per_gen_rows) or "‚Äî"
    if gen is not None:
        gcount = next((r['c'] for r in per_gen_rows if int(r['generation']) == int(gen)), 0)
        per_gen += f"  |  G{int(gen)}: {gcount}"
    emb.add_field(name="Learnsets", value=f"Total moves: {total_learn}\n{per_gen}", inline=False)
    
    # Sprite
    try:
        files = attach_sprite_to_embed(
            emb, species=str(_r(base_row, "name")), shiny=bool(shiny), gender=gender, form_key=form_key
        )
    except TypeError:
        files = attach_sprite_to_embed(
            emb, species=str(_r(base_row, "name")), shiny=bool(shiny), gender=gender
        )
    
    return emb, files

# === Form Selection View for /pokeinfo ===
class PokeInfoFormView(discord.ui.View):
    """Interactive form selection buttons for /pokeinfo"""
    def __init__(self, species_id: int, species_name: str, available_forms: List[dict], 
                 current_form: Optional[str], shiny: bool, gender: Optional[str], gen: Optional[int]):
        super().__init__(timeout=300)  # 5 minute timeout
        self.species_id = species_id
        self.species_name = species_name
        self.available_forms = available_forms
        self.current_form = current_form
        self.shiny = shiny
        self.gender = gender
        self.gen = gen
        
        # Add buttons for each form (max 25 buttons, 5 per row)
        for i, form_data in enumerate(available_forms[:25]):
            button = discord.ui.Button(
                label=form_data['display_name'],
                style=discord.ButtonStyle.primary if form_data['form_key'] == current_form else discord.ButtonStyle.secondary,
                row=i // 5,  # 5 buttons per row
                # Ensure uniqueness to avoid 'custom id cannot be duplicated'
                custom_id=f"form_{self.species_id}_{i}_{(form_data['form_key'] or 'base').replace(' ', '-')}"
            )
            button.callback = self._make_callback(form_data['form_key'])
            self.add_item(button)
    
    def _make_callback(self, form_key: Optional[str]):
        async def callback(interaction: discord.Interaction):
            try:
                await interaction.response.defer()
                # Re-generate embed for the selected form (will be implemented inline)
                await self._update_for_form(interaction, form_key)
            except Exception as e:
                print(f"[ERROR] Form button callback failed: {e}")
                import traceback
                traceback.print_exc()
                try:
                    await interaction.followup.send(f"Failed to update form: {e}", ephemeral=True)
                except:
                    pass
        return callback
    
    async def _update_for_form(self, interaction: discord.Interaction, new_form_key: Optional[str]):
        """Regenerate the embed for a different form"""
        # Re-fetch the species data with the new form
        con = await db_connect()
        try:
            cur = await con.execute("SELECT * FROM pokedex WHERE id=?", (self.species_id,))
            base_row = await cur.fetchone()
            await cur.close()
            
            if not base_row:
                await interaction.followup.send("Species not found.", ephemeral=True)
                return
            
            # Fetch form overrides if applicable
            form_row = None
            mrow = None
            prow = None
            if new_form_key:
                form_row_raw = await _safe_pokedex_forms_fetchone(
                    con,
                    "SELECT * FROM pokedex_forms WHERE species_id=? AND form_key=?",
                    (self.species_id, new_form_key),
                )
                form_row = dict(form_row_raw) if form_row_raw else None

                # Fallback to mega_evolution overrides when not present in pokedex_forms
                if not form_row:
                    mrow = await _safe_optional_fetchone(
                        con,
                        """
                        SELECT stats, types, abilities
                        FROM mega_evolution
                        WHERE base_species_id = ? AND mega_form = ?
                        """,
                        (self.species_id, new_form_key),
                        tables=("mega_evolution",),
                    )
                if mrow:
                        mrow = dict(mrow)
                        form_row = {
                            "stats": mrow.get("stats"),
                            "types": mrow.get("types"),
                            "abilities": mrow.get("abilities"),
                            "display_name": new_form_key.replace(str(base_row["name"]) + "-", "").replace("-", " ").title()
                        }

            # Second fallback for button view: primal_reversion
            if not form_row:
                prow = await _safe_optional_fetchone(
                    con,
                    """
                    SELECT stats, types, abilities
                    FROM primal_reversion
                    WHERE base_species_id = ? AND primal_form = ?
                    """,
                    (self.species_id, new_form_key),
                    tables=("primal_reversion",),
                )
                if prow:
                    prow = dict(prow)
                    form_row = {
                        "stats": prow.get("stats"),
                        "types": prow.get("types"),
                        "abilities": prow.get("abilities"),
                        "display_name": new_form_key.replace(str(base_row["name"]) + "-", "").replace("-", " ").title()
                    }
            
            # Fetch learnset counts
            cur = await con.execute("SELECT COUNT(*) AS c FROM learnsets WHERE species_id=?", (self.species_id,))
            total_learn = (await cur.fetchone())["c"]
            await cur.close()
            
            cur = await con.execute("""
                SELECT generation, COUNT(*) AS c
                FROM learnsets
                WHERE species_id=?
                GROUP BY generation
                ORDER BY generation
            """, (self.species_id,))
            per_gen_rows_raw = await cur.fetchall()
            per_gen_rows = [dict(row) for row in per_gen_rows_raw]
            await cur.close()
        finally:
            await con.close()
        
        # Unpack base stats
        # Convert Row to dict first
        base_row = dict(base_row) if base_row else {}
        
        def _r(row, key, default=None):
            if isinstance(row, dict):
                return row.get(key, default)
            return default
        
        def _j(val, default):
            if isinstance(val, dict): return val
            if isinstance(val, str):
                try:
                    return json.loads(val)
                except:
                    pass
            return default
        
        def j_or(row, key, default):
            return _j(_r(row, key), default)
        
        stats        = j_or(base_row, "stats", {})
        types        = j_or(base_row, "types", [])
        abilities    = j_or(base_row, "abilities", [])
        egg_groups   = j_or(base_row, "egg_groups", [])
        ev_yield     = j_or(base_row, "ev_yield", {})
        gender_ratio = j_or(base_row, "gender_ratio", {})
        flavor       = _r(base_row, "flavor", "")
        color        = _r(base_row, "color", "")
        
        base_experience = _r(base_row, "base_experience")
        height_m        = _r(base_row, "height_m")
        weight_kg       = _r(base_row, "weight_kg")
        
        # Apply form overrides
        if form_row:
            stats           = j_or(form_row, "stats", stats) or stats
            types           = j_or(form_row, "types", types) or types
            abilities       = j_or(form_row, "abilities", abilities) or abilities
            v = _r(form_row, "base_experience"); base_experience = base_experience if v in (None, "") else v
            v = _r(form_row, "height_m");        height_m        = height_m        if v in (None, "") else v
            v = _r(form_row, "weight_kg");       weight_kg       = weight_kg       if v in (None, "") else v
            v = _r(form_row, "flavor");          flavor          = flavor          if v in (None, "") else v
            v = _r(form_row, "color");           color           = color           if v in (None, "") else v
        
        # Normalize stats keys
        stats = _normalize_stats_keys(stats)
        ev_yield = _normalize_stats_keys(ev_yield)
        
        # Build embed title
        title_name = _r(base_row, "name", "").title()
        if form_row and _r(form_row, "display_name"):
            title_name = f"{title_name} ‚Äî {_r(form_row, 'display_name')}"
        elif not new_form_key and _r(base_row, "form_name"):
            form_display = _r(base_row, "form_name").replace("-", " ").title()
            title_name = f"{title_name}-{form_display}"
        title = f"{title_name}  (#{_r(base_row, 'id')})"
        
        emb = discord.Embed(title=title, description=flavor)
        
        # Types
        types_txt = ", ".join((t["name"] if isinstance(t, dict) else str(t)).replace("-", " ").title() for t in types) or "‚Äî"
        emb.add_field(name="Types", value=types_txt, inline=True)
        emb.add_field(name="Gen", value=str(_r(base_row, "introduced_in", "‚Äî")), inline=True)
        emb.add_field(name="Base Exp", value=str(base_experience if base_experience is not None else "‚Äî"), inline=True)
        
        # Base Stats
        S = lambda k: stats.get(k, "?")
        stats_txt = (
            f"HP {S('hp')} | Atk {S('atk')} | Def {S('def')}\n"
            f"SpA {S('spa')} | SpD {S('spd')} | Spe {S('spe')}"
        )
        emb.add_field(name="Base Stats", value=stats_txt, inline=False)
        
        # Size
        size_txt = f"{height_m} m, {weight_kg} kg" if (height_m is not None and weight_kg is not None) else "‚Äî"
        emb.add_field(name="Size", value=size_txt, inline=True)
        emb.add_field(name="Capture Rate", value=str(_r(base_row, "capture_rate", "‚Äî")), inline=True)
        emb.add_field(
            name="Base Friendship",
            value=str(_r(base_row, "base_friendship", _r(base_row, "base_happiness", "‚Äî"))),
            inline=True
        )
        
        # Egg groups and growth
        egg_txt = ", ".join((x["name"] if isinstance(x, dict) else str(x)).replace("-", " ").title() for x in egg_groups) or "‚Äî"
        growth = str(_r(base_row, "growth_rate", "‚Äî")).replace("-", " ").title()
        emb.add_field(name="Egg Groups", value=egg_txt, inline=True)
        emb.add_field(name="Growth Rate", value=growth, inline=True)
        
        # Abilities
        def _split_abilities(abilities):
            regular = []
            hidden = []
            for a in abilities:
                if isinstance(a, dict):
                    if a.get("is_hidden"):
                        hidden.append(a.get("name", ""))
                    else:
                        regular.append(a.get("name", ""))
                else:
                    regular.append(str(a))
            return regular, hidden
        
        regs, hides = _split_abilities(abilities)
        abil_txt   = ", ".join(a.replace("-", " ").title() for a in regs) or "‚Äî"
        hidden_txt = ", ".join(a.replace("-", " ").title() for a in hides) or "‚Äî"
        ev_txt     = ", ".join(f"{k.upper()} {v}" for k, v in (ev_yield.items() if isinstance(ev_yield, dict) else []) if int(v or 0) > 0) or "‚Äî"
        
        if isinstance(gender_ratio, dict):
            male = int(round(100 * (gender_ratio.get("male", 0) or 0)))
            female = int(round(100 * (gender_ratio.get("female", 0) or 0)))
            gender_txt = (f"‚ôÇ {male}% / ‚ôÄ {female}%" if (male or female)
                          else ("Genderless" if (gender_ratio.get("genderless") or 0) else "‚Äî"))
        else:
            gender_txt = "‚Äî"
        
        emb.add_field(name="Abilities", value=abil_txt, inline=False)
        emb.add_field(name="Hidden Ability", value=hidden_txt, inline=True)
        emb.add_field(name="EV Yield", value=ev_txt, inline=True)
        emb.add_field(name="Gender Ratio", value=gender_txt, inline=True)
        
        # Color and evolution
        color_genus = f"{str(color).title()} ¬∑ {str(_r(base_row, 'genus', '‚Äî'))}"
        emb.add_field(name="Color ¬∑ Genus", value=color_genus, inline=True)
        emb.add_field(name="Evolution", value=_r(base_row, "evolution", "‚Äî"), inline=False)
        
        # Learnsets
        per_gen = ", ".join(f"G{r['generation']}:{r['c']}" for r in per_gen_rows) or "‚Äî"
        if self.gen is not None:
            gcount = next((r['c'] for r in per_gen_rows if int(r['generation']) == int(self.gen)), 0)
            per_gen += f"  |  G{int(self.gen)}: {gcount}"
        emb.add_field(name="Learnsets", value=f"Total moves: {total_learn}\n{per_gen}", inline=False)
        
        # Attach sprite - need to get fresh File objects for editing
        sprite_form = new_form_key
        if sprite_form is None and _r(base_row, "form_name"):
            sprite_form = _r(base_row, "form_name")
        
        # Build sprite folder path
        species_name = str(_r(base_row, "name")).strip().lower()
        form_norm = (str(sprite_form or "").strip().lower().replace(" ", "-").replace("_", "-")) if sprite_form else None
        
        # Special-case: Greninja Ash/Battle Bond normalization
        if species_name == "greninja" and form_norm and ("ash" in form_norm or "battle" in form_norm or "bond" in form_norm):
            form_norm = "battle-bond"
        
        # Special-case: Missing n0 forms - normalize species name first
        if species_name == "missing n0" or species_name == "missing-n0":
            species_name = "missing-n0"  # Normalize to hyphenated version
            if form_norm and form_norm in ["n1", "n2", "n3", "n4", "n5"]:
                lookup_species = f"{species_name}-{form_norm}"
            else:
                lookup_species = species_name
        elif form_norm:
            if form_norm.startswith(f"{species_name}-"):
                lookup_species = form_norm
            else:
                lookup_species = f"{species_name}-{form_norm}"
        else:
            lookup_species = species_name
        
        # Get sprite file path and create fresh File object
        from pathlib import Path
        sprites_base = Path(__file__).resolve().parent / "pvp" / "_common" / "sprites"
        lookup_folder = lookup_species.lower().replace(" ", "-").replace("_", "-")
        sprite_folder = sprites_base / lookup_folder
        
        files = []
        sprite_found = False
        if sprite_folder.is_dir():
            is_female = (str(self.gender or "").strip().lower() == "female")
            
            # First try animated sprites
            animated_candidates = []
            if is_female:
                if self.shiny:
                    animated_candidates += ["female-animated-shiny-front.gif"]
                animated_candidates += ["female-animated-front.gif"]
            
            if self.shiny:
                animated_candidates += ["animated-shiny-front.gif"]
            animated_candidates += ["animated-front.gif"]
            
            # Try animated first
            for fname in animated_candidates:
                fp = sprite_folder / fname
                try:
                    if fp.exists() and fp.stat().st_size > 0:
                        files.append(discord.File(fp, filename=fp.name))
                        emb.set_thumbnail(url=f"attachment://{fp.name}")
                        sprite_found = True
                        break
                except Exception:
                    continue
            
            # If no animated sprite found, try static sprites
            if not sprite_found:
                static_candidates = []
                if is_female:
                    if self.shiny:
                        static_candidates += ["female-shiny-front.png"]
                    static_candidates += ["female-front.png"]
                
                if self.shiny:
                    static_candidates += ["shiny-front.png"]
                static_candidates += ["front.png", "icon.png"]
                
                for fname in static_candidates:
                    fp = sprite_folder / fname
                    try:
                        if fp.exists() and fp.stat().st_size > 0:
                            files.append(discord.File(fp, filename=fp.name))
                            emb.set_thumbnail(url=f"attachment://{fp.name}")
                            sprite_found = True
                            break
                    except Exception:
                        continue
        
        # If still not found, try base species folder as fallback
        if not sprite_found:
            base_folder = sprites_base / "missing-n0"
            if base_folder.is_dir():
                # Try static sprites from base folder
                static_candidates = []
                if self.shiny:
                    static_candidates += ["shiny-front.png"]
                static_candidates += ["front.png", "icon.png"]
                
                for fname in static_candidates:
                    fp = base_folder / fname
                    try:
                        if fp.exists() and fp.stat().st_size > 0:
                            files.append(discord.File(fp, filename=fp.name))
                            emb.set_thumbnail(url=f"attachment://{fp.name}")
                            sprite_found = True
                            break
                    except Exception:
                        continue
        
        if not sprite_found:
            print(f"[DEBUG] No sprite found for {lookup_species} (shiny={self.shiny}, gender={self.gender}), tried folder: {lookup_folder}")
        
        # Update the view with new current form
        new_view = PokeInfoFormView(
            species_id=self.species_id,
            species_name=self.species_name,
            available_forms=self.available_forms,
            current_form=new_form_key,
            shiny=self.shiny,
            gender=self.gender,
            gen=self.gen
        )
        
        try:
            await interaction.edit_original_response(embed=emb, attachments=files, view=new_view)
        finally:
            _close_discord_files(files)

@bot.tree.command(name="pokeinfo", description="Show Pok√©dex info from the DB (sprite, shiny, gender).")
@app_commands.describe(
    name_or_id="Name or National Dex number (e.g., bulbasaur or 1). Names like 'alolan raichu' are okay.",
    shiny="Show shiny sprite (default: off)",
    gender="Force sprite gender (optional)",
    gen="Also show how many moves are legal in this generation (1‚Äì9)"
)
@app_commands.choices(
    gender=[
        app_commands.Choice(name="male", value="male"),
        app_commands.Choice(name="female", value="female"),
    ]
)
async def pokeinfo(
    interaction: discord.Interaction,
    name_or_id: str,
    shiny: bool = False,
    gender: Optional[str] = None,
    gen: Optional[int] = None,
):
    """Full /pokeinfo with forms + fuzzy name + stats-key normalization."""
    if not interaction.response.is_done():
        await interaction.response.defer(ephemeral=True, thinking=True)

    # ---------- resolve base species row (+ form_key) ----------
    target = name_or_id.strip()
    form_key: Optional[str] = None

    if target.isdigit():
        species_id = int(target)
        form_key = None  # No explicit form parameter, will use base form
        base_row = None
        if db_cache:
            base_row = db_cache.get_cached_pokedex(target)
            if not base_row or species_id == 72635:
                base_row = db_cache.get_cached_pokedex("72635") or db_cache.get_cached_pokedex("missing n0") or base_row
        if base_row is None:
            con = await db_connect()
            try:
                cur = await con.execute("SELECT * FROM pokedex WHERE id=?", (species_id,))
                base_row = await cur.fetchone(); await cur.close()
                if not base_row or species_id == 72635:
                    cur = await con.execute("SELECT * FROM pokedex WHERE id=72635 OR name='missing n0' LIMIT 1", ())
                    base_row = await cur.fetchone(); await cur.close()
            finally:
                await con.close()
        if base_row and hasattr(base_row, "keys") and not isinstance(base_row, dict):
            base_row = dict(base_row)
    else:
        # name path: auto-detect form words + fuzzy-correct species name
        species_guess, parsed_form = parse_form_from_name(target)
        form_key = parsed_form  # Only use parsed form from name, no explicit parameter
        base_row = None
        if db_cache:
            guess = str(species_guess or "").strip()
            cache_keys = {
                guess,
                guess.lower(),
                guess.replace(" ", "-"),
                guess.replace("-", " "),
                guess.replace("_", "-"),
                guess.replace("-", "_"),
            }
            for ck in cache_keys:
                base_row = db_cache.get_cached_pokedex(ck)
                if base_row:
                    break
        if base_row is None:
            con = await db_connect()
            try:
                cur = await con.execute("SELECT * FROM pokedex WHERE LOWER(name)=LOWER(?)", (species_guess.lower(),))
                base_row = await cur.fetchone(); await cur.close()
                if not base_row:
                    base_row, _ = await fuzzy_species_row(con, species_guess)  # uses your _fuzzy_best()
                if not base_row:
                    cur = await con.execute(
                        "SELECT * FROM pokedex WHERE LOWER(name) LIKE ? ORDER BY id LIMIT 1",
                        (species_guess.lower() + "%",)
                    )
                    base_row = await cur.fetchone(); await cur.close()
            finally:
                await con.close()
        if base_row and hasattr(base_row, "keys") and not isinstance(base_row, dict):
            base_row = dict(base_row)

    if not base_row:
        # If not found, try to show Missing n0 as fallback
        if db_cache:
            base_row = db_cache.get_cached_pokedex("72635") or db_cache.get_cached_pokedex("missing n0")
        if base_row is None:
            con = await db_connect()
            try:
                cur = await con.execute("SELECT * FROM pokedex WHERE id=72635 OR name='missing n0' LIMIT 1", ())
                base_row = await cur.fetchone(); await cur.close()
            finally:
                await con.close()
        if not base_row:
            return await interaction.followup.send("Not found in Pok√©dex cache. Try another name/ID.", ephemeral=True)
        if hasattr(base_row, "keys") and not isinstance(base_row, dict):
            base_row = dict(base_row)

    # ---------- optional per-form overrides ----------
    form_row = None
    if form_key:
        sid = _r(base_row, "id")
        sname = _r(base_row, "name")
        if db_cache:
            try:
                forms = db_cache.get_cached_pokedex_forms()
            except Exception as e:
                if _is_missing_table_error(e, "pokedex_forms"):
                    _disable_optional_table("pokedex_forms")
                    forms = []
                else:
                    forms = []
            if forms:
                for f in forms:
                    if f.get("species_id") != sid:
                        continue
                    if (f.get("form_key") or "").strip().lower() == (form_key or "").strip().lower():
                        form_row = dict(f)
                        break
                if not form_row and not (form_key or "").startswith(f"{sname}-"):
                    species_form_key = f"{sname}-{form_key}"
                    for f in forms:
                        if f.get("species_id") != sid:
                            continue
                        if (f.get("form_key") or "").strip().lower() == species_form_key.strip().lower():
                            form_row = dict(f)
                            form_key = species_form_key
                            break

        if form_row is None:
            con = await db_connect()
            try:
                form_row = await _safe_pokedex_forms_fetchone(
                    con,
                    "SELECT * FROM pokedex_forms WHERE species_id=? AND form_key=?",
                    (sid, form_key),
                )
                if form_row:
                    form_row = dict(form_row) if hasattr(form_row, "keys") and not isinstance(form_row, dict) else form_row
                if not form_row and not (form_key or "").startswith(f"{sname}-"):
                    species_form_key = f"{sname}-{form_key}"
                    form_row = await _safe_pokedex_forms_fetchone(
                        con,
                        "SELECT * FROM pokedex_forms WHERE species_id=? AND form_key=?",
                        (sid, species_form_key),
                    )
                    if form_row:
                        form_row = dict(form_row) if hasattr(form_row, "keys") and not isinstance(form_row, dict) else form_row
                        form_key = species_form_key

                # Fallback: mega_evolution overrides if still not found
                if not form_row:
                    mrow = await _safe_optional_fetchone(
                        con,
                        """
                        SELECT stat_changes, type_changes, ability_change
                        FROM mega_evolution
                        WHERE base_species_id = ? AND mega_form = ?
                        """,
                        (_r(base_row, "id"), form_key),
                        tables=("mega_evolution",),
                    )
                    if mrow:
                        mrow = dict(mrow)
                        raw_stats = _r(base_row, "stats")
                        try:
                            base_stats = json.loads(raw_stats) if isinstance(raw_stats, str) else (raw_stats or {})
                        except Exception:
                            base_stats = raw_stats or {}
                        raw_diffs = mrow.get("stat_changes")
                        try:
                            diffs = json.loads(raw_diffs) if isinstance(raw_diffs, str) else (raw_diffs or {})
                        except Exception:
                            diffs = raw_diffs or {}
                        merged_stats = {}
                        mapping = {
                            "hp": ("hp",),
                            "attack": ("attack","atk"),
                            "defense": ("defense","def"),
                            "special_attack": ("special_attack","special-attack","spa"),
                            "special_defense": ("special_defense","special-defense","spd"),
                            "speed": ("speed","spe"),
                        }
                        for out_key, keys in mapping.items():
                            base_v = int(base_stats.get(out_key, 0))
                            diff_v = 0
                            for k in keys:
                                if k in diffs:
                                    try:
                                        diff_v = int(diffs[k])
                                    except Exception:
                                        diff_v = 0
                                    break
                            merged_stats[out_key] = base_v + diff_v
                        form_row = {
                            "stats": json.dumps(merged_stats, ensure_ascii=False),
                            "types": mrow.get("type_changes"),
                            "abilities": mrow.get("ability_change"),
                            "display_name": form_key.replace(str(_r(base_row, "name")) + "-", "").replace("-", " ").title()
                        }

                # Second fallback: primal_reversion overrides
                if not form_row:
                    prow = await _safe_optional_fetchone(
                        con,
                        """
                        SELECT stat_changes, type_changes, ability_change
                        FROM primal_reversion
                        WHERE base_species_id = ? AND primal_form = ?
                        """,
                        (_r(base_row, "id"), form_key),
                        tables=("primal_reversion",),
                    )
                    if prow:
                        prow = dict(prow)
                        raw_stats = _r(base_row, "stats")
                        try:
                            base_stats = json.loads(raw_stats) if isinstance(raw_stats, str) else (raw_stats or {})
                        except Exception:
                            base_stats = raw_stats or {}
                        raw_diffs = prow.get("stat_changes")
                        try:
                            diffs = json.loads(raw_diffs) if isinstance(raw_diffs, str) else (raw_diffs or {})
                        except Exception:
                            diffs = raw_diffs or {}
                        merged_stats = {}
                        mapping = {
                            "hp": ("hp",),
                            "attack": ("attack","atk"),
                            "defense": ("defense","def"),
                            "special_attack": ("special_attack","special-attack","spa"),
                            "special_defense": ("special_defense","special-defense","spd"),
                            "speed": ("speed","spe"),
                        }
                        for out_key, keys in mapping.items():
                            base_v = int(base_stats.get(out_key, 0))
                            diff_v = 0
                            for k in keys:
                                if k in diffs:
                                    try:
                                        diff_v = int(diffs[k])
                                    except Exception:
                                        diff_v = 0
                                    break
                            merged_stats[out_key] = base_v + diff_v
                        form_row = {
                            "stats": json.dumps(merged_stats, ensure_ascii=False),
                            "types": prow.get("type_changes"),
                            "abilities": prow.get("ability_change"),
                            "display_name": form_key.replace(str(_r(base_row, "name")) + "-", "").replace("-", " ").title()
                        }
            finally:
                await con.close()

    # ---------- learnset counts ----------
    species_id = _r(base_row, "id")
    total_learn = None
    per_gen_rows = None
    if db_cache:
        ls = db_cache.get_cached_learnsets()
        if ls:
            from collections import defaultdict
            filt = [r for r in ls if r.get("species_id") == species_id]
            total_learn = len(filt)
            gcnt = defaultdict(int)
            for r in filt:
                g = r.get("generation")
                if g is not None:
                    gcnt[int(g)] += 1
            per_gen_rows = [{"generation": g, "c": c} for g, c in sorted(gcnt.items())]
    if total_learn is None:
        con = await db_connect()
        try:
            cur = await con.execute("SELECT COUNT(*) AS c FROM learnsets WHERE species_id=?", (species_id,))
            total_learn = (await cur.fetchone())["c"]
            await cur.close()
            cur = await con.execute("""
                SELECT generation, COUNT(*) AS c
                FROM learnsets
                WHERE species_id=?
                GROUP BY generation
                ORDER BY generation
            """, (species_id,))
            per_gen_rows = await cur.fetchall()
            await cur.close()
            per_gen_rows = [dict(r) if hasattr(r, "keys") and not isinstance(r, dict) else r for r in per_gen_rows]
        finally:
            await con.close()

    # ---------- unpack + apply overrides ----------
    def j_or(row, key, default):
        return _j(_r(row, key), default)

    stats        = j_or(base_row, "stats", {})
    types        = j_or(base_row, "types", [])
    abilities    = j_or(base_row, "abilities", [])
    egg_groups   = j_or(base_row, "egg_groups", [])
    ev_yield     = j_or(base_row, "ev_yield", {})
    gender_ratio = j_or(base_row, "gender_ratio", {})
    flavor       = _r(base_row, "flavor", "")
    color        = _r(base_row, "color", "")

    base_experience = _r(base_row, "base_experience")
    height_m        = _r(base_row, "height_m")
    weight_kg       = _r(base_row, "weight_kg")

    if form_row:
        stats           = j_or(form_row, "stats", stats) or stats
        types           = j_or(form_row, "types", types) or types
        abilities       = j_or(form_row, "abilities", abilities) or abilities
        v = _r(form_row, "base_experience"); base_experience = base_experience if v in (None, "") else v
        v = _r(form_row, "height_m");        height_m        = height_m        if v in (None, "") else v
        v = _r(form_row, "weight_kg");       weight_kg       = weight_kg       if v in (None, "") else v
        v = _r(form_row, "flavor");          flavor          = flavor          if v in (None, "") else v
        v = _r(form_row, "color");           color           = color           if v in (None, "") else v

    # ---------- normalize keys so embed uses atk/def/spa/spd/spe ----------
    stats = _normalize_stats_keys(stats)
    ev_yield = _normalize_stats_keys(ev_yield)

    # ---------- embed ----------
    title_name = _r(base_row, "name", "").title()
    if form_row and _r(form_row, "display_name"):
        title_name = f"{title_name} ‚Äî {_r(form_row, 'display_name')}"
    elif not form_key and _r(base_row, "form_name"):
        # If no explicit form was requested but base has form_name (e.g., Meloetta-Aria, Shaymin-Land)
        form_display = _r(base_row, "form_name").replace("-", " ").title()
        title_name = f"{title_name}-{form_display}"
    title = f"{title_name}  (#{_r(base_row, 'id')})"

    # Check if this is Missing n0 - show "unknown" for unspecified fields
    is_missing_n0 = _r(base_row, "name", "").lower() == "missing n0"

    emb = discord.Embed(title=title, description=flavor if flavor else ("Unknown" if is_missing_n0 else ""))

    types_txt = ", ".join((t["name"] if isinstance(t, dict) else str(t)).replace("-", " ").title() for t in types) or ("Unknown" if is_missing_n0 else "‚Äî")
    emb.add_field(name="Types", value=types_txt, inline=True)
    gen_val = _r(base_row, "introduced_in", "Unknown" if is_missing_n0 else "‚Äî")
    emb.add_field(name="Gen", value=str(gen_val), inline=True)
    base_exp_val = base_experience if base_experience is not None else ("Unknown" if is_missing_n0 else "‚Äî")
    emb.add_field(name="Base Exp", value=str(base_exp_val), inline=True)

    # For Missing n0, show total base stats instead of individual values
    if is_missing_n0:
        stats_txt = "720 base stats (rolled at battle start)"
    else:
        S = lambda k: stats.get(k, "?")
        stats_txt = (
            f"HP {S('hp')} | Atk {S('atk')} | Def {S('def')}\n"
            f"SpA {S('spa')} | SpD {S('spd')} | Spe {S('spe')}"
        )
    emb.add_field(name="Base Stats", value=stats_txt, inline=False)

    size_txt = f"{height_m} m, {weight_kg} kg" if (height_m is not None and weight_kg is not None) else ("Unknown" if is_missing_n0 else "‚Äî")
    emb.add_field(name="Size", value=size_txt, inline=True)
    capture_rate_val = _r(base_row, "capture_rate", "Unknown" if is_missing_n0 else "‚Äî")
    emb.add_field(name="Capture Rate", value=str(capture_rate_val), inline=True)
    base_friendship_val = _r(base_row, "base_friendship", _r(base_row, "base_happiness", "Unknown" if is_missing_n0 else "‚Äî"))
    emb.add_field(
        name="Base Friendship",
        value=str(base_friendship_val),
        inline=True
    )

    egg_txt = ", ".join((x["name"] if isinstance(x, dict) else str(x)).replace("-", " ").title() for x in egg_groups) or ("Unknown" if is_missing_n0 else "‚Äî")
    growth = str(_r(base_row, "growth_rate", "Unknown" if is_missing_n0 else "‚Äî")).replace("-", " ").title()
    emb.add_field(name="Egg Groups", value=egg_txt, inline=True)
    emb.add_field(name="Growth Rate", value=growth, inline=True)

    regs, hides = _split_abilities(abilities)
    # For Missing n0, show that abilities are rolled at battle start
    if is_missing_n0:
        abil_txt = "Rolled at battle start"
        hidden_txt = "‚Äî"
    else:
        abil_txt   = ", ".join(a.replace("-", " ").title() for a in regs) or "‚Äî"
        hidden_txt = ", ".join(a.replace("-", " ").title() for a in hides) or "‚Äî"
    ev_txt     = ", ".join(f"{k.upper()} {v}" for k, v in (ev_yield.items() if isinstance(ev_yield, dict) else []) if int(v or 0) > 0) or ("Unknown" if is_missing_n0 else "‚Äî")

    if isinstance(gender_ratio, dict):
        male = int(round(100 * (gender_ratio.get("male", 0) or 0)))
        female = int(round(100 * (gender_ratio.get("female", 0) or 0)))
        gender_txt = (f"‚ôÇ {male}% / ‚ôÄ {female}%" if (male or female)
                      else ("Genderless" if (gender_ratio.get("genderless") or 0) else "‚Äî"))
    else:
        gender_txt = "‚Äî"

    emb.add_field(name="Abilities", value=abil_txt, inline=False)
    emb.add_field(name="Hidden Ability", value=hidden_txt, inline=True)
    emb.add_field(name="EV Yield", value=ev_txt, inline=True)
    emb.add_field(name="Gender Ratio", value=gender_txt, inline=True)

    color_val = str(color).title() if color else ("Unknown" if is_missing_n0 else "‚Äî")
    genus_val = str(_r(base_row, 'genus', 'Unknown' if is_missing_n0 else '‚Äî'))
    color_genus = f"{color_val} ¬∑ {genus_val}"
    emb.add_field(name="Color ¬∑ Genus", value=color_genus, inline=True)
    evolution_val = _r(base_row, "evolution", "Unknown" if is_missing_n0 else "‚Äî")
    emb.add_field(name="Evolution", value=evolution_val, inline=False)

    per_gen = ", ".join(f"G{r['generation']}:{r['c']}" for r in per_gen_rows) or "‚Äî"
    if gen is not None:
        gcount = next((r['c'] for r in per_gen_rows if int(r['generation']) == int(gen)), 0)
        per_gen += f"  |  G{int(gen)}: {gcount}"
    emb.add_field(name="Learnsets", value=f"Total moves: {total_learn}\n{per_gen}", inline=False)

    # ---------- sprite (form-aware if your helper supports it) ----------
    # If form_key is None but base has form_name, use that for sprite lookup
    sprite_form = form_key
    if sprite_form is None and _r(base_row, "form_name"):
        sprite_form = _r(base_row, "form_name")
    
    # Use find_sprite from pvp/sprites.py for proper Missing n0 form handling
    try:
        from pvp.sprites import find_sprite
        species_name_for_sprite = str(_r(base_row, "name"))
        is_female_sprite = (str(gender or "").strip().lower() == "female")
        
        # Try to find sprite using the proper sprite loading function
        sprite_path = find_sprite(
            species_name_for_sprite,
            gen=9,  # Default gen
            perspective="front",
            shiny=bool(shiny),
            female=is_female_sprite,
            prefer_animated=True,
            form=sprite_form
        )
        
        if sprite_path and sprite_path.exists():
            f = _discord_sprite_file(Path(sprite_path))
            if f is not None:
                files = [f]
                emb.set_thumbnail(url=f"attachment://{f.filename}")
            else:
                files = []
        else:
            # Fallback to attach_sprite_to_embed
            files = attach_sprite_to_embed(
                emb, species=species_name_for_sprite, shiny=bool(shiny), gender=gender, form_key=sprite_form
            )
    except Exception as e:
        # Log error and try fallback
        print(f"[DEBUG] Sprite loading error for {_r(base_row, 'name')} (form={sprite_form}): {e}")
        try:
            files = attach_sprite_to_embed(
                emb, species=str(_r(base_row, "name")), shiny=bool(shiny), gender=gender, form_key=sprite_form
            )
        except Exception:
            files = []

    # ---------- Check for available forms and add buttons ----------
    view = None
    con = await db_connect()
    try:
        # Regular forms from pokedex_forms
        form_rows = await _safe_pokedex_forms_fetchall(
            con,
            "SELECT form_key, display_name FROM pokedex_forms WHERE species_id = ? ORDER BY form_key",
            (_r(base_row, "id"),),
        )
        
        # Mega Evolution forms
        mega_rows = await _safe_optional_fetchall(
            con,
            "SELECT mega_form, form_key FROM mega_evolution WHERE base_species_id = ? ORDER BY mega_form",
            (_r(base_row, "id"),),
            tables=("mega_evolution",),
        )
        
        # Gigantamax forms
        gmax_rows = await _safe_optional_fetchall(
            con,
            "SELECT gmax_form, form_key FROM gigantamax WHERE base_species_id = ? ORDER BY gmax_form",
            (_r(base_row, "id"),),
            tables=("gigantamax",),
        )
        
        # Primal Reversion forms
        primal_rows = await _safe_optional_fetchall(
            con,
            "SELECT primal_form, form_key FROM primal_reversion WHERE base_species_id = ? ORDER BY primal_form",
            (_r(base_row, "id"),),
            tables=("primal_reversion",),
        )
        
        # Combine all forms
        all_forms = []
        
        # Add regular forms
        all_forms.extend([{'form_key': row['form_key'], 'display_name': row['display_name']} for row in form_rows])
        
        # Add Mega forms
        for row in mega_rows:
            form_name = row['mega_form'].replace(_r(base_row, "name") + "-", "").replace("-", " ").title()
            all_forms.append({
                'form_key': row['mega_form'],
                'display_name': f"{_r(base_row, 'name').title()} ‚Äî {form_name} ‚ö°"
            })
        
        # Add Gigantamax forms
        for row in gmax_rows:
            form_name = row['gmax_form'].replace(_r(base_row, "name") + "-", "").replace("-", " ").title()
            all_forms.append({
                'form_key': row['gmax_form'],
                'display_name': f"{_r(base_row, 'name').title()} ‚Äî {form_name} üí´"
            })
        
        # Add Primal forms
        for row in primal_rows:
            form_name = row['primal_form'].replace(_r(base_row, "name") + "-", "").replace("-", " ").title()
            all_forms.append({
                'form_key': row['primal_form'],
                'display_name': f"{_r(base_row, 'name').title()} ‚Äî {form_name} üî•"
            })
        
        # Deduplicate by form_key and label (avoid duplicate generic 'Mega' if specific exists)
        dedup: dict[str, dict] = {}
        for f in all_forms:
            fk = f.get('form_key') or 'base'
            # prefer longer/more descriptive labels
            if fk not in dedup or len(str(f.get('display_name') or '')) > len(str(dedup[fk].get('display_name') or '')):
                dedup[fk] = f
        all_forms = list(dedup.values())

        if all_forms:
            # Add base form as first option
            # If the base Pokemon has a form_name (e.g., Shaymin-Land, Meloetta-Aria), use that as the form_key
            base_form_key = _r(base_row, "form_name")
            base_form_display = _r(base_row, "name").title()
            if base_form_key:
                base_form_display = f"{base_form_display} ‚Äî {base_form_key.replace('-', ' ').title()}"
            else:
                base_form_display = f"{base_form_display} (Base)"
            
            available_forms = [{'form_key': base_form_key, 'display_name': base_form_display}]
            # Limit to 7 extra forms to avoid overcrowding
            available_forms.extend(all_forms[:7])
            
            if len(available_forms) > 1:  # Only show buttons if there are multiple forms
                view = PokeInfoFormView(
                    species_id=_r(base_row, "id"),
                    species_name=_r(base_row, "name"),
                    available_forms=available_forms,
                    current_form=form_key,
                    shiny=shiny,
                    gender=gender,
                    gen=gen
                )
    finally:
        await con.close()

    try:
        if view is not None:
            await interaction.followup.send(embed=emb, files=files, view=view, ephemeral=True)
        else:
            await interaction.followup.send(embed=emb, files=files, ephemeral=True)
    finally:
        _close_discord_files(files)
# Symbol per method (change these if you want different icons)
# ---------------- emoji & formatting helpers ----------------

async def _pokeball_emoji(guild: discord.Guild | None) -> str:
    """
    Try to find a custom pok√©ball emoji in this guild by common names or stored IDs.
    Returns a usable emoji string (e.g., '<:pokeball:123...>') or '' if not found.
    """
    if not guild:
        return ""
    # Try common names first
    common_names = ("pokeball", "poke-ball", "poke_ball", "poke ball")
    # exact match over guild emojis
    for e in guild.emojis:
        nm = e.name.lower().replace("_", "").replace("-", "")
        if nm in {n.replace("_", "").replace("-", "").replace(" ", "") for n in common_names}:
            return str(e)
    return ""  # fallback to nothing; you can replace with a unicode like '‚óì' if you want

METHOD_SYMBOL: Dict[str, str] = {
    "level-up": "LV",
    "machine":  "TM",
    "tutor":    "TR",
    "egg":      "EGG",
}
METHOD_ORDER: Dict[str, int] = {"level-up": 0, "machine": 1, "tutor": 2, "egg": 3}

TYPES = ["normal","fire","water","electric","grass","ice","fighting","poison","ground","flying",
         "psychic","bug","rock","ghost","dragon","dark","steel","fairy"]
CATEGORIES = ["physical","special","status"]

def _tc(s: str) -> str:
    return s.replace("-", " ").title()

def _fmt_line(name: str, method: str, level: Optional[int], form_label: str) -> str:
    """
    Compact single line:
      ‚Ä¢ level-up: '[Form] Lv.19 ‚Ä¢ Razor Leaf'
      ‚Ä¢ others:   '[Form] [TM] Brick Break' / '[Form] [EGG] Spore'
    """
    tag = METHOD_SYMBOL.get(method, "?")
    prefix = f"[{_tc(form_label)}] " if form_label and form_label != "(default)" else ""
    if method == "level-up" and level is not None:
        return f"{prefix}Lv.{int(level):>2} ‚Ä¢ {_tc(name)}"
    return f"{prefix}[{tag}] {_tc(name)}"

def _paginate_15(flat: List[str]) -> List[List[str]]:
    """Make pages of exactly 15 lines (pad the last one)."""
    pages = []
    for i in range(0, len(flat), 15):
        chunk = flat[i:i+15]
        if len(chunk) < 15:
            chunk += [""] * (15 - len(chunk))
        pages.append(chunk)
    return pages or [[""] * 15]

def _split_cols_3x5(lines15: List[str]) -> List[str]:
    """
    Take a 15-line page and return three strings (5 lines each),
    trimming trailing empties so columns look tight.
    """
    c0, c1, c2 = lines15[0:5], lines15[5:10], lines15[10:15]
    def _trim(col):
        while col and col[-1] == "":
            col.pop()
        return col
    c0, c1, c2 = _trim(c0), _trim(c1), _trim(c2)
    return ["\n".join(c) if c else "‚Äî" for c in (c0, c1, c2)]

# ---------------- pagination view (no code block; 3 embed fields) ----------------

class MovesPager(discord.ui.View):
    def __init__(self, pages: List[List[str]], title_prefix: str, footer_text: str, species: str):
        super().__init__(timeout=180)
        self.pages = pages
        self.page = 0
        self.title_prefix = title_prefix
        self.footer_text = footer_text
        self.species = species  # for sprite

    def _embed_and_files(self) -> tuple[discord.Embed, list]:
        col_texts = _split_cols_3x5(self.pages[self.page])
        emb = discord.Embed(
            title=f"{self.title_prefix} ‚Äî Page {self.page+1}/{len(self.pages)}",
            color=discord.Color.blurple()
        )
        # three neat inline columns (no gray code block)
        for txt in col_texts:
            emb.add_field(name="\u200b", value=txt, inline=True)
        # ensure row completes
        if len(col_texts) < 3:
            for _ in range(3 - len(col_texts)):
                emb.add_field(name="\u200b", value="‚Äî", inline=True)

        emb.set_footer(text=self.footer_text + " | Click ‚óÄÔ∏è ‚ñ∂Ô∏è or ‚èÆ ‚è≠ to navigate.")
        files = []
        try:
            # your own helper that returns List[discord.File]
            files = attach_sprite_to_embed(emb, species=self.species, shiny=False, gender=None)
        except Exception:
            pass
        return emb, files

    async def send_initial(self, itx: discord.Interaction):
        emb, files = self._embed_and_files()
        try:
            await itx.followup.send(embed=emb, files=files, view=self, ephemeral=False)
        finally:
            _close_discord_files(files)

    @discord.ui.button(label="‚èÆ", style=discord.ButtonStyle.secondary)
    async def first(self, itx: discord.Interaction, _):
        self.page = 0
        emb, files = self._embed_and_files()
        try:
            await itx.response.edit_message(embed=emb, attachments=files, view=self)
        finally:
            _close_discord_files(files)

    @discord.ui.button(label="‚óÄÔ∏è", style=discord.ButtonStyle.secondary)
    async def prev(self, itx: discord.Interaction, _):
        self.page = (self.page - 1) % len(self.pages)
        emb, files = self._embed_and_files()
        try:
            await itx.response.edit_message(embed=emb, attachments=files, view=self)
        finally:
            _close_discord_files(files)

    @discord.ui.button(label="‚ñ∂Ô∏è", style=discord.ButtonStyle.secondary)
    async def next(self, itx: discord.Interaction, _):
        self.page = (self.page + 1) % len(self.pages)
        emb, files = self._embed_and_files()
        try:
            await itx.response.edit_message(embed=emb, attachments=files, view=self)
        finally:
            _close_discord_files(files)

    @discord.ui.button(label="‚è≠", style=discord.ButtonStyle.secondary)
    async def last(self, itx: discord.Interaction, _):
        self.page = len(self.pages) - 1
        emb, files = self._embed_and_files()
        try:
            await itx.response.edit_message(embed=emb, attachments=files, view=self)
        finally:
            _close_discord_files(files)

# ---------------- /moves command (gen required; others optional) ----------------

@bot.tree.command(
    name="moves",
    description="List a Pok√©mon's moves for a generation in a clean 3√ó5 grid. Method/type/category optional."
)
@app_commands.describe(
    name_or_id="Pok√©mon name or National Dex number",
    gen="Generation number (1‚Äì9)",
    method="Optional: level-up, machine, tutor, egg (default: all methods)",
    move_category="Optional: Physical, Special or Status",
    move_type="Optional: move type (Fire, Water, etc.)"
)
@app_commands.choices(
    method=[
        app_commands.Choice(name="level-up", value="level-up"),
        app_commands.Choice(name="machine",  value="machine"),
        app_commands.Choice(name="tutor",    value="tutor"),
        app_commands.Choice(name="egg",      value="egg"),
    ],
    move_category=[app_commands.Choice(name=x.title(), value=x) for x in CATEGORIES],
    move_type=[app_commands.Choice(name=x.title(), value=x) for x in TYPES]
)
async def moves(
    interaction: discord.Interaction,
    name_or_id: str,
    gen: int,
    method: Optional[str] = None,
    move_category: Optional[str] = None,
    move_type: Optional[str] = None,
):
    await interaction.response.defer(ephemeral=True, thinking=True)

    # --- lookup species in your pokedex table
    target = name_or_id.strip()
    con = await db_connect()
    try:
        if target.isdigit():
            cur = await con.execute('SELECT id, name, introduced_in FROM pokedex WHERE id=?', (int(target),))
        else:
            cur = await con.execute('SELECT id, name, introduced_in FROM pokedex WHERE LOWER(name)=LOWER(?)', (target.lower(),))
        row = await cur.fetchone(); await cur.close()
        if not row and not target.isdigit():
            cur = await con.execute('SELECT id, name, introduced_in FROM pokedex WHERE LOWER(name) LIKE ? ORDER BY id LIMIT 1', (target.lower()+'%',))
            row = await cur.fetchone(); await cur.close()
    finally:
        await con.close()

    if not row:
        return await interaction.followup.send("Pok√©mon not found in your Pok√©dex cache.", ephemeral=True)

    sid, sname, intro = row["id"], row["name"], row["introduced_in"]
    if intro is not None and gen < int(intro):
        return await interaction.followup.send(
            f"**{_tc(sname)}** wasn‚Äôt in **Gen {gen}** (introduced in **Gen {intro}**).",
            ephemeral=True
        )

    # --- build SQL filters
    where = ["l.species_id = ?", "l.generation = ?"]
    params: List[object] = [sid, gen]
    if method:
        where.append("l.method = ?"); params.append(method)
    if move_category:
        where.append("LOWER(m.damage_class) = ?"); params.append(move_category.lower())
    if move_type:
        where.append("LOWER(m.type) = ?"); params.append(move_type.lower())

    # --- fetch learnset lines
    con = await db_connect()
    try:
        sql = f"""
            SELECT
              COALESCE(NULLIF(l.form_name,''), '(default)') AS form_label,
              m.name AS move_name,
              l.method,
              l.level_learned
            FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE {' AND '.join(where)}
        """
        cur = await con.execute(sql, tuple(params))
        rows = await cur.fetchall(); await cur.close()
    finally:
        await con.close()

    if not rows:
        bits = [f"Gen {gen}"]
        if method:        bits.append(method)
        if move_category: bits.append(move_category.title())
        if move_type:     bits.append(move_type.title())
        return await interaction.followup.send(
            f"No moves for **{_tc(sname)}** ({' ¬∑ '.join(bits)}).",
            ephemeral=True
        )

    # --- order & flatten to text lines
    from collections import defaultdict
    per_form: Dict[str, List[Tuple[int, Optional[int], str, str]]] = defaultdict(list)
    counts = {"level-up":0,"machine":0,"tutor":0,"egg":0}
    for r in rows:
        mo = r["method"]; counts[mo] = counts.get(mo, 0) + 1
        lvl = r["level_learned"] if mo == "level-up" else None
        per_form[r["form_label"]].append((METHOD_ORDER.get(mo, 99), lvl, r["move_name"], mo))

    def form_key(lbl: str): return (0, "") if lbl == "(default)" else (1, lbl.lower())

    flat: List[str] = []
    for form_lbl in sorted(per_form.keys(), key=form_key):
        entries = per_form[form_lbl]
        entries.sort(key=lambda t: (t[0], (t[1] is None, t[1] if t[1] is not None else 999), t[2].lower()))
        for _, lvl, name, mo in entries:
            flat.append(_fmt_line(name, mo, lvl, form_lbl))

    pages = _paginate_15(flat)

    # --- title with your server's pok√©ball emoji & bold method name (if chosen)
    ball = await _pokeball_emoji(interaction.guild)
    method_txt = ("all methods" if not method else f"**{method.lower()}**")
    title_prefix = " ¬∑ ".join(
        [f"{(ball + ' ') if ball else ''}{_tc(sname)}", f"Gen {gen}", method_txt]
        + ([move_category.title()] if move_category else [])
        + ([move_type.title()] if move_type else [])
    )

    # footer legend with bold symbols
    legend = "Legend ‚Äî " + "  ".join(f"**{v}**={k}" for k, v in METHOD_SYMBOL.items())
    totals = "  ".join(f"{k}:{v}" for k, v in counts.items() if v)
    if totals:
        legend += f"  |  Totals: {totals}"

    view = MovesPager(pages, title_prefix, legend, species=sname)
    await view.send_initial(interaction)
# =========================
#  fect message
# =========================
async def safe_fetch_message(
    client: discord.Client, channel_id: int, message_id: int
) -> Optional[discord.Message]:
    """Fetch a message if the channel type actually supports it."""
    chan = client.get_channel(channel_id)
    if chan is None:
        try:
            chan = await client.fetch_channel(channel_id)
        except Exception:
            chan = None
    if isinstance(chan, (discord.TextChannel, discord.Thread, discord.DMChannel, discord.GroupChannel)):
        try:
            return await chan.fetch_message(message_id)
        except Exception:
            return None
    return None


async def safe_edit_interaction_message(
    interaction: discord.Interaction,
    *,
    content: str | None = None,
    embed: discord.Embed | None = None,
    view: discord.ui.View | None = None,
) -> None:
    """Edit the message tied to this interaction if it exists."""
    if interaction.message is None:
        return
    try:
        await interaction.message.edit(content=content, embed=embed, view=view)
    except Exception:
        pass
class SafeView(discord.ui.View):
    def __init__(self, *, timeout: float | None = 180):
        super().__init__(timeout=timeout)

    def disable_all_buttons(self) -> None:
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                child.disabled = True


class VerifyRulesView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(
        label="‚úÖ I agree to the rules",
        style=discord.ButtonStyle.success,
        custom_id=VERIFY_BUTTON_CUSTOM_ID,
    )
    async def verify(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.guild or interaction.guild.id != VERIFY_GUILD_ID:
            await interaction.response.send_message("Run this in the server.", ephemeral=True)
            return
        if interaction.channel and interaction.channel.id != VERIFY_CHANNEL_ID:
            await interaction.response.send_message("Please verify in the rules channel.", ephemeral=True)
            return

        role = interaction.guild.get_role(VERIFY_ROLE_ID)
        if role is None:
            await interaction.response.send_message("Role not found. Tell an admin.", ephemeral=True)
            return

        member = interaction.user if isinstance(interaction.user, discord.Member) else None
        if member is None:
            await interaction.response.send_message("Could not resolve your member record.", ephemeral=True)
            return

        if role in member.roles:
            _set_cached_required_role(interaction.user.id, True)
            await interaction.response.send_message("You already have the role.", ephemeral=True)
            return

        try:
            await member.add_roles(role, reason="Accepted rules via verification button")
            _set_cached_required_role(interaction.user.id, True)
            await interaction.response.send_message("‚úÖ Verified! Role assigned.", ephemeral=True)
        except discord.Forbidden:
            await interaction.response.send_message("I don't have permission to assign that role.", ephemeral=True)
        except Exception:
            await interaction.response.send_message("An error occurred while assigning the role.", ephemeral=True)
# =========================
#  Events (single, clean)
# =========================

async def _periodic_cleanup_old_battle_media():
    """Periodically clean up old battle media files (GIFs) older than 1 hour."""
    import asyncio
    try:
        from pvp.renderer import cleanup_old_battle_media
        while True:
            try:
                # Wait 1 hour between cleanups
                await asyncio.sleep(3600)
                # Clean up files older than 1 hour
                cleanup_old_battle_media(max_age_hours=1)
                print("[Cleanup] Old battle media cleaned up")
            except Exception as e:
                print(f"[Cleanup] Error cleaning up old battle media: {e}")
    except ImportError:
        print("[Cleanup] cleanup_old_battle_media not available")

async def _periodic_pool_stats_logging():
    """Periodically log DB pool statistics to detect leaks."""
    import asyncio
    try:
        from pvp.db_pool import get_pool_stats
        while True:
            try:
                # Wait 5 minutes between logs
                await asyncio.sleep(300)
                stats = get_pool_stats()
                # Only log if pool utilization is high (>80%) or if there are leaks
                if stats.get("pool_utilization_pct", 0) > 80 or stats.get("in_use_connections", 0) > stats.get("pool_size", 0):
                    print(f"[DB Pool Stats] {stats}")
                # Always log if there are temporary connections (potential leak)
                if stats.get("total_connections", 0) > stats.get("pool_size", 0):
                    print(f"[DB Pool] WARNING: Potential connection leak detected! {stats}")
            except Exception as e:
                print(f"[DB Pool Stats] Error logging pool stats: {e}")
    except ImportError:
        print("[DB Pool Stats] get_pool_stats not available")

async def _periodic_auto_pull_updates():
    """
    Periodically fetch/pull updates from the current git branch.
    Intended for hosts where you want continuous auto-update checks while running.
    """
    import asyncio
    from pathlib import Path

    repo_root = Path(__file__).resolve().parent
    if not (repo_root / ".git").exists():
        print("[AutoPull] No .git directory found; auto-pull disabled.")
        return

    def _env_enabled(name: str, default: str = "1") -> bool:
        return str(os.getenv(name, default)).strip().lower() not in {"0", "false", "no", "off"}

    try:
        interval = int(float(os.getenv("AUTO_PULL_INTERVAL_SEC", "120")))
    except Exception:
        interval = 120
    interval = max(30, interval)
    restart_after_pull = _env_enabled("AUTO_PULL_RESTART", "1")

    async def _run_git(args: list[str], *, timeout: float = 30.0) -> tuple[int, str, str]:
        try:
            proc = await asyncio.create_subprocess_exec(
                "git",
                *args,
                cwd=str(repo_root),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
        except Exception as e:
            return (1, "", str(e))
        try:
            out_b, err_b = await asyncio.wait_for(proc.communicate(), timeout=timeout)
        except asyncio.TimeoutError:
            try:
                proc.kill()
            except Exception:
                pass
            try:
                await proc.communicate()
            except Exception:
                pass
            return (124, "", f"timeout after {timeout:.1f}s")
        out = (out_b.decode("utf-8", errors="ignore") if out_b else "").strip()
        err = (err_b.decode("utf-8", errors="ignore") if err_b else "").strip()
        return (int(proc.returncode or 0), out, err)

    rc, branch_name, err = await _run_git(["rev-parse", "--abbrev-ref", "HEAD"], timeout=20.0)
    if rc != 0 or not branch_name or branch_name == "HEAD":
        print(f"[AutoPull] Could not determine active branch ({err or 'unknown error'}); disabled.")
        return

    print(
        f"[AutoPull] Watching origin/{branch_name} every {interval}s "
        f"(restart={'on' if restart_after_pull else 'off'})."
    )

    while True:
        await asyncio.sleep(interval)
        try:
            # Skip pulls if working tree is dirty to avoid merge conflicts at runtime.
            rc, dirty, _ = await _run_git(["status", "--porcelain"], timeout=20.0)
            if rc == 0 and dirty:
                print("[AutoPull] Working tree dirty; skipping this check.")
                continue

            rc, _, err = await _run_git(["fetch", "origin", branch_name, "--quiet"], timeout=60.0)
            if rc != 0:
                print(f"[AutoPull] Fetch failed: {err or 'unknown error'}")
                continue

            rc_l, local_sha, _ = await _run_git(["rev-parse", "HEAD"], timeout=20.0)
            rc_r, remote_sha, err_r = await _run_git(["rev-parse", f"origin/{branch_name}"], timeout=20.0)
            if rc_l != 0 or rc_r != 0:
                print(f"[AutoPull] SHA resolve failed: {err_r or 'unknown error'}")
                continue
            if local_sha == remote_sha:
                continue

            rc, out, err = await _run_git(["pull", "--ff-only", "origin", branch_name], timeout=90.0)
            if rc != 0:
                print(f"[AutoPull] Pull failed: {err or out or 'unknown error'}")
                continue

            print(f"[AutoPull] Updated from origin/{branch_name}: {out or 'fast-forward complete'}")
            if restart_after_pull:
                print("[AutoPull] Restarting process to apply pulled updates...")
                try:
                    sys.stdout.flush()
                except Exception:
                    pass
                os.execv(sys.executable, [sys.executable, *sys.argv])
        except Exception as e:
            print(f"[AutoPull] Loop error: {e}")

@bot.event
async def on_ready():
    # Prevent double-run on reconnects
    if getattr(bot, "_ready_once", False):
        print(f"[reconnect] Reconnected as {bot.user} (id={bot.user.id})")
        return
    bot._ready_once = True
    _enable_embed_only_messages()
    try:
        bot.add_view(VerifyRulesView())
        print("[verify] Verification view registered")
    except Exception as e:
        print(f"[verify] add_view error: {e}")
    try:
        bot.beta_claim_view = BetaClaimView()
        bot.add_view(bot.beta_claim_view)
        print("[beta] Beta claim view registered")
    except Exception as e:
        print(f"[beta] add_view error: {e}")
    try:
        bot.add_view(AdventureRoute1PersistentView())
        print("[adventure] Route 1 persistent view registered")
    except Exception as e:
        print(f"[adventure] Route 1 persistent view add_view error: {e}")
    try:
        await bot.load_extension("pvp.pvprules")
        print("[PvP] pvp.pvprules loaded")
    except Exception as e:
        print("[PvP] Failed to load pvp.pvprules:", e)
    try:
        await bot.load_extension("pvp.commands")
        print("[PvP] pvp.commands loaded")
    except Exception as e:
        print("[PvP] Failed to load pvp.commands:", e)
    # 1) DB init / migrations
    try:
        await db.init_schema()
    except Exception as e:
        print(f"[on_ready] db.init_schema error: {e}")

    # 1a) Warm the DB connection pool for faster first queries (/team, /mypokeinfo, etc.)
    #     Tune via env: DB_POOL_MIN, DB_POOL_MAX, DB_POOL_ACQUIRE_TIMEOUT, DB_STICKY_CONN=0 to avoid pinning.
    try:
        warmed = await db.warm_pool(3)
        if warmed:
            print(f"[on_ready] DB pool warmed: {warmed} conns")
    except Exception as e:
        print(f"[on_ready] db.warm_pool error: {e}")

    # 1b) Warm db_cache at startup (pokedex, moves, items, static tables, pokemons for active teams).
    if warm_cache is not None:
        try:
            counts = await warm_cache()
            parts_main = [f"pokedex={counts['pokedex']}", f"moves={counts['moves']}", f"items={counts['items']}"]
            if counts.get("pokemons_owners"):
                parts_main.append(f"pokemons(team)={counts['pokemons_owners']}")
            print(f"[on_ready] Cache warmed: {' '.join(parts_main)}")
            parts = []
            for t in STATIC_TABLES + ["config"]:
                n = counts.get(t, 0)
                if n:
                    parts.append(f"{t}={n}")
            if parts:
                print(f"[on_ready] Cache warmed (static): {' '.join(parts)}")
        except Exception as e:
            print(f"[on_ready] warm_cache error: {e}")

    # 2) Load cogs once
    for Cog in (BagCog, AdminItems, EmojiLinkCog, AdminGivePokemon, OwnerShinyOddsCog, MPokeInfo):
        try:
            if not any(isinstance(c, Cog) for c in bot.cogs.values()):
                await bot.add_cog(Cog(bot))
                print(f"Loaded {Cog.__name__}")
        except Exception as e:
            print(f"[on_ready] Failed to load {Cog.__name__}: {e}")

    # 3) Sync slash commands
    try:
        cmds = await bot.tree.sync()
        print(f"[slash] Globally synced {len(cmds)} cmds: {[c.name for c in cmds]}")
    except Exception as e:
        print(f"[slash] sync failed: {e}")

    # 4) Banner
    try:
        guilds = len(bot.guilds)
    except Exception:
        guilds = "?"
    print(f"Logged in as {bot.user} (id={bot.user.id}) ¬∑ guilds={guilds}")
    sys.stdout.flush()

    # 5) Start periodic cleanup task for old battle media
    if not hasattr(bot, "_cleanup_task_started"):
        bot._cleanup_task_started = True
        bot.loop.create_task(_periodic_cleanup_old_battle_media())
        print("[Cleanup] Periodic battle media cleanup task started")

    # 6) Start periodic DB pool stats logging (every 5 minutes)
    if not hasattr(bot, "_pool_stats_task_started"):
        bot._pool_stats_task_started = True
        bot.loop.create_task(_periodic_pool_stats_logging())
        print("[DB Pool] Periodic pool stats logging started")

    # 7) Start periodic git auto-pull checks (enabled by default).
    #    Env controls:
    #      AUTO_PULL_LOOP=0        -> disable
    #      AUTO_PULL_INTERVAL_SEC  -> check interval (min 30s, default 120s)
    #      AUTO_PULL_RESTART=0     -> don't restart automatically after pull
    auto_pull_enabled = str(os.getenv("AUTO_PULL_LOOP", "1")).strip().lower() not in {"0", "false", "no", "off"}
    if auto_pull_enabled and not hasattr(bot, "_auto_pull_task_started"):
        bot._auto_pull_task_started = True
        bot.loop.create_task(_periodic_auto_pull_updates())
        print("[AutoPull] Periodic auto-pull task started")

@bot.event
async def on_message(message: discord.Message):
    # Always ignore bot messages to prevent loops
    if message.author.bot:
        return

    if EMBED_ECHO_CHANNEL_IDS and message.channel.id in EMBED_ECHO_CHANNEL_IDS:
        if EMBED_ECHO_GUILD_ID is not None:
            if not message.guild or message.guild.id != EMBED_ECHO_GUILD_ID:
                await bot.process_commands(message)
                return

        if EMBED_ECHO_USER_IDS is not None and message.author.id not in EMBED_ECHO_USER_IDS:
            await bot.process_commands(message)
            return

        if EMBED_ECHO_IGNORE_PREFIX_COMMANDS:
            prefix = bot.command_prefix
            if isinstance(prefix, str) and message.content.startswith(prefix):
                await bot.process_commands(message)
                return

        content = message.content or ""
        if content.strip() or message.attachments:
            embed = discord.Embed(description=content.strip() or None)
            embed.set_author(
                name=message.author.display_name,
                icon_url=message.author.display_avatar.url,
            )
            files = None
            if message.attachments:
                try:
                    files = [await a.to_file() for a in message.attachments]
                except Exception:
                    files = None
            try:
                await message.channel.send(embed=embed, files=files)
                if EMBED_ECHO_DELETE_SOURCE:
                    await message.delete()
            except Exception:
                pass
            finally:
                _close_discord_files(files)

    await bot.process_commands(message)
# ---------- /learn (add-or-replace with buttons) ----------
def _norm_move_name(s: str) -> str:
    return str(s).strip().lower().replace("  ", " ").replace(" ", "-")

def _parse_moves_text(txt: str | None) -> list[str]:
    if not txt:
        return []
    try:
        arr = json.loads(txt)
        if isinstance(arr, list):
            return [str(x) for x in arr][:4]
    except Exception:
        pass
    parts = [p.strip() for p in str(txt).split(",")]
    return [p for p in parts if p][:4]

async def _get_current_moves(owner_id: str, mon_id: int) -> list[str]:
    conn = await db.connect()
    try:
        cur = await conn.execute("SELECT moves FROM pokemons WHERE owner_id=? AND id=?", (owner_id, mon_id))
        row = await cur.fetchone(); await cur.close()
        return _parse_moves_text(row["moves"] if row else None)
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _save_moves(owner_id: str, mon_id: int, moves: list[str]) -> None:
    await _set_pokemon_moves(owner_id, mon_id, moves[:4])

async def _highest_unlocked_gen(user_id: str) -> int:
    """Return user's highest unlocked generation from user_rulesets.max_unlocked_gen (default 1)."""
    conn = await db.connect()
    try:
        c = await conn.execute("SELECT max_unlocked_gen FROM user_rulesets WHERE user_id=?", (user_id,))
        r = await c.fetchone(); await c.close()
        if r and r["max_unlocked_gen"]:
            return int(r["max_unlocked_gen"])
        return 1
    except Exception:
        return 1
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _resolve_team_mon_by_name_or_slot(user_id: str, token: str) -> tuple[int | None, dict | None, str | None]:
    """
    token: '1'..'6' (slot) OR species name.
    Returns (pokemon_id, row, err_msg)
    row has columns: id, species, level, team_slot
    """
    conn = await db.connect()
    try:
        # slot?
        tok = token.strip()
        if tok.isdigit():
            slot = int(tok)
            if not (1 <= slot <= 6):
                return None, None, "Team slot must be from 1 to 6."
            cur = await conn.execute(
                "SELECT id, species, level, team_slot FROM pokemons WHERE owner_id=? AND team_slot=?",
                (user_id, slot),
            )
            row = await cur.fetchone(); await cur.close()
            if not row:
                return None, None, f"No Pok√©mon in team slot {slot}."
            return int(row["id"]), row, None

        # species name on team
        cur = await conn.execute(
            "SELECT id, species, level, team_slot FROM pokemons WHERE owner_id=? AND LOWER(species)=LOWER(?) AND team_slot IS NOT NULL",
            (user_id, tok),
        )
        rows = await cur.fetchall(); await cur.close()
        if not rows:
            return None, None, f"No **{tok.title()}** in your current team."
        if len(rows) > 1:
            slots = ", ".join(str(r["team_slot"]) for r in rows if r["team_slot"] is not None)
            return None, None, f"You have multiple **{tok.title()}** in your team (slots {slots}). Use the **slot number** instead."
        row = rows[0]
        return int(row["id"]), row, None
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _species_id_from_name(name: str) -> int | None:
    conn = await db.connect()
    try:
        c = await conn.execute("SELECT id FROM pokedex WHERE LOWER(name)=LOWER(?) LIMIT 1", (name,))
        r = await c.fetchone(); await c.close()
        return int(r["id"]) if r else None
    finally:
        try:
            await conn.close()
        except Exception:
            pass

async def _move_id_from_name(move: str) -> tuple[int | None, str | None]:
    """Return (move_id, canonical_name) by flexible name match."""
    nm = _norm_move_name(move)
    conn = await db.connect()
    try:
        # exact (hyphen style) or space style
        c = await conn.execute(
            "SELECT id, name FROM moves WHERE LOWER(name)=LOWER(?) OR LOWER(REPLACE(name,'-',' '))=LOWER(?) LIMIT 1",
            (nm, move.strip().lower())
        )
        r = await c.fetchone(); await c.close()
        if r:
            return int(r["id"]), r["name"]
        # prefix fallback
        c = await conn.execute(
            "SELECT id, name FROM moves WHERE LOWER(name) LIKE ? ORDER BY LENGTH(name) LIMIT 1",
            (f"{nm}%",)
        )
        r = await c.fetchone(); await c.close()
        return (int(r["id"]), r["name"]) if r else (None, None)
    finally:
        try:
            await conn.close()
        except Exception:
            pass


def _learnset_gen_bounds_for_user_gen(user_gen: int) -> tuple[int, int]:
    """
    Map user-selected game gen to learnset generation window.
    Kanto/FRLG mode (gen 1) uses Gen 1-3 level-up learnsets.
    """
    try:
        g = int(user_gen or 1)
    except Exception:
        g = 1
    g = max(1, min(9, g))
    cap = 3 if g == 1 else g
    return (1, max(1, min(9, cap)))


async def _levelup_moves_for_species(species_id: int, gen_min: int, gen_max: int) -> list[dict[str, Any]]:
    try:
        sid = int(species_id)
        gmin = int(gen_min)
        gmax = int(gen_max)
    except Exception:
        return []
    if sid <= 0:
        return []
    if gmin > gmax:
        gmin, gmax = gmax, gmin
    async with db.session() as conn:
        cur = await conn.execute(
            """
            SELECT
                m.name AS move_name,
                MIN(COALESCE(l.level_learned, 1)) AS unlock_level
            FROM learnsets l
            JOIN moves m ON m.id = l.move_id
            WHERE l.species_id = ?
              AND l.generation BETWEEN ? AND ?
              AND LOWER(REPLACE(TRIM(COALESCE(l.method, '')), '_', '-')) = 'level-up'
            GROUP BY m.name
            ORDER BY unlock_level ASC, m.name ASC
            """,
            (sid, gmin, gmax),
        )
        rows = await cur.fetchall()
        await cur.close()
    out: list[dict[str, Any]] = []
    for r in rows or []:
        d = dict(r) if hasattr(r, "keys") else {}
        move_name = str(d.get("move_name") or "").strip()
        if not move_name:
            continue
        try:
            unlock = int(d.get("unlock_level") or 1)
        except Exception:
            unlock = 1
        out.append({"move_name": move_name, "unlock_level": max(1, unlock)})
    return out


def _split_levelup_rows(rows: list[dict[str, Any]], level: int) -> tuple[list[dict[str, Any]], list[dict[str, Any]]]:
    now_rows: list[dict[str, Any]] = []
    locked_rows: list[dict[str, Any]] = []
    try:
        lvl = int(level)
    except Exception:
        lvl = 1
    for r in rows or []:
        try:
            unlock = int(r.get("unlock_level") or 1)
        except Exception:
            unlock = 1
        if unlock <= lvl:
            now_rows.append(r)
        else:
            locked_rows.append(r)
    return now_rows, locked_rows


class OverrideMoveView(discord.ui.View):
    def __init__(self, owner_id: str, mon_id: int, old_moves: list[str], new_move: str, *, timeout: float = 60.0):
        super().__init__(timeout=timeout)
        self.owner_id = owner_id
        self.mon_id   = mon_id
        self.old      = old_moves[:4]
        self.new      = new_move
        for i, mv in enumerate(self.old):
            btn = discord.ui.Button(label=mv.replace("-", " ").title(), style=discord.ButtonStyle.primary, custom_id=f"ovr:{i}")
            btn.callback = self._make_cb(i)
            self.add_item(btn)

    def _lock(self):
        for c in self.children:
            if isinstance(c, discord.ui.Button):
                c.disabled = True

    def _make_cb(self, idx: int):
        async def cb(inter: discord.Interaction):
            if not inter.response.is_done():
                await inter.response.defer(ephemeral=True)
            new_list = self.old[:]
            new_list[idx] = self.new
            await _save_moves(str(inter.user.id), self.mon_id, new_list)
            self._lock()
            try:
                await inter.edit_original_response(view=self)
            except Exception:
                pass
            await inter.followup.send(
                f"‚úÖ Replaced **{self.old[idx].replace('-', ' ').title()}** with **{self.new.replace('-', ' ').title()}**.",
                ephemeral=True
            )
        return cb

# ---------------- /learn command ----------------
@bot.tree.command(name="learn", description="Teach a legal level-up move for your current generation rules.")
@app_commands.describe(
    mon="Team slot (1-6) OR Pok√©mon name on your team",
    move="Move name (must be a currently learnable level-up move)",
)
async def learn_cmd(interaction: discord.Interaction, mon: str, move: str):
    uid = str(interaction.user.id)
    await interaction.response.defer(ephemeral=True)

    mon_id, mon_row, err = await _resolve_team_mon_by_name_or_slot(uid, mon)
    if err:
        return await interaction.followup.send(f"‚ùå {err}", ephemeral=True)
    species_name = str(mon_row["species"])
    level = int(mon_row["level"])

    species_id = await _species_id_from_name(species_name)
    if not species_id:
        return await interaction.followup.send("‚ùå Could not resolve species in Pok√©dex.", ephemeral=True)

    try:
        user_gen = int(await _user_selected_gen(uid))
    except Exception:
        user_gen = 1
    gen_min, gen_max = _learnset_gen_bounds_for_user_gen(user_gen)

    rows = await _levelup_moves_for_species(int(species_id), gen_min, gen_max)
    if not rows:
        return await interaction.followup.send(
            f"‚ùå No level-up learnset data found for **{species_name.replace('-', ' ').title()}** "
            f"(Gen window: **{gen_min}-{gen_max}**).",
            ephemeral=True,
        )
    now_rows, _locked_rows = _split_levelup_rows(rows, level)
    if not now_rows:
        return await interaction.followup.send(
            f"‚ùå **{species_name.replace('-', ' ').title()}** has no level-up moves available at **Lv.{int(level)}** "
            f"for Gen window **{gen_min}-{gen_max}**.",
            ephemeral=True,
        )

    legal_names = [str(r.get("move_name") or "") for r in now_rows if str(r.get("move_name") or "").strip()]
    best_move, confidence, suggestions = FuzzyMatcher.fuzzy_match(move, legal_names, threshold=0.70)
    if not best_move or confidence < 0.70:
        pretty_examples = [str(m).replace("-", " ").replace("_", " ").title() for m in legal_names[:8]]
        pretty_suggestions = [str(s).replace("-", " ").replace("_", " ").title() for s in suggestions[:5]]
        sugg_text = f"\n\n**Try one of these now:** {', '.join(pretty_examples)}" if pretty_examples else ""
        if pretty_suggestions:
            sugg_text += f"\n**Did you mean:** {', '.join(pretty_suggestions)}"
        move_display = str(move or "").replace("-", " ").replace("_", " ").title()
        species_display = species_name.replace("-", " ").title()
        return await interaction.followup.send(
            f"‚ùå **{move_display}** can't be learned by **{species_display}** at **Lv.{int(level)}**.{sugg_text}",
            ephemeral=True,
        )

    current = await _get_current_moves(uid, mon_id)
    current_norm = {_norm_move_name(m) for m in current}
    nm = _norm_move_name(best_move)
    if nm in current_norm:
        return await interaction.followup.send(
            f"‚ÑπÔ∏è **{species_name.replace('-', ' ').title()}** already knows **{str(best_move).replace('-', ' ').title()}**.",
            ephemeral=True,
        )

    if len(current) < 4:
        new_list = current + [nm]
        await _save_moves(uid, mon_id, new_list)
        return await interaction.followup.send(
            f"‚úÖ **{species_name.replace('-', ' ').title()}** learned **{str(best_move).replace('-', ' ').title()}**!",
            ephemeral=True,
        )

    view = OverrideMoveView(uid, mon_id, current[:4], nm)
    await interaction.followup.send(
        f"Your **{species_name.replace('-', ' ').title()}** already knows 4 moves. Choose one to forget:",
        view=view,
        ephemeral=True,
    )


@bot.tree.command(name="move", description="Show level-up moves this Pok√©mon can learn now and later.")
@app_commands.describe(mon="Team slot (1-6) OR Pok√©mon name on your team")
async def move_cmd(interaction: discord.Interaction, mon: str):
    uid = str(interaction.user.id)
    await interaction.response.defer(ephemeral=True)

    mon_id, mon_row, err = await _resolve_team_mon_by_name_or_slot(uid, mon)
    if err:
        return await interaction.followup.send(f"‚ùå {err}", ephemeral=True)
    species_name = str(mon_row["species"])
    level = int(mon_row["level"])

    species_id = await _species_id_from_name(species_name)
    if not species_id:
        return await interaction.followup.send("‚ùå Could not resolve species in Pok√©dex.", ephemeral=True)

    try:
        user_gen = int(await _user_selected_gen(uid))
    except Exception:
        user_gen = 1
    gen_min, gen_max = _learnset_gen_bounds_for_user_gen(user_gen)

    rows = await _levelup_moves_for_species(int(species_id), gen_min, gen_max)
    if not rows:
        return await interaction.followup.send(
            f"‚ùå No level-up learnset data found for **{species_name.replace('-', ' ').title()}** "
            f"(Gen window: **{gen_min}-{gen_max}**).",
            ephemeral=True,
        )

    current = await _get_current_moves(uid, mon_id)
    current_norm = {_norm_move_name(m) for m in current}
    now_rows, locked_rows = _split_levelup_rows(rows, level)

    def _line(row: dict[str, Any]) -> str:
        mv = str(row.get("move_name") or "").strip()
        try:
            unlock = int(row.get("unlock_level") or 1)
        except Exception:
            unlock = 1
        mv_norm = _norm_move_name(mv)
        known_prefix = "‚úÖ " if mv_norm in current_norm else ""
        return f"{known_prefix}Lv.{int(unlock):>2} ‚Ä¢ {mv.replace('-', ' ').title()}"

    now_lines = [_line(r) for r in now_rows][:20]
    lock_lines = [_line(r) for r in locked_rows][:20]

    emb = discord.Embed(
        title=f"{species_name.replace('-', ' ').title()} ‚Äî Move Learnset",
        description=(
            f"Current level: **{int(level)}**\n"
            f"Generation rules: **Gen {int(user_gen)}** (level-up window **{gen_min}-{gen_max}**)"
        ),
        color=0x5865F2,
    )
    emb.add_field(
        name=f"Learnable now ({len(now_rows)})",
        value="\n".join(now_lines) if now_lines else "‚Äî",
        inline=False,
    )
    emb.add_field(
        name=f"Locked until later ({len(locked_rows)})",
        value="\n".join(lock_lines) if lock_lines else "‚Äî",
        inline=False,
    )
    emb.set_footer(text="‚úÖ = move already known")
    await interaction.followup.send(embed=emb, ephemeral=True)
# =========================
#  /release command
# =========================

class ReleaseConfirmView(discord.ui.View):
    """Confirmation view for releasing a Pok√©mon"""
    def __init__(self, author_id: int, mon_data: dict, timeout: float = 60.0):
        super().__init__(timeout=timeout)
        self.author_id = int(author_id)
        self.mon_data = mon_data
        self.confirmed = False

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if not await _check_required_role_interaction(interaction):
            return False
        if int(interaction.user.id) != self.author_id:
            await interaction.response.send_message("This isn't for you.", ephemeral=True)
            return False
        return True
    
    @discord.ui.button(label="‚úÖ Confirm Release", style=discord.ButtonStyle.danger)
    async def confirm_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.confirmed = True
        self.stop()
        await interaction.response.edit_message(content="‚úÖ Confirmed. Releasing Pok√©mon...", view=None)
    
    @discord.ui.button(label="‚ùå Cancel", style=discord.ButtonStyle.secondary)
    async def cancel_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.confirmed = False
        self.stop()
        await interaction.response.edit_message(content="‚ùå Release cancelled.", view=None)


@bot.tree.command(name="pklock", description="Lock or unlock a team Pok√©mon to prevent accidental release.")
@app_commands.describe(
    slot="Team slot (1-6)",
    lock="True = lock, False = unlock. Leave empty to toggle.",
)
async def pklock_command(
    interaction: discord.Interaction,
    slot: app_commands.Range[int, 1, 6],
    lock: Optional[bool] = None,
):
    await interaction.response.defer(ephemeral=True)
    uid = str(interaction.user.id)
    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT id, species FROM pokemons WHERE owner_id=? AND team_slot=? LIMIT 1",
            (uid, int(slot)),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return await interaction.followup.send(
                f"‚ùå No Pok√©mon found in team slot **{int(slot)}**.",
                ephemeral=True,
            )
        mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
        species = str(row["species"] if hasattr(row, "keys") else row[1]).replace("-", " ").title()
        currently_locked = await _is_pokemon_locked(uid, mon_id, conn=conn)
        target_locked = (not currently_locked) if lock is None else bool(lock)
        if target_locked != currently_locked:
            await _set_pokemon_locked(uid, mon_id, target_locked, conn=conn)
            await conn.commit()

    if target_locked == currently_locked:
        state_word = "already locked" if target_locked else "already unlocked"
        icon = "üîí" if target_locked else "üîì"
        return await interaction.followup.send(
            f"{icon} **{species}** is {state_word}.",
            ephemeral=True,
        )

    if target_locked:
        return await interaction.followup.send(
            f"üîí Locked **{species}** in slot **{int(slot)}**. It cannot be released until unlocked.",
            ephemeral=True,
        )
    return await interaction.followup.send(
        f"üîì Unlocked **{species}** in slot **{int(slot)}**.",
        ephemeral=True,
    )


@bot.tree.command(name="boxpklock", description="Lock or unlock a boxed Pok√©mon to prevent accidental release.")
@app_commands.describe(
    box_no="Box number",
    pos="Box slot position",
    lock="True = lock, False = unlock. Leave empty to toggle.",
)
async def boxpklock_command(
    interaction: discord.Interaction,
    box_no: app_commands.Range[int, 1, 64],
    pos: app_commands.Range[int, 1, 180],
    lock: Optional[bool] = None,
):
    await interaction.response.defer(ephemeral=True)
    uid = str(interaction.user.id)
    ok, msg, _count, _cap = await _validate_box_and_slot(uid, int(box_no), slot=int(pos))
    if not ok:
        return await interaction.followup.send(f"‚ùå {msg}", ephemeral=True)

    async with db.session() as conn:
        cur = await conn.execute(
            "SELECT id, species FROM pokemons WHERE owner_id=? AND team_slot IS NULL AND box_no=? AND box_pos=? LIMIT 1",
            (uid, int(box_no), int(pos)),
        )
        row = await cur.fetchone()
        await cur.close()
        if not row:
            return await interaction.followup.send(
                f"‚ùå No boxed Pok√©mon found at Box **{int(box_no)}**, Slot **{int(pos)}**.",
                ephemeral=True,
            )
        mon_id = int(row["id"] if hasattr(row, "keys") else row[0])
        species = str(row["species"] if hasattr(row, "keys") else row[1]).replace("-", " ").title()
        currently_locked = await _is_pokemon_locked(uid, mon_id, conn=conn)
        target_locked = (not currently_locked) if lock is None else bool(lock)
        if target_locked != currently_locked:
            await _set_pokemon_locked(uid, mon_id, target_locked, conn=conn)
            await conn.commit()

    if target_locked == currently_locked:
        state_word = "already locked" if target_locked else "already unlocked"
        icon = "üîí" if target_locked else "üîì"
        return await interaction.followup.send(
            f"{icon} **{species}** is {state_word}.",
            ephemeral=True,
        )

    if target_locked:
        return await interaction.followup.send(
            f"üîí Locked **{species}** at Box **{int(box_no)}**, Slot **{int(pos)}**. It cannot be released until unlocked.",
            ephemeral=True,
        )
    return await interaction.followup.send(
        f"üîì Unlocked **{species}** at Box **{int(box_no)}**, Slot **{int(pos)}**.",
        ephemeral=True,
    )

@bot.tree.command(name="release", description="Release a Pok√©mon from your team")
@app_commands.describe(slot="Team slot (1-6) to release")
async def release_pokemon(interaction: discord.Interaction, slot: app_commands.Range[int, 1, 6]):
    """Release a Pok√©mon from the specified team slot after confirmation"""
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    
    # Check if user is admin (admins bypass safety checks)
    is_admin = await _is_admin_user(uid)
    
    # Get the Pok√©mon in the specified slot
    conn = await db.connect()
    try:
        cur = await conn.execute(
            "SELECT * FROM pokemons WHERE owner_id = ? AND team_slot = ? LIMIT 1",
            (uid, slot)
        )
        row = await cur.fetchone()
        await cur.close()

        if not row:
            return await interaction.followup.send(
                f"‚ùå No Pok√©mon found in slot **{slot}**.",
                ephemeral=True
            )

        mon = dict(row)
        mon_id = int(mon.get("id") or 0)

        if mon_id > 0 and await _is_pokemon_locked(uid, mon_id, conn=conn):
            return await interaction.followup.send(
                f"üîí **{mon['species']}** in slot **{slot}** is locked. Use `/pklock slot:{int(slot)} lock:false` first.",
                ephemeral=True,
            )

        # Safety checks (only for non-admins)
        if not is_admin:
            # Check if this is the user's starter
            cur = await conn.execute(
                "SELECT starter FROM users WHERE user_id = ? LIMIT 1",
                (uid,)
            )
            starter_row = await cur.fetchone()
            await cur.close()

            if starter_row and starter_row['starter']:
                starter_species = starter_row['starter'].lower()
                if mon['species'].lower() == starter_species:
                    return await interaction.followup.send(
                        f"‚ùå You cannot release your starter Pok√©mon (**{mon['species']}**)!",
                        ephemeral=True
                    )

            # Check if this is the user's last Pok√©mon in team
            non_egg_team_count = await _team_non_egg_count(uid, conn=conn)
            mon_species_norm = _daycare_norm_species(mon.get("species"))
            if mon_species_norm != "egg" and int(non_egg_team_count) <= 1:
                return await interaction.followup.send(
                    f"‚ùå You cannot release your last non-egg Pok√©mon! You must always have at least one non-egg Pok√©mon in your team.",
                    ephemeral=True
                )

        # Create preview embed
        description = f"Are you sure you want to release this Pok√©mon? **This cannot be undone!**"
        if is_admin:
            description += f"\n\nüîß *Admin mode: Safety checks bypassed*"

        embed = discord.Embed(
            title=f"‚ö†Ô∏è Release {mon['species']}?",
            description=description,
            color=discord.Color.red()
        )

        # Add Pok√©mon details
        embed.add_field(name="Species", value=mon['species'], inline=True)
        embed.add_field(name="Level", value=str(mon['level']), inline=True)
        embed.add_field(name="Slot", value=str(slot), inline=True)

        # Add nature if available
        if mon.get('nature'):
            embed.add_field(name="Nature", value=mon['nature'].title(), inline=True)

        # Add shiny status
        if mon.get('shiny'):
            embed.add_field(name="‚ú® Shiny", value="Yes", inline=True)

        # Add held item if any
        if mon.get('held_item'):
            embed.add_field(name="Held Item", value=mon['held_item'], inline=True)

        # Create confirmation view
        view = ReleaseConfirmView(interaction.user.id, mon)
        msg = await interaction.followup.send(embed=embed, view=view, ephemeral=True)

        # Wait for user response
        await view.wait()

        if view.confirmed:
            # Return held item to bag if any
            held_item = mon.get('held_item')
            item_msg = ""
            if held_item:
                try:
                    await db.give_item(uid, str(held_item), 1)
                    item_msg = f"\nüì¶ Returned {pretty_item_name(str(held_item))} to your bag."
                except Exception:
                    item_msg = f"\nüì¶ Returned held item to your bag."

            # Permanently release from roster.
            await conn.execute(
                "DELETE FROM pokemons WHERE owner_id = ? AND id = ?",
                (uid, mon['id'])
            )
            await conn.execute(
                "DELETE FROM pokemon_locks WHERE owner_id = ? AND mon_id = ?",
                (uid, mon['id']),
            )
            try:
                await _ensure_pokemon_nicknames_table(conn)
                await conn.execute(
                    "DELETE FROM pokemon_nicknames WHERE owner_id = ? AND mon_id = ?",
                    (uid, mon['id']),
                )
            except Exception:
                pass
            await conn.commit()
            db.invalidate_pokemons_cache(uid)
            await _compact_team_slots(uid)

            await interaction.followup.send(
                f"‚úÖ Successfully released **{mon['species']}** from slot **{slot}**.{item_msg}",
                ephemeral=True
            )
    # else: cancellation message already sent by button callback
    finally:
        try:
            await conn.close()
        except Exception:
            pass

# =========================
#  legacy clearteam helper (command removed)
# =========================

async def _clear_team_internal(interaction: discord.Interaction):
    """Release all Pok√©mon in the user's team."""
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    
    # Check if user is admin (admins bypass safety checks)
    is_admin = await _is_admin_user(uid)
    
    conn = await db.connect()
    try:
        # Get all Pok√©mon in the team
        cur = await conn.execute(
            "SELECT id, species, team_slot, held_item FROM pokemons WHERE owner_id = ? AND team_slot BETWEEN 1 AND 6 ORDER BY team_slot",
            (uid,)
        )
        team_mons = await cur.fetchall()
        await cur.close()
        
        if not team_mons:
            return await interaction.followup.send(
                "‚ùå Your team is already empty!",
                ephemeral=True
            )

        locked_mon_ids = await _get_locked_pokemon_ids(uid, conn=conn)
        
        # Safety checks (only for non-admins)
        if not is_admin:
            # Check if any of these are the user's starter
            cur = await conn.execute(
                "SELECT starter FROM users WHERE user_id = ? LIMIT 1",
                (uid,)
            )
            starter_row = await cur.fetchone()
            await cur.close()
            
            starter_species = None
            if starter_row and starter_row.get('starter'):
                starter_species = starter_row['starter'].lower()
            
            # Check if any team member is the starter
            for mon in team_mons:
                mon_dict = dict(mon)
                if starter_species and mon_dict['species'].lower() == starter_species:
                    return await interaction.followup.send(
                        f"‚ùå You cannot release your starter Pok√©mon (**{mon_dict['species']}**)! Use `/release` on individual slots to exclude it.",
                        ephemeral=True
                    )

            non_egg_team = [dict(m) for m in team_mons if _daycare_norm_species(dict(m).get("species")) != "egg"]
            if len(non_egg_team) <= 1:
                return await interaction.followup.send(
                    "‚ùå You must keep at least one non-egg Pok√©mon in your team.",
                    ephemeral=True,
                )
        
        # Release all Pok√©mon in the team (non-admin keeps one non-egg Pok√©mon).
        released_count = 0
        items_returned = []
        locked_kept: list[str] = []
        keep_id: Optional[int] = None
        keep_species: Optional[str] = None
        if not is_admin:
            for mon in team_mons:
                md = dict(mon)
                mid = int(md.get("id") or 0)
                if mid > 0 and mid in locked_mon_ids:
                    continue
                if _daycare_norm_species(md.get("species")) != "egg":
                    keep_id = int(md.get("id"))
                    keep_species = str(md.get("species") or "Pok√©mon")
                    break
        
        for mon in team_mons:
            mon_dict = dict(mon)
            mon_id = int(mon_dict['id'])
            if mon_id in locked_mon_ids:
                locked_kept.append(str(mon_dict.get("species") or "Pok√©mon"))
                continue
            if keep_id is not None and int(mon_id) == int(keep_id):
                continue
            held_item = mon_dict.get('held_item')
            
            # Track items to return
            if held_item:
                items_returned.append(held_item)
            
            # Permanently release Pok√©mon.
            await conn.execute(
                "DELETE FROM pokemons WHERE owner_id = ? AND id = ?",
                (uid, mon_id)
            )
            await conn.execute(
                "DELETE FROM pokemon_locks WHERE owner_id = ? AND mon_id = ?",
                (uid, mon_id),
            )
            try:
                await _ensure_pokemon_nicknames_table(conn)
                await conn.execute(
                    "DELETE FROM pokemon_nicknames WHERE owner_id = ? AND mon_id = ?",
                    (uid, mon_id),
                )
            except Exception:
                pass
            released_count += 1
        
        # Commit the team changes first
        await conn.commit()
        db.invalidate_pokemons_cache(uid)
        
        # Now return items to bag (in a separate transaction to avoid locks)
        for held_item in items_returned:
            try:
                await db.give_item(uid, held_item, 1)
            except Exception as item_err:
                print(f"[clearteam] Warning: Failed to return item {held_item}: {item_err}")
        
        # Build response message
        response_parts = [f"‚úÖ Successfully released **{released_count}** Pok√©mon from your team."]
        if keep_species:
            response_parts.append(f"üõ°Ô∏è Kept **{keep_species}** in your team to satisfy the minimum-team rule.")
        if locked_kept:
            response_parts.append(
                f"üîí Kept **{len(locked_kept)}** locked Pok√©mon. "
                f"Use `/pklock` or `/boxpklock` to unlock before releasing."
            )
        
        if items_returned:
            unique_items = list(set(items_returned))
            item_count = len(unique_items)
            if item_count == 1:
                response_parts.append(f"üì¶ Returned **{unique_items[0]}** to your bag.")
            else:
                response_parts.append(f"üì¶ Returned **{item_count}** items to your bag.")
        
        await interaction.followup.send("\n".join(response_parts), ephemeral=True)
        
    except Exception as e:
        await conn.rollback()
        import traceback
        traceback.print_exc()
        await interaction.followup.send(
            f"‚ùå Error clearing team: {str(e)}",
            ephemeral=True
        )
    finally:
        try:
            await conn.close()
        except Exception:
            pass


# =========================
#  /swap command
# =========================

@bot.tree.command(name="swap", description="Swap two Pok√©mon in your team")
@app_commands.describe(
    slot1="First team slot (1-6)",
    slot2="Second team slot (1-6)"
)
async def swap_pokemon(
    interaction: discord.Interaction,
    slot1: app_commands.Range[int, 1, 6],
    slot2: app_commands.Range[int, 1, 6]
):
    """Swap the positions of two Pok√©mon in the team"""
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    
    if slot1 == slot2:
        return await interaction.followup.send(
            "‚ùå You must specify two different slots!",
            ephemeral=True
        )
    
    conn = await db.connect()
    try:
        # Get both Pok√©mon
        cur = await conn.execute(
            "SELECT id, species, team_slot FROM pokemons WHERE owner_id = ? AND team_slot IN (?, ?)",
            (uid, slot1, slot2)
        )
        rows = await cur.fetchall()
        await cur.close()

        # Map slots to Pok√©mon
        pokemon_by_slot = {row['team_slot']: dict(row) for row in rows}

        mon1 = pokemon_by_slot.get(slot1)
        mon2 = pokemon_by_slot.get(slot2)

        # Check if both slots have Pok√©mon
        if not mon1 and not mon2:
            return await interaction.followup.send(
                f"‚ùå No Pok√©mon found in slots **{slot1}** and **{slot2}**.",
                ephemeral=True
            )

        # Perform the swap
        if mon1 and mon2:
            # Both slots occupied - swap them
            # Use a temporary slot to avoid constraint violations
            await conn.execute("UPDATE pokemons SET team_slot = -1 WHERE id = ?", (mon1['id'],))
            await conn.execute("UPDATE pokemons SET team_slot = ? WHERE id = ?", (slot1, mon2['id']))
            await conn.execute("UPDATE pokemons SET team_slot = ? WHERE id = ?", (slot2, mon1['id']))
            await conn.commit()
            db.invalidate_pokemons_cache(uid)
            
            await interaction.followup.send(
                f"‚úÖ Swapped **{mon1['species']}** (slot {slot1}) with **{mon2['species']}** (slot {slot2}).",
                ephemeral=True
            )
        elif mon1:
            # Only slot1 occupied - move to slot2
            await conn.execute("UPDATE pokemons SET team_slot = ? WHERE id = ?", (slot2, mon1['id']))
            await conn.commit()
            db.invalidate_pokemons_cache(uid)
            
            await interaction.followup.send(
                f"‚úÖ Moved **{mon1['species']}** from slot **{slot1}** to slot **{slot2}**.",
                ephemeral=True
            )
        elif mon2:
            # Only slot2 occupied - move to slot1
            await conn.execute("UPDATE pokemons SET team_slot = ? WHERE id = ?", (slot1, mon2['id']))
            await conn.commit()
            db.invalidate_pokemons_cache(uid)
            
            await interaction.followup.send(
                f"‚úÖ Moved **{mon2['species']}** from slot **{slot2}** to slot **{slot1}**.",
                ephemeral=True
            )
    except Exception as e:
        await conn.rollback()
        await interaction.followup.send(
            f"‚ùå Error swapping Pok√©mon: {e}",
            ephemeral=True
        )
    finally:
        try:
            await conn.close()
        except Exception:
            pass

# =========================
#  /transform - Transform Pok√©mon Forms
# =========================

# Form transformation data
TRANSFORM_DATA = {
    "rotom": {
        "forms": ["normal", "heat", "wash", "frost", "fan", "mow"],
        "items": {
            "heat": "oven",
            "wash": "washing-machine",
            "frost": "refrigerator",
            "fan": "fan",
            "mow": "lawnmower"
        },
        "types": {
            "normal": ["Electric", "Ghost"],
            "heat": ["Electric", "Fire"],
            "wash": ["Electric", "Water"],
            "frost": ["Electric", "Ice"],
            "fan": ["Electric", "Flying"],
            "mow": ["Electric", "Grass"]
        }
    },
    "deoxys": {
        "forms": ["normal", "attack", "defense", "speed"],
        "items": {
            "attack": "meteorite",
            "defense": "meteorite",
            "speed": "meteorite"
        },
        "types": {"normal": ["Psychic"], "attack": ["Psychic"], "defense": ["Psychic"], "speed": ["Psychic"]}
    },
    "shaymin": {
        "forms": ["land", "sky"],
        "items": {"sky": "gracidea"},
        "types": {"land": ["Grass"], "sky": ["Grass", "Flying"]}
    },
    "necrozma": {
        "forms": ["normal", "dusk-mane", "dawn-wings"],
        "items": {
            "dusk-mane": "n-solarizer--merge",
            "dawn-wings": "n-lunarizer--merge"
        },
        "types": {"normal": ["Psychic"], "dusk-mane": ["Psychic", "Steel"], "dawn-wings": ["Psychic", "Ghost"]},
        "requires_fusion": {
            "dusk-mane": "solgaleo",
            "dawn-wings": "lunala"
        }
    },
    "kyurem": {
        "forms": ["normal", "white", "black"],
        "items": {"white": "dna-splicers", "black": "dna-splicers"},
        "types": {"normal": ["Dragon", "Ice"], "white": ["Dragon", "Ice"], "black": ["Dragon", "Ice"]},
        "requires_fusion": {
            "white": "reshiram",
            "black": "zekrom"
        }
    },
    "calyrex": {
        "forms": ["normal", "ice-rider", "shadow-rider"],
        "items": {"ice-rider": "reins-of-unity", "shadow-rider": "reins-of-unity"},
        "types": {"normal": ["Psychic", "Grass"], "ice-rider": ["Psychic", "Ice"], "shadow-rider": ["Psychic", "Ghost"]},
        "requires_fusion": {
            "ice-rider": "glastrier",
            "shadow-rider": "spectrier"
        }
    },
    "hoopa": {
        "forms": ["confined", "unbound"],
        "items": {"unbound": "prison-bottle"},
        "types": {"confined": ["Psychic", "Ghost"], "unbound": ["Psychic", "Dark"]}
    },
    "tornadus": {
        "forms": ["incarnate", "therian"],
        "items": {"therian": "reveal-glass"},
        "types": {"incarnate": ["Flying"], "therian": ["Flying"]}
    },
    "thundurus": {
        "forms": ["incarnate", "therian"],
        "items": {"therian": "reveal-glass"},
        "types": {"incarnate": ["Electric", "Flying"], "therian": ["Electric", "Flying"]}
    },
    "landorus": {
        "forms": ["incarnate", "therian"],
        "items": {"therian": "reveal-glass"},
        "types": {"incarnate": ["Ground", "Flying"], "therian": ["Ground", "Flying"]}
    },
    "enamorus": {
        "forms": ["incarnate", "therian"],
        "items": {"therian": "reveal-glass"},
        "types": {"incarnate": ["Fairy", "Flying"], "therian": ["Fairy", "Flying"]}
    }
}

async def form_autocomplete(
    interaction: discord.Interaction,
    current: str,
) -> list[app_commands.Choice[str]]:
    """Autocomplete for forme selection based on species"""
    # Get the current pokemon parameter value
    namespace = interaction.namespace
    pokemon_name = getattr(namespace, 'pokemon', '').lower()
    
    if not pokemon_name or pokemon_name not in TRANSFORM_DATA:
        return []
    
    forms = TRANSFORM_DATA[pokemon_name]["forms"]
    return [
        app_commands.Choice(name=form.title(), value=form)
        for form in forms
        if current.lower() in form.lower()
    ][:25]

@bot.tree.command(name="transform", description="Transform a Pok√©mon into a different forme")
@app_commands.describe(
    pokemon="The Pok√©mon species to transform (e.g., Rotom, Deoxys, Shaymin)",
    slot="Team slot (1-6)",
    form="The forme to transform into"
)
@app_commands.autocomplete(form=form_autocomplete)
async def transform_pokemon(
    interaction: discord.Interaction,
    pokemon: str,
    slot: app_commands.Range[int, 1, 6],
    form: str
):
    """Transform a Pok√©mon into a different forme using transformation items"""
    await interaction.response.defer(ephemeral=False)
    uid = str(interaction.user.id)
    
    pokemon_lower = pokemon.lower().strip()
    form_lower = form.lower().strip()
    
    # Check if this Pok√©mon can be transformed
    if pokemon_lower not in TRANSFORM_DATA:
        return await interaction.followup.send(
            f"‚ùå **{pokemon.title()}** cannot be transformed using this command.\n"
            f"Transformable Pok√©mon: {', '.join([p.title() for p in TRANSFORM_DATA.keys()])}",
            ephemeral=True
        )
    
    transform_info = TRANSFORM_DATA[pokemon_lower]
    
    # Check if the forme is valid
    if form_lower not in transform_info["forms"]:
        valid_forms = ", ".join([f.title() for f in transform_info["forms"]])
        return await interaction.followup.send(
            f"‚ùå Invalid forme for **{pokemon.title()}**!\n"
            f"Available formes: {valid_forms}",
            ephemeral=True
        )
    
    conn = await db.connect()
    
    try:
        # Get the Pok√©mon from the specified slot
        cur = await conn.execute(
            "SELECT id, species, form FROM pokemons WHERE owner_id = ? AND team_slot = ?",
            (uid, slot)
        )
        mon_row = await cur.fetchone()
        await cur.close()
    
        if not mon_row:
            return await interaction.followup.send(
                f"‚ùå No Pok√©mon found in slot **{slot}**!",
                ephemeral=True
            )
    
        mon = dict(mon_row)
    
        # Check if species matches
        if mon['species'].lower() != pokemon_lower:
            return await interaction.followup.send(
                f"‚ùå The Pok√©mon in slot **{slot}** is **{mon['species']}**, not **{pokemon.title()}**!",
                ephemeral=True
            )
    
        # Check if already in this form
        current_form = mon['form'] or transform_info["forms"][0]  # Default to first form if None
        if current_form == form_lower:
            return await interaction.followup.send(
                f"‚ùå Your **{mon['species']}** is already in **{form_lower.title()}** forme!",
                ephemeral=True
            )
    
        # Check if reverting to normal (free action)
        is_reverting = form_lower == transform_info["forms"][0]
    
        # Initialize fusion partner variables
        fusion_partner_id = None
        fusion_partner_species = None
    
        if not is_reverting:
            # Check if user has the required item
            required_item = transform_info["items"].get(form_lower)
            if not required_item:
                return await interaction.followup.send(
                    f"‚ùå Cannot transform to **{form_lower.title()}** forme!",
                    ephemeral=True
                )
        
            # Check inventory
            cur = await conn.execute(
                "SELECT qty FROM user_items WHERE owner_id = ? AND item_id = ?",
                (uid, required_item)
            )
            item_row = await cur.fetchone()
            await cur.close()
        
            if not item_row or item_row['qty'] < 1:
                # Get item name for display
                cur = await conn.execute("SELECT name FROM items WHERE id = ?", (required_item,))
                item_name_row = await cur.fetchone()
                await cur.close()
                item_name = item_name_row['name'] if item_name_row else required_item
            
                return await interaction.followup.send(
                    f"‚ùå You don't have a **{item_name}** to transform your {mon['species']}!\n"
                    f"This item is required to transform into **{form_lower.title()}** forme.",
                    ephemeral=True
                )
        
            # Check if fusion partner is required (Kyurem, Necrozma, Calyrex)
            requires_fusion = transform_info.get("requires_fusion", {})
            fusion_partner_species = requires_fusion.get(form_lower)
        
            if fusion_partner_species:
                # Find all Pok√©mon of the required species
                cur = await conn.execute(
                    """SELECT id, species, team_slot, box_no, box_pos, level, shiny 
                       FROM pokemons 
                       WHERE owner_id = ? AND LOWER(species) = ?""",
                    (uid, fusion_partner_species.lower())
                )
                fusion_candidates = await cur.fetchall()
                await cur.close()
            
                if not fusion_candidates:
                    return await interaction.followup.send(
                        f"‚ùå You need a **{fusion_partner_species.title()}** to fuse with your {pokemon.title()}!",
                        ephemeral=True
                    )
            
                # If multiple candidates, ask user to choose
                if len(fusion_candidates) > 1:
                    class FusionPartnerSelect(ui.View):
                        def __init__(self, candidates, timeout=60):
                            super().__init__(timeout=timeout)
                            self.selected_id = None
                            self.candidates = candidates
                        
                            # Create dropdown with candidates
                            options = []
                            for cand in candidates[:25]:  # Discord limit
                                cand_dict = dict(cand)
                                location = f"Slot {cand_dict['team_slot']}" if cand_dict.get('team_slot') else f"Box {cand_dict.get('box_no', '?')}"
                                shiny_marker = "‚ú® " if cand_dict.get('shiny') else ""
                                options.append(
                                    discord.SelectOption(
                                        label=f"{shiny_marker}{fusion_partner_species.title()} - Lv.{cand_dict['level']} ({location})",
                                        value=str(cand_dict['id'])
                                    )
                                )
                        
                            select = ui.Select(placeholder=f"Choose which {fusion_partner_species.title()} to fuse with...", options=options)
                        
                            async def select_callback(interaction: discord.Interaction):
                                self.selected_id = int(select.values[0])
                                await interaction.response.edit_message(
                                    content=f"‚úÖ Selected {fusion_partner_species.title()}! Proceeding with fusion...",
                                    view=None
                                )
                                self.stop()
                        
                            select.callback = select_callback
                            self.add_item(select)
                
                    view = FusionPartnerSelect(fusion_candidates)
                    await interaction.followup.send(
                        f"‚ùì You have multiple **{fusion_partner_species.title()}**. Please choose which one to fuse with:",
                        view=view,
                        ephemeral=True
                    )
                
                    await view.wait()
                
                    if view.selected_id is None:
                        return await interaction.followup.send("‚ùå Fusion cancelled (timed out).", ephemeral=True)
                
                    fusion_partner_id = view.selected_id
                else:
                    # Only one candidate, use it
                    fusion_partner_id = fusion_candidates[0]['id']
    
        # Perform the transformation
        try:
            # Get current Pok√©mon data (IVs, EVs, nature, level for stat recalculation)
            cur = await conn.execute(
                "SELECT id, species, level, ivs, evs, nature FROM pokemons WHERE owner_id = ? AND team_slot = ?",
                (uid, slot)
            )
            full_mon = await cur.fetchone()
            await cur.close()
        
            if not full_mon:
                return await interaction.followup.send("‚ùå Pok√©mon not found!", ephemeral=True)
        
            full_mon = dict(full_mon)
        
            # Fetch base stats for the new forme
            # First try database, then PokeAPI if needed
            forme_key = f"{pokemon_lower}-{form_lower}" if form_lower != transform_info["forms"][0] else pokemon_lower
        
            # 1. Try to fetch from local database first (fastest)
            forme_data = await db.get_pokedex_by_name(forme_key)
        
            if not forme_data:
                # 2. Try to fetch from PokeAPI and cache it
                print(f"[TRANSFORM] Fetching {forme_key} from PokeAPI...")
                try:
                    forme_data = await ensure_species_and_learnsets(forme_key)
                except Exception as api_err:
                    print(f"[TRANSFORM] PokeAPI fetch failed for {forme_key}: {api_err}")
                    forme_data = None
        
            if not forme_data:
                # 3. Fallback to base species
                print(f"[TRANSFORM] Using base species stats for {pokemon_lower}...")
                forme_data = await db.get_pokedex_by_name(pokemon_lower)
            
                if not forme_data:
                    # Last resort: try PokeAPI for base species
                    try:
                        forme_data = await ensure_species_and_learnsets(pokemon_lower)
                    except Exception:
                        pass
        
            if not forme_data:
                return await interaction.followup.send(
                    f"‚ùå Could not find base stats for {pokemon.title()}!",
                    ephemeral=True
                )
        
            # Extract stats from database/API row
            new_base_stats = forme_data.get("stats") or {}
            if isinstance(new_base_stats, str):
                import json
                new_base_stats = json.loads(new_base_stats)
        
            # Normalize base stats to long keys
            base_stats_long = normalize_base_stats(new_base_stats)
        
            # Parse IVs and EVs from JSON
            import json
            ivs = json.loads(full_mon['ivs']) if isinstance(full_mon['ivs'], str) else full_mon['ivs']
            evs = json.loads(full_mon['evs']) if isinstance(full_mon['evs'], str) else full_mon['evs']
        
            # Recalculate stats with new base stats (using existing IVs, EVs, nature, level)
            final_stats = stats.calc_all_stats(
                base_stats=base_stats_long,
                ivs=ivs,
                evs=evs,
                level=full_mon['level'],
                nature=full_mon['nature']
            )
        
            # Update form AND stats in database
            # NOTE: This ONLY updates form and stats. All other attributes are preserved:
            # shiny, gender, friendship, ivs, evs, held_item, moves, ability, nature, level, pokeball, etc.
            # IVs from the base Pokemon are kept (this matches official game mechanics for fusions)
            await conn.execute(
                """UPDATE pokemons 
                   SET form = ?, hp = ?, atk = ?, def = ?, spa = ?, spd = ?, spe = ?
                   WHERE id = ?""",
                (
                    form_lower if form_lower != transform_info["forms"][0] else None,
                    final_stats['hp'],
                    final_stats['attack'],
                    final_stats['defense'],
                    final_stats['special_attack'],
                    final_stats['special_defense'],
                    final_stats['speed'],
                    mon['id']
                )
            )
        
            # Handle fusion partner (Kyurem/Necrozma/Calyrex fusions)
            if fusion_partner_id and not is_reverting:
                # Store fusion partner data before absorbing
                cur = await conn.execute(
                    """SELECT species, level, hp, atk, def, spa, spd, spe, ivs, evs, nature, 
                              ability, gender, friendship, held_item, moves, shiny, pokeball
                       FROM pokemons WHERE id = ?""",
                    (fusion_partner_id,)
                )
                partner_data = await cur.fetchone()
                await cur.close()
            
                if partner_data:
                    partner_dict = dict(partner_data)
                    # Store partner data as JSON in the base Pok√©mon
                    import json
                    fusion_data_json = json.dumps(partner_dict)
                
                    await conn.execute(
                        "UPDATE pokemons SET fusion_data = ? WHERE id = ?",
                        (fusion_data_json, mon['id'])
                    )
                
                    # Remove fusion partner from team/box (absorbed)
                    await conn.execute(
                        "DELETE FROM pokemons WHERE id = ?",
                        (fusion_partner_id,)
                    )
        
            # Handle defusion (reverting from fused forme)
            if is_reverting and transform_info.get("requires_fusion"):
                # Check if this was a fused forme
                cur = await conn.execute(
                    "SELECT fusion_data FROM pokemons WHERE id = ?",
                    (mon['id'],)
                )
                fusion_row = await cur.fetchone()
                await cur.close()
            
                if fusion_row and fusion_row['fusion_data']:
                    # Restore the absorbed Pok√©mon
                    import json
                    partner_data = json.loads(fusion_row['fusion_data'])
                
                    # Insert the partner back into the PC (box 1)
                    await conn.execute(
                        """INSERT INTO pokemons 
                           (owner_id, species, level, hp, atk, def, spa, spd, spe, ivs, evs, nature,
                            ability, gender, friendship, held_item, moves, shiny, pokeball, box_no, box_pos)
                           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                        (
                            uid,
                            partner_data['species'],
                            partner_data['level'],
                            partner_data['hp'],
                            partner_data['atk'],
                            partner_data['def'],
                            partner_data['spa'],
                            partner_data['spd'],
                            partner_data['spe'],
                            partner_data['ivs'],
                            partner_data['evs'],
                            partner_data['nature'],
                            partner_data.get('ability'),
                            partner_data.get('gender'),
                            partner_data.get('friendship', 50),
                            partner_data.get('held_item'),
                            partner_data['moves'],
                            partner_data.get('shiny', 0),
                            partner_data.get('pokeball'),
                            1,  # box_no
                            None  # box_pos will be determined by system
                        )
                    )
                
                    # Clear fusion data from base Pok√©mon
                    await conn.execute(
                        "UPDATE pokemons SET fusion_data = NULL WHERE id = ?",
                        (mon['id'],)
                    )
        
            await conn.commit()
            db.invalidate_pokemons_cache(uid)
        
            # Success message
            if is_reverting:
                message = f"‚úÖ Your **{mon['species']}** has reverted to its **{form_lower.title()}** forme!"
            
                # Check if we restored a fusion partner
                if transform_info.get("requires_fusion"):
                    cur = await conn.execute(
                        "SELECT species FROM pokemons WHERE owner_id = ? ORDER BY id DESC LIMIT 1",
                        (uid,)
                    )
                    last_pokemon = await cur.fetchone()
                    await cur.close()
                
                    if last_pokemon:
                        restored_species = last_pokemon['species'].title()
                        message += f"\nüîì **{restored_species}** has been restored and placed in Box 1!"
            else:
                message = f"‚úÖ Your **{mon['species']}** has transformed into **{form_lower.title()}** forme!"
            
                # Add fusion partner info if applicable
                if fusion_partner_id:
                    message += f"\nüîó **{fusion_partner_species.title()}** has been absorbed into the fusion!"
        
            # Add type and stat info
            new_types = transform_info["types"].get(form_lower, [])
            if new_types:
                type_str = "/".join(new_types)
                message += f"\n**Type:** {type_str}"
        
            message += f"\n**Stats Updated:** HP: {final_stats['hp']}, Atk: {final_stats['attack']}, Def: {final_stats['defense']}, SpA: {final_stats['special_attack']}, SpD: {final_stats['special_defense']}, Spe: {final_stats['speed']}"
            message += f"\n\nüìä **IVs/EVs from base {pokemon.title()} are preserved** (official game mechanic)"
        
            await interaction.followup.send(message, ephemeral=True)
        
        except Exception as e:
            await conn.rollback()
            await interaction.followup.send(
                f"‚ùå Error transforming Pok√©mon: {e}",
                ephemeral=True
            )
        finally:
            try:
                await conn.close()
            except Exception:
                pass
    finally:
        try:
            await conn.close()
        except Exception:
            pass


# =========================
#  Clean startup with DB
# =========================
async def main():
    await db.init_schema()
    try:
        await bot.start(TOKEN)
    finally:
        await db.close()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass  # Ctrl+C: exit cleanly without traceback

# yo yo yo yo